// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;
using qx.data;

namespace qx.core
{
    /// <summary>
	/// <para>The qooxdoo root class. All other classes are direct or indirect subclasses of this one.</para>
	/// <para>This class contains methods for:</para>
	/// <list type="bullet">
	/// <item>object management (creation and destruction)</item>
	/// <item>interfaces for event system</item>
	/// <item>generic setter/getter support</item>
	/// <item>interfaces for logging console</item>
	/// <item>user friendly OO interfaces like <see cref="Self"/> or <see cref="Base"/></item>
	/// </list
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.core.Object", OmitOptionalParameters = true, Export = false)]
    public partial class Object : object
    {
		#region Methods

		/// <summary>
		/// <para>Create a new instance</para>
		/// </summary>
		public Object() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Call the same method of the super class.</para>
		/// </summary>
		/// <param name="args">the arguments variable of the calling method</param>
		/// <param name="varags">variable number of arguments passed to the overwritten function</param>
		/// <returns>the return value of the method of the base class.</returns>
		[JsMethod(Name = "base")]
		public object Base(JsArguments args, object varags) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>EXPERIMENTAL &#8211; NOT READY FOR PRODUCTION</para>
		/// <para>Returns a clone of this object. Copies over all user configured
		/// property values. Do not configure a parent nor apply the appearance
		/// styles directly.</para>
		/// </summary>
		/// <returns>The clone</returns>
		[JsMethod(Name = "clone")]
		public qx.core.Object Clone() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Dispose this object</para>
		/// </summary>
		[JsMethod(Name = "dispose")]
		public void Dispose() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Load user defined data from the object</para>
		/// </summary>
		/// <param name="key">the key</param>
		/// <returns>the user data</returns>
		[JsMethod(Name = "getUserData")]
		public object GetUserData(string key) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns true if the object is disposed.</para>
		/// </summary>
		/// <returns>Whether the object has been disposed</returns>
		[JsMethod(Name = "isDisposed")]
		public bool IsDisposed() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the static class (to access static members of this class)</para>
		/// </summary>
		/// <param name="args">the arguments variable of the calling method</param>
		/// <returns>the return value of the method of the base class.</returns>
		[JsMethod(Name = "self")]
		public object Self(JsArguments args) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Store user defined data inside the object.</para>
		/// </summary>
		/// <param name="key">the key</param>
		/// <param name="value">the value of the user data</param>
		[JsMethod(Name = "setUserData")]
		public void SetUserData(string key, object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Return unique hash code of object</para>
		/// </summary>
		/// <returns>unique hash code of the object</returns>
		[JsMethod(Name = "toHashCode")]
		public double ToHashCode() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a string representation of the qooxdoo object.</para>
		/// </summary>
		/// <returns>string representation of the object</returns>
		[JsMethod(Name = "toString")]
		public string ToString() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add event listener to this object.</para>
		/// </summary>
		/// <param name="type">name of the event type</param>
		/// <param name="listener">event callback function</param>
		/// <param name="self">Reference to the &#8216;this&#8217; variable inside the event listener. When not given, the corresponding dispatcher usually falls back to a default, which is the target by convention. Note this is not a strict requirement, i.e. custom dispatchers can follow a different strategy.</param>
		/// <param name="capture">Whether to attach the event to the capturing phase or the bubbling phase of the event. The default is to attach the event handler to the bubbling phase.</param>
		/// <returns>An opaque id, which can be used to remove the event listener using the #removeListenerById method.</returns>
		[JsMethod(Name = "addListener")]
		public string AddListener(string type, Action<qx.eventx.type.Data> listener, object self = null, bool capture = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add event listener to this object, which is only called once. After the
		/// listener is called the event listener gets removed.</para>
		/// </summary>
		/// <param name="type">name of the event type</param>
		/// <param name="listener">event callback function</param>
		/// <param name="self">reference to the &#8216;this&#8217; variable inside the callback</param>
		/// <param name="capture">Whether to attach the event to the capturing phase or the bubbling phase of the event. The default is to attach the event handler to the bubbling phase.</param>
		/// <returns>An opaque id, which can be used to remove the event listener using the #removeListenerById method.</returns>
		[JsMethod(Name = "addListenerOnce")]
		public string AddListenerOnce(string type, Action<qx.eventx.type.Data> listener, object self = null, bool capture = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Dispatch an event on this object</para>
		/// </summary>
		/// <param name="evt">event to dispatch</param>
		/// <returns>Whether the event default was prevented or not. Returns true, when the event was NOT prevented.</returns>
		[JsMethod(Name = "dispatchEvent")]
		public bool DispatchEvent(qx.eventx.type.Event evt) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Creates and dispatches an non-bubbling data event on this object.</para>
		/// </summary>
		/// <param name="type">Event type to fire</param>
		/// <param name="data">User defined data attached to the event object</param>
		/// <param name="oldData">The event&#8217;s old data (optional)</param>
		/// <param name="cancelable">Whether or not an event can have its default action prevented. The default action can either be the browser&#8217;s default action of a native event (e.g. open the context menu on a right click) or the default action of a qooxdoo class (e.g. close the window widget). The default action can be prevented by calling qx.event.type.Event#preventDefault</param>
		/// <returns>Whether the event default was prevented or not. Returns true, when the event was NOT prevented.</returns>
		[JsMethod(Name = "fireDataEvent")]
		public bool FireDataEvent(string type, object data, object oldData = null, bool cancelable = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Creates and dispatches an event on this object.</para>
		/// </summary>
		/// <param name="type">Event type to fire</param>
		/// <param name="clazz">The event class</param>
		/// <param name="args">Arguments, which will be passed to the event&#8217;s init method.</param>
		/// <returns>Whether the event default was prevented or not. Returns true, when the event was NOT prevented.</returns>
		[JsMethod(Name = "fireEvent")]
		public bool FireEvent(string type, Class clazz = null, JsArray args = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Create an event object and dispatch it on this object.
		/// The event dispatched with this method does never bubble! Use only if you
		/// are sure that bubbling is not required.</para>
		/// </summary>
		/// <param name="type">Event type to fire</param>
		/// <param name="clazz">The event class</param>
		/// <param name="args">Arguments, which will be passed to the event&#8217;s init method.</param>
		/// <returns>Whether the event default was prevented or not. Returns true, when the event was NOT prevented.</returns>
		[JsMethod(Name = "fireNonBubblingEvent")]
		public bool FireNonBubblingEvent(string type, Class clazz = null, JsArray args = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check if there are one or more listeners for an event type.</para>
		/// </summary>
		/// <param name="type">name of the event type</param>
		/// <param name="capture">Whether to check for listeners of the bubbling or of the capturing phase.</param>
		/// <returns>Whether the object has a listener of the given type.</returns>
		[JsMethod(Name = "hasListener")]
		public bool HasListener(string type, bool capture = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove event listener from this object</para>
		/// </summary>
		/// <param name="type">name of the event type</param>
		/// <param name="listener">event callback function</param>
		/// <param name="self">reference to the &#8216;this&#8217; variable inside the callback</param>
		/// <param name="capture">Whether to remove the event listener of the bubbling or of the capturing phase.</param>
		/// <returns>Whether the event was removed successfully (has existed)</returns>
		[JsMethod(Name = "removeListener")]
		public bool RemoveListener(string type, Action<qx.eventx.type.Data> listener, object self = null, bool? capture = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes an event listener from an event target by an id returned by
		/// <see cref="AddListener"/></para>
		/// </summary>
		/// <param name="id">The id returned by #addListener</param>
		/// <returns>Whether the event was removed successfully (has existed)</returns>
		[JsMethod(Name = "removeListenerById")]
		public bool RemoveListenerById(string id) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the condition evaluates to true.</para>
		/// </summary>
		/// <param name="condition">Condition to check for. Must evaluate to true.</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assert")]
		public void Assert(object condition, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the number of arguments is within the given range</para>
		/// </summary>
		/// <param name="args">The arguments variable of a function</param>
		/// <param name="minCount">Minimal number of arguments</param>
		/// <param name="maxCount">Maximum number of arguments</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertArgumentsCount")]
		public void AssertArgumentsCount(JsArguments args, double minCount, double maxCount, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is an array.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertArray")]
		public void AssertArray(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that both array have identical array items.</para>
		/// </summary>
		/// <param name="expected">The expected array</param>
		/// <param name="found">The found array</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertArrayEquals")]
		public void AssertArrayEquals(JsArray expected, JsArray found, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a boolean.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertBoolean")]
		public void AssertBoolean(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value represents the given CSS color value. This method
		/// parses the color strings and compares the RGB values. It is able to
		/// parse values supported by <see cref="qx.util.ColorUtil.StringToRgb"/>.</para>
		/// </summary>
		/// <param name="expected">The expected color</param>
		/// <param name="value">The value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertCssColor")]
		public void AssertCssColor(string expected, string value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a DOM element.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertElement")]
		public void AssertElement(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that both values are equal. (Uses the equality operator
		/// ==.)</para>
		/// </summary>
		/// <param name="expected">Reference value</param>
		/// <param name="found">found value</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertEquals")]
		public void AssertEquals(object expected, object found, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that an event is fired.</para>
		/// </summary>
		/// <param name="obj">The object on which the event should be fired.</param>
		/// <param name="eventx">The event which should be fired.</param>
		/// <param name="invokeFunc">The function which will be invoked and which fires the event.</param>
		/// <param name="listener">The function which will be invoked in the listener. The function has one parameter called e which is the event.</param>
		/// <param name="msg">Message to be shows if the assertion fails.</param>
		[JsMethod(Name = "assertEventFired")]
		public void AssertEventFired(object obj, string eventx, Action<object> invokeFunc, Action<qx.eventx.type.Data> listener = null, string msg = "") { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that an event is not fired.</para>
		/// </summary>
		/// <param name="obj">The object on which the event should be fired.</param>
		/// <param name="eventx">The event which should be fired.</param>
		/// <param name="invokeFunc">The function which will be invoked and which should not fire the event.</param>
		/// <param name="msg">Message to be shows if the assertion fails.</param>
		[JsMethod(Name = "assertEventNotFired")]
		public void AssertEventNotFired(object obj, string eventx, Action<object> invokeFunc, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Asserts that the callback raises a matching exception.</para>
		/// </summary>
		/// <param name="callback">function to check</param>
		/// <param name="exception">Expected constructor of the exception. The assertion fails if the raised exception is not an instance of the parameter.</param>
		/// <param name="re">The assertion fails if the error message does not match this parameter</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertException")]
		public void AssertException(Action<object> callback, JsError exception = null, object re = null, string msg = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is false (Identity check).</para>
		/// </summary>
		/// <param name="value">Condition to check for. Must be identical to false.</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertFalse")]
		public void AssertFalse(bool value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a function.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertFunction")]
		public void AssertFunction(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that both values are identical. (Uses the identity operator
		/// ===.)</para>
		/// </summary>
		/// <param name="expected">Reference value</param>
		/// <param name="found">found value</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertIdentical")]
		public void AssertIdentical(object expected, object found, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is an item in the given array.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="array">List of valid values</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertInArray")]
		public void AssertInArray(object value, JsArray array, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is inside the given range.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="min">lower bound</param>
		/// <param name="max">upper bound</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertInRange")]
		public void AssertInRange(object value, double min, double max, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is an instance of the given class.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="clazz">The value must be an instance of this class</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertInstance")]
		public void AssertInstance(object value, Class clazz, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is an integer.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertInteger")]
		public void AssertInteger(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value implements the given interface.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="iface">The value must implement this interface</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertInterface")]
		public void AssertInterface(object value, Class iface, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the first two arguments are equal, when serialized into
		/// JSON.</para>
		/// </summary>
		/// <param name="expected">The expected value</param>
		/// <param name="found">The found value</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertJsonEquals")]
		public void AssertJsonEquals(object expected, object found, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a key in the given map.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="map">Map, where the keys represent the valid values</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertKeyInMap")]
		public void AssertKeyInMap(object value, object map, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a map either created using new Object
		/// or by using the object literal notation { ... }.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertMap")]
		public void AssertMap(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the given string matches the regular expression</para>
		/// </summary>
		/// <param name="str">String, which should match the regular expression</param>
		/// <param name="re">Regular expression to match</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertMatch")]
		public void AssertMatch(string str, JsRegExp re, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that both values are not equal. (Uses the not equality operator
		/// !=.)</para>
		/// </summary>
		/// <param name="expected">Reference value</param>
		/// <param name="found">found value</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertNotEquals")]
		public void AssertNotEquals(object expected, object found, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that both values are not identical. (Uses the not identity operator
		/// !==.)</para>
		/// </summary>
		/// <param name="expected">Reference value</param>
		/// <param name="found">found value</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertNotIdentical")]
		public void AssertNotIdentical(object expected, object found, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is not null.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertNotNull")]
		public void AssertNotNull(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is not undefined.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertNotUndefined")]
		public void AssertNotUndefined(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is null.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertNull")]
		public void AssertNull(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a number.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertNumber")]
		public void AssertNumber(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is an object.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertObject")]
		public void AssertObject(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is an integer >= 0.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertPositiveInteger")]
		public void AssertPositiveInteger(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a number >= 0.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertPositiveNumber")]
		public void AssertPositiveNumber(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is an instance of <see cref="qx.core.Object"/>.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertQxObject")]
		public void AssertQxObject(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is an instance of <see cref="qx.ui.core.Widget"/>.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertQxWidget")]
		public void AssertQxWidget(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a regular expression.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertRegExp")]
		public void AssertRegExp(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is a string.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertString")]
		public void AssertString(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is true (Identity check).</para>
		/// </summary>
		/// <param name="value">Condition to check for. Must be identical to true.</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertTrue")]
		public void AssertTrue(bool value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value has the given type using the typeof
		/// operator. Because the type is not always what it is supposed to be it is
		/// better to use more explicit checks like <see cref="AssertString"/> or
		/// <see cref="AssertArray"/>.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="type">expected type of the value</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertType")]
		public void AssertType(object value, string type, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Assert that the value is undefined.</para>
		/// </summary>
		/// <param name="value">Value to check</param>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		[JsMethod(Name = "assertUndefined")]
		public void AssertUndefined(object value, string msg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Raise an <see cref="AssertionError"/></para>
		/// </summary>
		/// <param name="msg">Message to be shown if the assertion fails.</param>
		/// <param name="compact">Show less verbose message. Default: false.</param>
		[JsMethod(Name = "fail")]
		public void Fail(string msg, bool compact) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the value of the given property. If no generated getter could be
		/// found, a fallback tries to access a handwritten getter.</para>
		/// </summary>
		/// <param name="prop">Name of the property.</param>
		/// <returns>The value of the value</returns>
		[JsMethod(Name = "get")]
		public object Get(string prop) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the value of the given property. If no generated resetter could be
		/// found, a handwritten resetter will be invoked, if available.</para>
		/// </summary>
		/// <param name="prop">Name of the property.</param>
		[JsMethod(Name = "reset")]
		public void Reset(string prop) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets multiple properties at once by using a property list or
		/// sets one property and its value by the first and second argument.
		/// As a fallback, if no generated property setter could be found, a
		/// handwritten setter will be searched and invoked if available.</para>
		/// </summary>
		/// <param name="data">a map of property values. The key is the name of the property.</param>
		/// <param name="value">the value, only used when data is a string.</param>
		/// <returns>this instance.</returns>
		[JsMethod(Name = "set")]
		public object Set(object data, object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Logs a debug message.</para>
		/// </summary>
		/// <param name="varargs">The item(s) to log. Any number of arguments is supported. If an argument is not a string, the object dump will be logged.</param>
		[JsMethod(Name = "debug")]
		public void Debug(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Logs an error message.</para>
		/// </summary>
		/// <param name="varargs">The item(s) to log. Any number of arguments is supported. If an argument is not a string, the object dump will be logged.</param>
		[JsMethod(Name = "error")]
		public void Error(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Logs an info message.</para>
		/// </summary>
		/// <param name="varargs">The item(s) to log. Any number of arguments is supported. If an argument is not a string, the object dump will be logged.</param>
		[JsMethod(Name = "info")]
		public void Info(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Prints the current stack trace</para>
		/// </summary>
		[JsMethod(Name = "trace")]
		public void Trace() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Logs a warning message.</para>
		/// </summary>
		/// <param name="varargs">The item(s) to log. Any number of arguments is supported. If an argument is not a string, the object dump will be logged.</param>
		[JsMethod(Name = "warn")]
		public void Warn(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>The bind method delegates the call to the
		/// <see cref="qx.data.SingleValueBinding.Bind"/> function. As source, the current
		/// object (this) will be used.</para>
		/// </summary>
		/// <param name="sourcePropertyChain">The property chain which represents the source property.</param>
		/// <param name="targetObject">The object which the source should be bind to.</param>
		/// <param name="targetProperty">The property name of the target object.</param>
		/// <param name="options">A map containing the options. See qx.data.SingleValueBinding#bind for more information.</param>
		/// <returns>Returns the internal id for that binding. This can be used for referencing the binding e.g. for removing. This is not an atomic id so you can&#8217;t you use it as a hash-map index.</returns>
		[JsMethod(Name = "bind")]
		public object Bind(string sourcePropertyChain, qx.core.Object targetObject, string targetProperty, object options) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns an array which lists all bindings for the object.</para>
		/// </summary>
		/// <returns>An array of binding informations. Every binding information is an array itself containing id, sourceObject, sourceEvent, targetObject and targetProperty in that order.</returns>
		[JsMethod(Name = "getBindings")]
		public JsArray GetBindings() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all bindings from the object.</para>
		/// </summary>
		[JsMethod(Name = "removeAllBindings")]
		public void RemoveAllBindings() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the binding with the given id from the current object. The
		/// id hast to be the id returned by any of the bind functions.</para>
		/// </summary>
		/// <param name="id">The id of the binding.</param>
		[JsMethod(Name = "removeBinding")]
		public void RemoveBinding(object id) { throw new NotImplementedException(); }

		#endregion Methods
    }
}