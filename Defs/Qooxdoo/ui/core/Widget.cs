// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;
using qx.locale;

namespace qx.ui.core
{
    /// <summary>
	/// <para>This is the base class for all widgets.</para>
	/// <para>A widget consists of at least three HTML elements. The container element,
	/// which is
	/// added to the parent widget has two child Element: The &#8220;decoration&#8221; and the
	/// &#8220;content&#8221; element. The decoration element has a lower z-Index and contains
	/// markup to render the widget&#8217;s background and border using an implementation
	/// of <see cref="qx.ui.decoration.IDecorator"/>.The content element is positioned
	/// inside the &#8220;container&#8221; element to respect paddings and contains the &#8220;real&#8221;
	/// widget element.</para>
	/// 
	/// -container------------
	/// |                    |
	/// |  -decoration----   |
	/// |  | -content----|-  |
	/// |  | |           ||  |
	/// |  --|------------|  |
	/// |    --------------  |
	/// |                    |
	/// ----------------------
	/// </code>
	/// <para>External Documentation</para>
	/// 
	/// Documentation of this widget in the qooxdoo manual.
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.ui.core.Widget", OmitOptionalParameters = true, Export = false)]
    public partial class Widget : qx.ui.core.LayoutItem
    {
		#region Events

		/// <summary>
		/// <para>When the widget gets active (receives keyboard events etc.)</para>
		/// </summary>
		public event Action<qx.eventx.type.Focus> OnActivate;

		/// <summary>
		/// <para>Fired after the widget appears on the screen.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnAppear;

		/// <summary>
		/// <para>Fired before the context menu is opened.</para>
		/// </summary>
		public event Action<qx.eventx.type.Data> OnBeforeContextmenuOpen;

		/// <summary>
		/// <para>The event is fired when the widget gets blurred. Only widgets which are
		/// <see cref="Focusable"/> receive this event.</para>
		/// </summary>
		public event Action<qx.eventx.type.Focus> OnBlur;

		/// <summary>
		/// <para>Fired if the widget becomes the capturing widget by a call to <see cref="Capture"/>.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnCapture;

		/// <summary>
		/// Fired on change of the property <see cref="Appearance"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeAppearance;

		/// <summary>
		/// Fired on change of the property <see cref="BackgroundColor"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeBackgroundColor;

		/// <summary>
		/// Fired on change of the property <see cref="ContextMenu"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeContextMenu;

		/// <summary>
		/// Fired on change of the property <see cref="Decorator"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeDecorator;

		/// <summary>
		/// Fired on change of the property <see cref="Enabled"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeEnabled;

		/// <summary>
		/// Fired on change of the property <see cref="Font"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeFont;

		/// <summary>
		/// Fired on change of the property <see cref="NativeContextMenu"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeNativeContextMenu;

		/// <summary>
		/// Fired on change of the property <see cref="Selectable"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeSelectable;

		/// <summary>
		/// Fired on change of the property <see cref="Shadow"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeShadow;

		/// <summary>
		/// Fired on change of the property <see cref="TextColor"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeTextColor;

		/// <summary>
		/// Fired on change of the property <see cref="ToolTipText"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeToolTipText;

		/// <summary>
		/// Fired on change of the property <see cref="Visibility"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeVisibility;

		/// <summary>
		/// Fired on change of the property <see cref="ZIndex"/>.
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeZIndex;

		/// <summary>
		/// <para>Widget is clicked using left or middle button.
		/// <see cref="qx.event.type.Mouse.GetButton"/> for more details.</para>
		/// </summary>
		public event Action<qx.eventx.type.Mouse> OnClick;

		/// <summary>
		/// <para>Widget is clicked using the right mouse button.</para>
		/// </summary>
		public event Action<qx.eventx.type.Mouse> OnContextmenu;

		/// <summary>
		/// <para>Fired after the creation of a child control. The passed data is the
		/// newly created child widget.</para>
		/// </summary>
		public event Action<qx.eventx.type.Data> OnCreateChildControl;

		/// <summary>
		/// <para>Widget is double clicked using left or middle button.
		/// <see cref="qx.event.type.Mouse.GetButton"/> for more details.</para>
		/// </summary>
		public event Action<qx.eventx.type.Mouse> OnDblclick;

		/// <summary>
		/// <para>When the widget gets inactive</para>
		/// </summary>
		public event Action<qx.eventx.type.Focus> OnDeactivate;

		/// <summary>
		/// <para>Fired after the widget disappears from the screen.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnDisappear;

		/// <summary>
		/// <para>Fired during the drag. Contains the current mouse coordinates
		/// using <see cref="qx.event.type.Drag.GetDocumentLeft"/> and
		/// <see cref="qx.event.type.Drag.GetDocumentTop"/></para>
		/// <para>Modeled after the WHATWG specification of Drag&amp;Drop:
		/// http://www.whatwg.org/specs/web-apps/current-work/#dnd</para>
		/// </summary>
		public event Action<qx.eventx.type.Drag> OnDrag;

		/// <summary>
		/// <para>Fired when the drag configuration has been modified e.g. the user
		/// pressed a key which changed the selected action. This event will be
		/// fired on the draggable and the droppable element. In case of the
		/// droppable element, you can cancel the event and prevent a drop based on
		/// e.g. the current action.</para>
		/// </summary>
		public event Action<qx.eventx.type.Drag> OnDragchange;

		/// <summary>
		/// <para>Fired on the source (drag) target every time a drag session was ended.</para>
		/// </summary>
		public event Action<qx.eventx.type.Drag> OnDragend;

		/// <summary>
		/// <para>Fired on a potential drop target when leaving it.</para>
		/// <para>Modeled after the WHATWG specification of Drag&amp;Drop:
		/// http://www.whatwg.org/specs/web-apps/current-work/#dnd</para>
		/// </summary>
		public event Action<qx.eventx.type.Drag> OnDragleave;

		/// <summary>
		/// <para>Fired on a potential drop target when reaching it via the mouse.
		/// This event can be canceled if none of the incoming data types
		/// are supported.</para>
		/// <para>Modeled after the WHATWG specification of Drag&amp;Drop:
		/// http://www.whatwg.org/specs/web-apps/current-work/#dnd</para>
		/// </summary>
		public event Action<qx.eventx.type.Drag> OnDragover;

		/// <summary>
		/// <para>Initiate the drag-and-drop operation. This event is cancelable
		/// when the drag operation is currently not allowed/possible.</para>
		/// <para>Modeled after the WHATWG specification of Drag&amp;Drop:
		/// http://www.whatwg.org/specs/web-apps/current-work/#dnd</para>
		/// </summary>
		public event Action<qx.eventx.type.Drag> OnDragstart;

		/// <summary>
		/// <para>Fired on the drop target when the drag&amp;drop action is finished
		/// successfully. This event is normally used to transfer the data
		/// from the drag to the drop target.</para>
		/// <para>Modeled after the WHATWG specification of Drag&amp;Drop:
		/// http://www.whatwg.org/specs/web-apps/current-work/#dnd</para>
		/// </summary>
		public event Action<qx.eventx.type.Drag> OnDrop;

		/// <summary>
		/// <para>Fired when the drop was successfully done and the target widget
		/// is now asking for data. The listener should transfer the data,
		/// respecting the selected action, to the event. This can be done using
		/// the event&#8217;s <see cref="qx.event.type.Drag.AddData"/> method.</para>
		/// </summary>
		public event Action<qx.eventx.type.Drag> OnDroprequest;

		/// <summary>
		/// <para>The event is fired when the widget gets focused. Only widgets which are
		/// <see cref="Focusable"/> receive this event.</para>
		/// </summary>
		public event Action<qx.eventx.type.Focus> OnFocus;

		/// <summary>
		/// <para>When the widget itself or any child of the widget receive the focus.</para>
		/// </summary>
		public event Action<qx.eventx.type.Focus> OnFocusin;

		/// <summary>
		/// <para>When the widget itself or any child of the widget lost the focus.</para>
		/// </summary>
		public event Action<qx.eventx.type.Focus> OnFocusout;

		/// <summary>
		/// <para>This event if fired if a keyboard key is pressed down. This event is
		/// only fired once if the user keeps the key pressed for a while.</para>
		/// </summary>
		public event Action<qx.eventx.type.KeySequence> OnKeydown;

		/// <summary>
		/// <para>This event is fired if the pressed key or keys result in a printable
		/// character. Since the character is not necessarily associated with a
		/// single physical key press, the event does not have a key identifier
		/// getter. This event gets repeated if the user keeps pressing the key(s).</para>
		/// <para>The unicode code of the pressed key can be read using
		/// <see cref="qx.event.type.KeyInput.GetCharCode"/>.</para>
		/// </summary>
		public event Action<qx.eventx.type.KeyInput> OnKeyinput;

		/// <summary>
		/// <para>This event is fired any time a key is pressed. It will be repeated if
		/// the user keeps the key pressed. The pressed key can be determined using
		/// <see cref="qx.event.type.KeySequence.GetKeyIdentifier"/>.</para>
		/// </summary>
		public event Action<qx.eventx.type.KeySequence> OnKeypress;

		/// <summary>
		/// <para>This event if fired if a keyboard key is released.</para>
		/// </summary>
		public event Action<qx.eventx.type.KeySequence> OnKeyup;

		/// <summary>
		/// <para>Fired if the widget looses the capturing mode by a call to
		/// <see cref="ReleaseCapture"/> or a mouse click.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnLosecapture;

		/// <summary>
		/// <para>Mouse button is pressed on the widget.</para>
		/// </summary>
		public event Action<qx.eventx.type.Mouse> OnMousedown;

		/// <summary>
		/// <para>Fired if the mouse cursor moves over the widget.
		/// The data property of the event contains the widget&#8217;s computed location
		/// and dimension as returned by <see cref="qx.ui.core.LayoutItem.GetBounds"/></para>
		/// </summary>
		public event Action<qx.eventx.type.Mouse> OnMousemove;

		/// <summary>
		/// <para>Fired if the mouse cursor leaves widget.</para>
		/// <para>Note: This event is also dispatched if the widget is disabled!</para>
		/// </summary>
		public event Action<qx.eventx.type.Mouse> OnMouseout;

		/// <summary>
		/// <para>Fired if the mouse cursor enters the widget.</para>
		/// <para>Note: This event is also dispatched if the widget is disabled!</para>
		/// </summary>
		public event Action<qx.eventx.type.Mouse> OnMouseover;

		/// <summary>
		/// <para>Mouse button is released on the widget.</para>
		/// </summary>
		public event Action<qx.eventx.type.Mouse> OnMouseup;

		/// <summary>
		/// <para>Fired if the mouse wheel is used over the widget.</para>
		/// </summary>
		public event Action<qx.eventx.type.MouseWheel> OnMousewheel;

		/// <summary>
		/// <para>Fired on move (after layout) of the widget.
		/// The data property of the event contains the widget&#8217;s computed location
		/// and dimension as returned by <see cref="qx.ui.core.LayoutItem.GetBounds"/></para>
		/// </summary>
		public event Action<qx.eventx.type.Data> OnMove;

		/// <summary>
		/// <para>Fired on resize (after layout) of the widget.
		/// The data property of the event contains the widget&#8217;s computed location
		/// and dimension as returned by <see cref="qx.ui.core.LayoutItem.GetBounds"/></para>
		/// </summary>
		public event Action<qx.eventx.type.Data> OnResize;

		/// <summary>
		/// <para>Fired when a finger swipes over the screen.</para>
		/// </summary>
		public event Action<qx.eventx.type.Touch> OnSwipe;

		/// <summary>
		/// <para>Fired after the appearance has been applied. This happens before the
		/// widget becomes visible, on state and appearance changes. The data field
		/// contains the state map. This can be used to react on state changes or to
		/// read properties set by the appearance.</para>
		/// </summary>
		public event Action<qx.eventx.type.Data> OnSyncAppearance;

		/// <summary>
		/// <para>Fired when a finger taps on the screen.</para>
		/// </summary>
		public event Action<qx.eventx.type.Touch> OnTap;

		/// <summary>
		/// <para>Fired if a touch at the screen is canceled.</para>
		/// </summary>
		public event Action<qx.eventx.type.Touch> OnTouchcancel;

		/// <summary>
		/// <para>Fired if a touch at the screen has ended.</para>
		/// </summary>
		public event Action<qx.eventx.type.Touch> OnTouchend;

		/// <summary>
		/// <para>Fired during a touch at the screen.</para>
		/// </summary>
		public event Action<qx.eventx.type.Touch> OnTouchmove;

		/// <summary>
		/// <para>Fired if a touch at the screen is started.</para>
		/// </summary>
		public event Action<qx.eventx.type.Touch> OnTouchstart;

		#endregion Events

		#region Properties

		/// <summary>
		/// <para>Whether the widget is anonymous.</para>
		/// <para>Anonymous widgets are ignored in the event hierarchy. This is useful
		/// for combined widgets where the internal structure do not have a custom
		/// appearance with a different styling from the element around. This is
		/// especially true for widgets like checkboxes or buttons where the text
		/// or icon are handled synchronously for state changes to the outer widget.</para>
		/// </summary>
		[JsProperty(Name = "anonymous", NativeField = true)]
		public bool Anonymous { get; set; }

		/// <summary>
		/// <para>The appearance ID. This ID is used to identify the appearance theme
		/// entry to use for this widget. This controls the styling of the element.</para>
		/// </summary>
		[JsProperty(Name = "appearance", NativeField = true)]
		public string Appearance { get; set; }

		/// <summary>
		/// <para>The background color the rendered widget.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "backgroundColor", NativeField = true)]
		public string BackgroundColor { get; set; }

		/// <summary>
		/// <para>Controls if a tooltip should shown or not.</para>
		/// </summary>
		[JsProperty(Name = "blockToolTip", NativeField = true)]
		public bool BlockToolTip { get; set; }

		/// <summary>
		/// <para>Whether to show a context menu and which one</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "contextMenu", NativeField = true)]
		public qx.ui.menu.Menu ContextMenu { get; set; }

		/// <summary>
		/// <para>Mapping to native style property cursor.</para>
		/// <para>The name of the cursor to show when the mouse pointer is over the widget.
		/// This is any valid CSS2 cursor name defined by W3C.</para>
		/// <para>The following values are possible crossbrowser:
		/// <list type="bullet"><item>default</item>
		/// <item>crosshair</item>
		/// <item>pointer</item>
		/// <item>move</item>
		/// <item>n-resize</item>
		/// <item>ne-resize</item>
		/// <item>e-resize</item>
		/// <item>se-resize</item>
		/// <item>s-resize</item>
		/// <item>sw-resize</item>
		/// <item>w-resize</item>
		/// <item>nw-resize</item>
		/// <item>nesw-resize</item>
		/// <item>nwse-resize</item>
		/// <item>text</item>
		/// <item>wait</item>
		/// <item>help </item>
		/// </list</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "cursor", NativeField = true)]
		public string Cursor { get; set; }

		/// <summary>
		/// <para>The decorator property points to an object, which is responsible
		/// for drawing the widget&#8217;s decoration, e.g. border, background or shadow.</para>
		/// <para>This can be a decorator object or a string pointing to a decorator
		/// defined in the decoration theme.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "decorator", NativeField = true)]
		public qx.html.Decorator Decorator { get; set; }

		/// <summary>
		/// <para>Whether the widget acts as a source for drag&amp;drop operations</para>
		/// </summary>
		[JsProperty(Name = "draggable", NativeField = true)]
		public bool Draggable { get; set; }

		/// <summary>
		/// <para>Whether the widget acts as a target for drag&amp;drop operations</para>
		/// </summary>
		[JsProperty(Name = "droppable", NativeField = true)]
		public bool Droppable { get; set; }

		/// <summary>
		/// <para>Whether the widget is enabled. Disabled widgets are usually grayed out
		/// and do not process user created events. While in the disabled state most
		/// user input events are blocked. Only the <see cref="Mouseover"/> and
		/// <see cref="Mouseout"/> events will be dispatched.</para>
		/// </summary>
		[JsProperty(Name = "enabled", NativeField = true)]
		public bool Enabled { get; set; }

		/// <summary>
		/// <para>Whether the widget is focusable e.g. rendering a focus border and visualize
		/// as active element.</para>
		/// <para>See also <see cref="IsTabable"/> which allows runtime checks for
		/// isChecked or other stuff to test whether the widget is
		/// reachable via the TAB key.</para>
		/// </summary>
		[JsProperty(Name = "focusable", NativeField = true)]
		public bool Focusable { get; set; }

		/// <summary>
		/// <para>The widget&#8217;s font. The value is either a font name defined in the font
		/// theme or an instance of <see cref="qx.bom.Font"/>.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "font", NativeField = true)]
		public string Font { get; set; }

		/// <summary>
		/// <para>If this property if enabled, the widget and all of its child widgets
		/// will never get activated. The activation keeps at the currently
		/// activated widget.</para>
		/// <para>This is mainly useful for widget authors. Please use with caution!</para>
		/// </summary>
		[JsProperty(Name = "keepActive", NativeField = true)]
		public bool KeepActive { get; set; }

		/// <summary>
		/// <para>If this property is enabled, the widget and all of its child widgets
		/// will never get focused. The focus keeps at the currently
		/// focused widget.</para>
		/// <para>This only works for widgets which are not <see cref="Focusable"/>.</para>
		/// <para>This is mainly useful for widget authors. Please use with caution!</para>
		/// </summary>
		[JsProperty(Name = "keepFocus", NativeField = true)]
		public bool KeepFocus { get; set; }

		/// <summary>
		/// <para>Whether the native context menu should be enabled for this widget. To
		/// globally enable the native context menu set the <see cref="NativeContextMenu"/>
		/// property of the root widget (<see cref="qx.ui.root.Abstract"/>) to
		/// true.</para>
		/// </summary>
		[JsProperty(Name = "nativeContextMenu", NativeField = true)]
		public bool NativeContextMenu { get; set; }

		/// <summary>
		/// <para>Mapping to native style property opacity.</para>
		/// <para>The uniform opacity setting to be applied across an entire object.
		/// Behaves like the new CSS-3 Property.
		/// Any values outside the range 0.0 (fully transparent) to 1.0
		/// (fully opaque) will be clamped to this range.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "opacity", NativeField = true)]
		public double Opacity { get; set; }

		/// <summary>
		/// <para>The &#8216;padding&#8217; property is a shorthand property for setting &#8216;paddingTop&#8217;,
		/// &#8216;paddingRight&#8217;, &#8216;paddingBottom&#8217; and &#8216;paddingLeft&#8217; at the same time.</para>
		/// <para>If four values are specified they apply to top, right, bottom and left respectively.
		/// If there is only one value, it applies to all sides, if there are two or three,
		/// the missing values are taken from the opposite side.</para>
		/// </summary>
		[JsProperty(Name = "padding", NativeField = true)]
		public object Padding { get; set; }

		/// <summary>
		/// <para>Padding of the widget (bottom)</para>
		/// </summary>
		[JsProperty(Name = "paddingBottom", NativeField = true)]
		public double PaddingBottom { get; set; }

		/// <summary>
		/// <para>Padding of the widget (left)</para>
		/// </summary>
		[JsProperty(Name = "paddingLeft", NativeField = true)]
		public double PaddingLeft { get; set; }

		/// <summary>
		/// <para>Padding of the widget (right)</para>
		/// </summary>
		[JsProperty(Name = "paddingRight", NativeField = true)]
		public double PaddingRight { get; set; }

		/// <summary>
		/// <para>Padding of the widget (top)</para>
		/// </summary>
		[JsProperty(Name = "paddingTop", NativeField = true)]
		public double PaddingTop { get; set; }

		/// <summary>
		/// <para>Whether the widget contains content which may be selected by the user.</para>
		/// <para>If the value set to true the native browser selection can
		/// be used for text selection. But it is normally useful for
		/// forms fields, longer texts/documents, editors, etc.</para>
		/// </summary>
		[JsProperty(Name = "selectable", NativeField = true)]
		public bool Selectable { get; set; }

		/// <summary>
		/// <para>The decorator used to render the widget&#8217;s outline/shadow. The decorator&#8217;s
		/// insets are interpreted as the amount of pixels the shadow extends the
		/// widget&#8217;s size.</para>
		/// <para>This can be a decorator object or a string pointing to a decorator
		/// defined in the decoration theme.</para>
		/// <para>Note that shadows work only properly in top level widgets like menus, windows
		/// or tooltips. If used in inner widgets the shadow may not be cut by the
		/// parent widget.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "shadow", NativeField = true)]
		public qx.html.Decorator Shadow { get; set; }

		/// <summary>
		/// <para>Defines the tab index of an widget. If widgets with tab indexes are part
		/// of the current focus root these elements are sorted in first priority. Afterwards
		/// the sorting continues by rendered position, zIndex and other criteria.</para>
		/// <para>Please note: The value must be between 1 and 32000.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "tabIndex", NativeField = true)]
		public double TabIndex { get; set; }

		/// <summary>
		/// <para>The text color the rendered widget.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "textColor", NativeField = true)]
		public string TextColor { get; set; }

		/// <summary>
		/// <para>Sets the tooltip instance to use for this widget. If only the tooltip
		/// text and icon have to be set its better to use the <see cref="ToolTipText"/>
		/// and <see cref="ToolTipIcon"/> properties since they use a shared tooltip
		/// instance.</para>
		/// <para>If this property is set the <see cref="ToolTipText"/> and <see cref="ToolTipIcon"/>
		/// properties are ignored.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "toolTip", NativeField = true)]
		public qx.ui.tooltip.ToolTip ToolTip { get; set; }

		/// <summary>
		/// <para>The icon URI of the widget&#8217;s tooltip. This icon is displayed using a shared
		/// tooltip instance. If the tooltip must be customized beyond the tooltip text
		/// <see cref="ToolTipText"/> and the icon, the <see cref="ToolTip"/> property has to be
		/// used.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "toolTipIcon", NativeField = true)]
		public string ToolTipIcon { get; set; }

		/// <summary>
		/// <para>The text of the widget&#8217;s tooltip. This text can contain HTML markup.
		/// The text is displayed using a shared tooltip instance. If the tooltip
		/// must be customized beyond the text and an icon <see cref="ToolTipIcon"/>, the
		/// <see cref="ToolTip"/> property has to be used</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "toolTipText", NativeField = true)]
		public string ToolTipText { get; set; }

		/// <summary>
		/// <para>Controls the visibility. Valid values are:</para>
		/// <list type="bullet">
		/// <item>visible: Render the widget</item>
		/// <item>hidden: Hide the widget but don't relayout the widget's parent.</item>
		/// <item>excluded: Hide the widget and relayout the parent as if the
		/// widget was not a child of its parent.</item>
		/// </list
		/// </summary>
		/// <remarks>
		/// Possible values: "visible","hidden","excluded"
		/// </remarks>
		[JsProperty(Name = "visibility", NativeField = true)]
		public object Visibility { get; set; }

		/// <summary>
		/// <para>The z-index property sets the stack order of an element. An element with
		/// greater stack order is always in front of another element with lower stack order.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "zIndex", NativeField = true)]
		public double ZIndex { get; set; }

		#endregion Properties

		#region Methods

		public Widget() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Activate this widget e.g. for keyboard events.</para>
		/// </summary>
		[JsMethod(Name = "activate")]
		public void Activate() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Recursively adds all children to the given queue</para>
		/// </summary>
		/// <param name="queue">The queue to add widgets to</param>
		[JsMethod(Name = "addChildrenToQueue")]
		public void AddChildrenToQueue(JsArray queue) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets a state.</para>
		/// </summary>
		/// <param name="state">The state to add</param>
		[JsMethod(Name = "addState")]
		public void AddState(string state) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove focus from this widget.</para>
		/// </summary>
		[JsMethod(Name = "blur")]
		public void Blur() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Enables mouse event capturing. All mouse events will dispatched on this
		/// widget until capturing is disabled using <see cref="ReleaseCapture"/> or a
		/// mouse button is clicked. If the widgets becomes the capturing widget the
		/// <see cref="Capture"/> event is fired. Once it looses capture mode the
		/// <see cref="Losecapture"/> event is fired.</para>
		/// </summary>
		/// <param name="containerCapture">If true all events originating in the container are captured. If false events originating in the container are not captured.</param>
		[JsMethod(Name = "capture")]
		public void Capture(bool containerCapture = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reconfigure number of separators</para>
		/// </summary>
		[JsMethod(Name = "clearSeparators")]
		public void ClearSeparators() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>EXPERIMENTAL &#8211; NOT READY FOR PRODUCTION</para>
		/// <para>Returns a clone of this object. Copies over all user configured
		/// property values. Do not configure a parent nor apply the appearance
		/// styles directly.</para>
		/// </summary>
		/// <returns>The clone</returns>
		[JsMethod(Name = "clone")]
		public qx.core.Object Clone() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Deactivate this widget e.g. for keyboard events.</para>
		/// </summary>
		[JsMethod(Name = "deactivate")]
		public void Deactivate() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes this widget from its parent and disposes it.</para>
		/// <para>Please note that the widget is not disposed synchronously. The
		/// real dispose happens after the next queue flush.</para>
		/// </summary>
		[JsMethod(Name = "destroy")]
		public void Destroy() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Hide this widget and exclude it from the underlying layout.</para>
		/// </summary>
		[JsMethod(Name = "exclude")]
		public void Exclude() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fade in the widget.</para>
		/// </summary>
		/// <param name="duration">Time in ms.</param>
		/// <returns>The animation handle to react for the fade animation.</returns>
		[JsMethod(Name = "fadeIn")]
		public qx.bom.element.AnimationHandle FadeIn(double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fade out this widget.</para>
		/// </summary>
		/// <param name="duration">Time in ms.</param>
		/// <returns>The animation handle to react for the fade animation.</returns>
		[JsMethod(Name = "fadeOut")]
		public qx.bom.element.AnimationHandle FadeOut(double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Focus this widget.</para>
		/// </summary>
		[JsMethod(Name = "focus")]
		public void Focus() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property anonymous.</para>
		/// </summary>
		[JsMethod(Name = "getAnonymous")]
		public bool GetAnonymous() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property appearance.</para>
		/// </summary>
		[JsMethod(Name = "getAppearance")]
		public string GetAppearance() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property backgroundColor.</para>
		/// </summary>
		[JsMethod(Name = "getBackgroundColor")]
		public string GetBackgroundColor() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property blockToolTip.</para>
		/// </summary>
		[JsMethod(Name = "getBlockToolTip")]
		public bool GetBlockToolTip() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the child control from the given ID. Returns
		/// null when the child control is unknown.</para>
		/// <para>It is designed for widget authors, who want to access child controls,
		/// which are created by the widget itself.</para>
		/// Warning: This method exposes widget internals and modifying the
		/// returned sub widget may bring the widget into an inconsistent state.
		/// Accessing child controls defined in a super class or in an foreign class
		/// is not supported. Do not use it if the result can be achieved using public
		/// API or theming.
		/// </summary>
		/// <param name="id">ID of the child control</param>
		/// <param name="notcreate">Whether the child control should not be created dynamically if not yet available.</param>
		/// <returns>Child control</returns>
		[JsMethod(Name = "getChildControl")]
		public qx.ui.core.Widget GetChildControl(string id, bool notcreate = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the widget which contains the children and
		/// is relevant for laying them out. This is from the user point of
		/// view and may not be identical to the technical structure.</para>
		/// </summary>
		/// <returns>Widget which contains the children.</returns>
		[JsMethod(Name = "getChildrenContainer")]
		public qx.ui.core.Widget GetChildrenContainer() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the element wrapper of the widget&#8217;s container element.
		/// This method exposes widget internal and must be used with caution!</para>
		/// </summary>
		/// <returns>The widget&#8217;s container element</returns>
		[JsMethod(Name = "getContainerElement")]
		public qx.html.Element GetContainerElement() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Computes the location of the container element in context of the document dimensions.</para>
		/// <para>Supported modes:</para>
		/// <list type="bullet">
		/// <item>margin: Calculate from the margin box of the element
		/// (bigger than the visual appearance: including margins of given element)</item>
		/// <item>box: Calculates the offset box of the element
		/// (default, uses the same size as visible)</item>
		/// <item>border: Calculate the border box
		/// (useful to align to border edges of two elements).</item>
		/// <item>scroll: Calculate the scroll box
		/// (relevant for absolute positioned content).</item>
		/// <item>padding: Calculate the padding box
		/// (relevant for static/relative positioned content).</item>
		/// </list
		/// </summary>
		/// <param name="mode">A supported option. See comment above.</param>
		/// <returns>Returns a map with left, top, right and bottom which contains the distance of the element relative to the document.</returns>
		[JsMethod(Name = "getContainerLocation")]
		public object GetContainerLocation(string mode = "box") { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the element wrapper of the widget&#8217;s content element.
		/// This method exposes widget internal and must be used with caution!</para>
		/// </summary>
		/// <returns>The widget&#8217;s content element</returns>
		[JsMethod(Name = "getContentElement")]
		public qx.html.Element GetContentElement() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Computes the location of the content element in context of the document
		/// dimensions.</para>
		/// <para>Supported modes:</para>
		/// <list type="bullet">
		/// <item>margin: Calculate from the margin box of the element
		/// (bigger than the visual appearance: including margins of given element)</item>
		/// <item>box: Calculates the offset box of the element (default,
		/// uses the same size as visible)</item>
		/// <item>border: Calculate the border box (useful to align to
		/// border edges of two elements).</item>
		/// <item>scroll: Calculate the scroll box (relevant for absolute
		/// positioned content).</item>
		/// <item>padding: Calculate the padding box (relevant for
		/// static/relative positioned content).</item>
		/// </list
		/// </summary>
		/// <param name="mode">A supported option. See comment above.</param>
		/// <returns>Returns a map with left, top, right and bottom which contains the distance of the element relative to the document.</returns>
		[JsMethod(Name = "getContentLocation")]
		public object GetContentLocation(string mode = "box") { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property contextMenu.</para>
		/// </summary>
		[JsMethod(Name = "getContextMenu")]
		public qx.ui.menu.Menu GetContextMenu() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property cursor.</para>
		/// </summary>
		[JsMethod(Name = "getCursor")]
		public string GetCursor() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property decorator.</para>
		/// </summary>
		[JsMethod(Name = "getDecorator")]
		public qx.html.Decorator GetDecorator() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the element wrapper of the widget&#8217;s decorator element.
		/// This method exposes widget internals and must be used with caution!</para>
		/// </summary>
		/// <returns>The widget&#8217;s decorator element (may be null)</returns>
		[JsMethod(Name = "getDecoratorElement")]
		public qx.html.Decorator GetDecoratorElement() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property draggable.</para>
		/// </summary>
		[JsMethod(Name = "getDraggable")]
		public bool GetDraggable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property droppable.</para>
		/// </summary>
		[JsMethod(Name = "getDroppable")]
		public bool GetDroppable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property enabled.</para>
		/// </summary>
		[JsMethod(Name = "getEnabled")]
		public bool GetEnabled() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the next event target in the parent chain. May
		/// also return the widget itself if it is not anonymous.</para>
		/// </summary>
		/// <returns>A working event target of this widget. May be null as well.</returns>
		[JsMethod(Name = "getEventTarget")]
		public qx.ui.core.Widget GetEventTarget() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property focusable.</para>
		/// </summary>
		[JsMethod(Name = "getFocusable")]
		public bool GetFocusable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the element which should be focused.</para>
		/// </summary>
		/// <returns>The html element to focus.</returns>
		[JsMethod(Name = "getFocusElement")]
		public qx.html.Element GetFocusElement() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the next focus target in the parent chain. May
		/// also return the widget itself if it is not anonymous and focusable.</para>
		/// </summary>
		/// <returns>A working focus target of this widget. May be null as well.</returns>
		[JsMethod(Name = "getFocusTarget")]
		public qx.ui.core.Widget GetFocusTarget() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property font.</para>
		/// </summary>
		[JsMethod(Name = "getFont")]
		public string GetFont() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the widget&#8217;s computed inner size as available
		/// through the layout process.</para>
		/// <para>This function is guaranteed to return a correct value
		/// during a <see cref="Resize"/> or <see cref="Move"/> event dispatch.</para>
		/// </summary>
		/// <returns>The widget inner dimension in pixel (if the layout is valid). Contains the keys width and height.</returns>
		[JsMethod(Name = "getInnerSize")]
		public object GetInnerSize() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Return the insets of the widget&#8217;s inner element relative to its
		/// container element. The inset is the sum of the padding and border width.</para>
		/// </summary>
		/// <returns>Contains the keys top, right, bottom and left. All values are integers.</returns>
		[JsMethod(Name = "getInsets")]
		public object GetInsets() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property keepActive.</para>
		/// </summary>
		[JsMethod(Name = "getKeepActive")]
		public bool GetKeepActive() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property keepFocus.</para>
		/// </summary>
		[JsMethod(Name = "getKeepFocus")]
		public bool GetKeepFocus() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property nativeContextMenu.</para>
		/// </summary>
		[JsMethod(Name = "getNativeContextMenu")]
		public bool GetNativeContextMenu() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property opacity.</para>
		/// </summary>
		[JsMethod(Name = "getOpacity")]
		public double GetOpacity() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property paddingBottom.</para>
		/// </summary>
		[JsMethod(Name = "getPaddingBottom")]
		public double GetPaddingBottom() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property paddingLeft.</para>
		/// </summary>
		[JsMethod(Name = "getPaddingLeft")]
		public double GetPaddingLeft() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property paddingRight.</para>
		/// </summary>
		[JsMethod(Name = "getPaddingRight")]
		public double GetPaddingRight() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property paddingTop.</para>
		/// </summary>
		[JsMethod(Name = "getPaddingTop")]
		public double GetPaddingTop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property selectable.</para>
		/// </summary>
		[JsMethod(Name = "getSelectable")]
		public bool GetSelectable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property shadow.</para>
		/// </summary>
		[JsMethod(Name = "getShadow")]
		public qx.html.Decorator GetShadow() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the element wrapper of the widget&#8217;s shadow element.
		/// This method exposes widget internals and must be used with caution!</para>
		/// </summary>
		/// <returns>The widget&#8217;s shadow element (may be null)</returns>
		[JsMethod(Name = "getShadowElement")]
		public qx.html.Decorator GetShadowElement() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property tabIndex.</para>
		/// </summary>
		[JsMethod(Name = "getTabIndex")]
		public double GetTabIndex() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property textColor.</para>
		/// </summary>
		[JsMethod(Name = "getTextColor")]
		public string GetTextColor() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property toolTip.</para>
		/// </summary>
		[JsMethod(Name = "getToolTip")]
		public qx.ui.tooltip.ToolTip GetToolTip() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property toolTipIcon.</para>
		/// </summary>
		[JsMethod(Name = "getToolTipIcon")]
		public string GetToolTipIcon() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property toolTipText.</para>
		/// </summary>
		[JsMethod(Name = "getToolTipText")]
		public string GetToolTipText() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property visibility.</para>
		/// </summary>
		[JsMethod(Name = "getVisibility")]
		public object GetVisibility() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property zIndex.</para>
		/// </summary>
		[JsMethod(Name = "getZIndex")]
		public double GetZIndex() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the given ID is assigned to a child control.</para>
		/// </summary>
		/// <param name="id">ID of the child control</param>
		/// <returns>true when the child control is registered.</returns>
		[JsMethod(Name = "hasChildControl")]
		public bool HasChildControl(string id) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns whether the layout has children, which are layout relevant. This
		/// excludes all widgets, which have a <see cref="qx.ui.core.Widget.Visibility"/>
		/// value of exclude.</para>
		/// </summary>
		/// <returns>Whether the layout has layout relevant children</returns>
		[JsMethod(Name = "hasLayoutChildren")]
		public bool HasLayoutChildren() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns whether a state is set.</para>
		/// </summary>
		/// <param name="state">the state to check.</param>
		/// <returns>whether the state is set.</returns>
		[JsMethod(Name = "hasState")]
		public bool HasState(string state) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Hide this widget.</para>
		/// </summary>
		[JsMethod(Name = "hide")]
		public void Hide() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property anonymous
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property anonymous.</param>
		[JsMethod(Name = "initAnonymous")]
		public void InitAnonymous(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property appearance
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property appearance.</param>
		[JsMethod(Name = "initAppearance")]
		public void InitAppearance(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property backgroundColor
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property backgroundColor.</param>
		[JsMethod(Name = "initBackgroundColor")]
		public void InitBackgroundColor(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property blockToolTip
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property blockToolTip.</param>
		[JsMethod(Name = "initBlockToolTip")]
		public void InitBlockToolTip(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property contextMenu
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property contextMenu.</param>
		[JsMethod(Name = "initContextMenu")]
		public void InitContextMenu(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property cursor
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property cursor.</param>
		[JsMethod(Name = "initCursor")]
		public void InitCursor(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property decorator
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property decorator.</param>
		[JsMethod(Name = "initDecorator")]
		public void InitDecorator(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property draggable
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property draggable.</param>
		[JsMethod(Name = "initDraggable")]
		public void InitDraggable(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property droppable
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property droppable.</param>
		[JsMethod(Name = "initDroppable")]
		public void InitDroppable(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property enabled
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property enabled.</param>
		[JsMethod(Name = "initEnabled")]
		public void InitEnabled(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property focusable
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property focusable.</param>
		[JsMethod(Name = "initFocusable")]
		public void InitFocusable(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property font
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property font.</param>
		[JsMethod(Name = "initFont")]
		public void InitFont(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property keepActive
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property keepActive.</param>
		[JsMethod(Name = "initKeepActive")]
		public void InitKeepActive(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property keepFocus
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property keepFocus.</param>
		[JsMethod(Name = "initKeepFocus")]
		public void InitKeepFocus(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property nativeContextMenu
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property nativeContextMenu.</param>
		[JsMethod(Name = "initNativeContextMenu")]
		public void InitNativeContextMenu(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property opacity
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property opacity.</param>
		[JsMethod(Name = "initOpacity")]
		public void InitOpacity(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property paddingBottom
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property paddingBottom.</param>
		[JsMethod(Name = "initPaddingBottom")]
		public void InitPaddingBottom(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property paddingLeft
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property paddingLeft.</param>
		[JsMethod(Name = "initPaddingLeft")]
		public void InitPaddingLeft(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property paddingRight
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property paddingRight.</param>
		[JsMethod(Name = "initPaddingRight")]
		public void InitPaddingRight(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property paddingTop
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property paddingTop.</param>
		[JsMethod(Name = "initPaddingTop")]
		public void InitPaddingTop(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property selectable
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property selectable.</param>
		[JsMethod(Name = "initSelectable")]
		public void InitSelectable(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property shadow
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property shadow.</param>
		[JsMethod(Name = "initShadow")]
		public void InitShadow(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property tabIndex
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property tabIndex.</param>
		[JsMethod(Name = "initTabIndex")]
		public void InitTabIndex(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property textColor
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property textColor.</param>
		[JsMethod(Name = "initTextColor")]
		public void InitTextColor(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property toolTip
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property toolTip.</param>
		[JsMethod(Name = "initToolTip")]
		public void InitToolTip(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property toolTipIcon
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property toolTipIcon.</param>
		[JsMethod(Name = "initToolTipIcon")]
		public void InitToolTipIcon(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property toolTipText
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property toolTipText.</param>
		[JsMethod(Name = "initToolTipText")]
		public void InitToolTipText(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property visibility
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property visibility.</param>
		[JsMethod(Name = "initVisibility")]
		public void InitVisibility(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property zIndex
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property zIndex.</param>
		[JsMethod(Name = "initZIndex")]
		public void InitZIndex(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Called by the layout manager to mark this item&#8217;s layout as invalid.
		/// This function should clear all layout relevant caches.</para>
		/// </summary>
		[JsMethod(Name = "invalidateLayoutCache")]
		public void InvalidateLayoutCache() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the cache for children which should be laid out.</para>
		/// </summary>
		[JsMethod(Name = "invalidateLayoutChildren")]
		public void InvalidateLayoutChildren() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property anonymous equals true.</para>
		/// </summary>
		[JsMethod(Name = "isAnonymous")]
		public void IsAnonymous() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property blockToolTip equals true.</para>
		/// </summary>
		[JsMethod(Name = "isBlockToolTip")]
		public void IsBlockToolTip() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property draggable equals true.</para>
		/// </summary>
		[JsMethod(Name = "isDraggable")]
		public void IsDraggable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property droppable equals true.</para>
		/// </summary>
		[JsMethod(Name = "isDroppable")]
		public void IsDroppable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property enabled equals true.</para>
		/// </summary>
		[JsMethod(Name = "isEnabled")]
		public void IsEnabled() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the widget is locally excluded.</para>
		/// <para>Note: This method does not respect the hierarchy.</para>
		/// </summary>
		/// <returns>Returns true when the widget is excluded</returns>
		[JsMethod(Name = "isExcluded")]
		public bool IsExcluded() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property focusable equals true.</para>
		/// </summary>
		[JsMethod(Name = "isFocusable")]
		public void IsFocusable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the widget is locally hidden.</para>
		/// <para>Note: This method does not respect the hierarchy.</para>
		/// </summary>
		/// <returns>Returns true when the widget is hidden</returns>
		[JsMethod(Name = "isHidden")]
		public bool IsHidden() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property keepActive equals true.</para>
		/// </summary>
		[JsMethod(Name = "isKeepActive")]
		public void IsKeepActive() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property keepFocus equals true.</para>
		/// </summary>
		[JsMethod(Name = "isKeepFocus")]
		public void IsKeepFocus() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property nativeContextMenu equals true.</para>
		/// </summary>
		[JsMethod(Name = "isNativeContextMenu")]
		public void IsNativeContextMenu() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Detects if the widget and all its parents are visible.</para>
		/// <para>WARNING: Please use this method with caution becuase it flushes the
		/// internal queues which might be an expensive operation.</para>
		/// </summary>
		/// <returns>true, if the widget is currently on the screen</returns>
		[JsMethod(Name = "isSeeable")]
		public bool IsSeeable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property selectable equals true.</para>
		/// </summary>
		[JsMethod(Name = "isSelectable")]
		public void IsSelectable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the widget is reachable by pressing the TAB key.</para>
		/// <para>Normally tests for both, the focusable property and a positive or
		/// undefined tabIndex property. The widget must have a DOM element
		/// since only visible widgets are tabable.</para>
		/// </summary>
		/// <returns>Whether the element is tabable.</returns>
		[JsMethod(Name = "isTabable")]
		public bool IsTabable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the widget is locally visible.</para>
		/// <para>Note: This method does not respect the hierarchy.</para>
		/// </summary>
		/// <returns>Returns true when the widget is visible</returns>
		[JsMethod(Name = "isVisible")]
		public bool IsVisible() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Disables mouse capture mode enabled by <see cref="Capture"/>.</para>
		/// </summary>
		[JsMethod(Name = "releaseCapture")]
		public void ReleaseCapture() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Clears a state.</para>
		/// </summary>
		/// <param name="state">the state to clear.</param>
		[JsMethod(Name = "removeState")]
		public void RemoveState(string state) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Used by the layout engine to apply coordinates and dimensions.</para>
		/// </summary>
		/// <param name="left">Any integer value for the left position, always in pixels</param>
		/// <param name="top">Any integer value for the top position, always in pixels</param>
		/// <param name="width">Any positive integer value for the width, always in pixels</param>
		/// <param name="height">Any positive integer value for the height, always in pixels</param>
		/// <returns>A map of which layout sizes changed.</returns>
		[JsMethod(Name = "renderLayout")]
		public object RenderLayout(double left, double top, double width, double height) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Renders a separator between two children</para>
		/// </summary>
		/// <param name="separator">The separator to render</param>
		/// <param name="bounds">Contains the left and top coordinate and the width and height of the separator to render.</param>
		[JsMethod(Name = "renderSeparator")]
		public void RenderSeparator(qx.html.Decorator separator, object bounds) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replaces the first state with the second one.</para>
		/// <para>This method is ideal for state transitions e.g. normal => selected.</para>
		/// </summary>
		/// <param name="old">Previous state</param>
		/// <param name="value">New state</param>
		[JsMethod(Name = "replaceState")]
		public void ReplaceState(string old, string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property anonymous.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetAnonymous")]
		public void ResetAnonymous() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property appearance.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetAppearance")]
		public void ResetAppearance() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property backgroundColor.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetBackgroundColor")]
		public void ResetBackgroundColor() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property blockToolTip.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetBlockToolTip")]
		public void ResetBlockToolTip() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property contextMenu.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetContextMenu")]
		public void ResetContextMenu() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property cursor.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetCursor")]
		public void ResetCursor() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property decorator.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetDecorator")]
		public void ResetDecorator() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property draggable.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetDraggable")]
		public void ResetDraggable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property droppable.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetDroppable")]
		public void ResetDroppable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property enabled.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetEnabled")]
		public void ResetEnabled() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property focusable.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetFocusable")]
		public void ResetFocusable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property font.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetFont")]
		public void ResetFont() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property keepActive.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetKeepActive")]
		public void ResetKeepActive() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property keepFocus.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetKeepFocus")]
		public void ResetKeepFocus() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property nativeContextMenu.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetNativeContextMenu")]
		public void ResetNativeContextMenu() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property opacity.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOpacity")]
		public void ResetOpacity() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property padding.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPadding")]
		public void ResetPadding() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property paddingBottom.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPaddingBottom")]
		public void ResetPaddingBottom() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property paddingLeft.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPaddingLeft")]
		public void ResetPaddingLeft() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property paddingRight.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPaddingRight")]
		public void ResetPaddingRight() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property paddingTop.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPaddingTop")]
		public void ResetPaddingTop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property selectable.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetSelectable")]
		public void ResetSelectable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property shadow.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetShadow")]
		public void ResetShadow() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property tabIndex.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetTabIndex")]
		public void ResetTabIndex() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property textColor.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetTextColor")]
		public void ResetTextColor() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property toolTip.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetToolTip")]
		public void ResetToolTip() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property toolTipIcon.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetToolTipIcon")]
		public void ResetToolTipIcon() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property toolTipText.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetToolTipText")]
		public void ResetToolTipText() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property visibility.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetVisibility")]
		public void ResetVisibility() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property zIndex.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetZIndex")]
		public void ResetZIndex() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Marks the layout of this widget as invalid and triggers a layout update.
		/// This is a shortcut for qx.ui.core.queue.Layout.add(this);.</para>
		/// </summary>
		[JsMethod(Name = "scheduleLayoutUpdate")]
		public void ScheduleLayoutUpdate() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>The method scrolls the given item into view.</para>
		/// </summary>
		/// <param name="child">Child to scroll into view</param>
		/// <param name="alignX">Alignment of the item. Allowed values: left or right. Could also be null. Without a given alignment the method tries to scroll the widget with the minimum effort needed.</param>
		/// <param name="alignY">Alignment of the item. Allowed values: top or bottom. Could also be null. Without a given alignment the method tries to scroll the widget with the minimum effort needed.</param>
		/// <param name="direct">Whether the execution should be made directly when possible</param>
		[JsMethod(Name = "scrollChildIntoView")]
		public void ScrollChildIntoView(qx.ui.core.Widget child, string alignX = null, string alignY = null, bool direct = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>The method scrolls the given item into view (x-axis only).</para>
		/// </summary>
		/// <param name="child">Child to scroll into view</param>
		/// <param name="align">Alignment of the item. Allowed values: left or right. Could also be null. Without a given alignment the method tries to scroll the widget with the minimum effort needed.</param>
		/// <param name="direct">Whether the execution should be made directly when possible</param>
		[JsMethod(Name = "scrollChildIntoViewX")]
		public void ScrollChildIntoViewX(qx.ui.core.Widget child, string align = null, bool direct = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>The method scrolls the given item into view (y-axis only).</para>
		/// </summary>
		/// <param name="child">Child to scroll into view</param>
		/// <param name="align">Alignment of the element. Allowed values: top or bottom. Could also be null. Without a given alignment the method tries to scroll the widget with the minimum effort needed.</param>
		/// <param name="direct">Whether the execution should be made directly when possible</param>
		[JsMethod(Name = "scrollChildIntoViewY")]
		public void ScrollChildIntoViewY(qx.ui.core.Widget child, string align = null, bool direct = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property anonymous.</para>
		/// </summary>
		/// <param name="value">New value for property anonymous.</param>
		[JsMethod(Name = "setAnonymous")]
		public void SetAnonymous(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property appearance.</para>
		/// </summary>
		/// <param name="value">New value for property appearance.</param>
		[JsMethod(Name = "setAppearance")]
		public void SetAppearance(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property backgroundColor.</para>
		/// </summary>
		/// <param name="value">New value for property backgroundColor.</param>
		[JsMethod(Name = "setBackgroundColor")]
		public void SetBackgroundColor(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property blockToolTip.</para>
		/// </summary>
		/// <param name="value">New value for property blockToolTip.</param>
		[JsMethod(Name = "setBlockToolTip")]
		public void SetBlockToolTip(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property contextMenu.</para>
		/// </summary>
		/// <param name="value">New value for property contextMenu.</param>
		[JsMethod(Name = "setContextMenu")]
		public void SetContextMenu(qx.ui.menu.Menu value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property cursor.</para>
		/// </summary>
		/// <param name="value">New value for property cursor.</param>
		[JsMethod(Name = "setCursor")]
		public void SetCursor(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property decorator.</para>
		/// </summary>
		/// <param name="value">New value for property decorator.</param>
		[JsMethod(Name = "setDecorator")]
		public void SetDecorator(qx.html.Decorator value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Directly modifies the relative left position in relation
		/// to the parent element.</para>
		/// <para>Use with caution! This may be used for animations, drag&amp;drop
		/// or other cases where high performance location manipulation
		/// is important. Otherwise please use <see cref="qx.ui.core.LayoutItem.SetUserBounds"/> instead.</para>
		/// </summary>
		/// <param name="value">Left position</param>
		[JsMethod(Name = "setDomLeft")]
		public void SetDomLeft(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Directly modifies the relative left and top position in relation
		/// to the parent element.</para>
		/// <para>Use with caution! This may be used for animations, drag&amp;drop
		/// or other cases where high performance location manipulation
		/// is important. Otherwise please use <see cref="qx.ui.core.LayoutItem.SetUserBounds"/> instead.</para>
		/// </summary>
		/// <param name="left">Left position</param>
		/// <param name="top">Top position</param>
		[JsMethod(Name = "setDomPosition")]
		public void SetDomPosition(double left, double top) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Directly modifies the relative top position in relation
		/// to the parent element.</para>
		/// <para>Use with caution! This may be used for animations, drag&amp;drop
		/// or other cases where high performance location manipulation
		/// is important. Otherwise please use <see cref="qx.ui.core.LayoutItem.SetUserBounds"/> instead.</para>
		/// </summary>
		/// <param name="value">Top position</param>
		[JsMethod(Name = "setDomTop")]
		public void SetDomTop(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property draggable.</para>
		/// </summary>
		/// <param name="value">New value for property draggable.</param>
		[JsMethod(Name = "setDraggable")]
		public void SetDraggable(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property droppable.</para>
		/// </summary>
		/// <param name="value">New value for property droppable.</param>
		[JsMethod(Name = "setDroppable")]
		public void SetDroppable(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property enabled.</para>
		/// </summary>
		/// <param name="value">New value for property enabled.</param>
		[JsMethod(Name = "setEnabled")]
		public void SetEnabled(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property focusable.</para>
		/// </summary>
		/// <param name="value">New value for property focusable.</param>
		[JsMethod(Name = "setFocusable")]
		public void SetFocusable(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property font.</para>
		/// </summary>
		/// <param name="value">New value for property font.</param>
		[JsMethod(Name = "setFont")]
		public void SetFont(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property keepActive.</para>
		/// </summary>
		/// <param name="value">New value for property keepActive.</param>
		[JsMethod(Name = "setKeepActive")]
		public void SetKeepActive(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property keepFocus.</para>
		/// </summary>
		/// <param name="value">New value for property keepFocus.</param>
		[JsMethod(Name = "setKeepFocus")]
		public void SetKeepFocus(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set the parent</para>
		/// </summary>
		/// <param name="parent">The new parent.</param>
		[JsMethod(Name = "setLayoutParent")]
		public void SetLayoutParent(qx.ui.core.Widget parent) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property nativeContextMenu.</para>
		/// </summary>
		/// <param name="value">New value for property nativeContextMenu.</param>
		[JsMethod(Name = "setNativeContextMenu")]
		public void SetNativeContextMenu(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property opacity.</para>
		/// </summary>
		/// <param name="value">New value for property opacity.</param>
		[JsMethod(Name = "setOpacity")]
		public void SetOpacity(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the values of the property group padding.</para>
		/// <para>This setter supports a shorthand mode compatible with the way margins and paddins are set in CSS.</para>
		/// </summary>
		/// <param name="paddingTop">Sets the value of the property #paddingTop.</param>
		/// <param name="paddingRight">Sets the value of the property #paddingRight.</param>
		/// <param name="paddingBottom">Sets the value of the property #paddingBottom.</param>
		/// <param name="paddingLeft">Sets the value of the property #paddingLeft.</param>
		[JsMethod(Name = "setPadding")]
		public void SetPadding(object paddingTop, object paddingRight, object paddingBottom, object paddingLeft) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property paddingBottom.</para>
		/// </summary>
		/// <param name="value">New value for property paddingBottom.</param>
		[JsMethod(Name = "setPaddingBottom")]
		public void SetPaddingBottom(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property paddingLeft.</para>
		/// </summary>
		/// <param name="value">New value for property paddingLeft.</param>
		[JsMethod(Name = "setPaddingLeft")]
		public void SetPaddingLeft(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property paddingRight.</para>
		/// </summary>
		/// <param name="value">New value for property paddingRight.</param>
		[JsMethod(Name = "setPaddingRight")]
		public void SetPaddingRight(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property paddingTop.</para>
		/// </summary>
		/// <param name="value">New value for property paddingTop.</param>
		[JsMethod(Name = "setPaddingTop")]
		public void SetPaddingTop(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property selectable.</para>
		/// </summary>
		/// <param name="value">New value for property selectable.</param>
		[JsMethod(Name = "setSelectable")]
		public void SetSelectable(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property shadow.</para>
		/// </summary>
		/// <param name="value">New value for property shadow.</param>
		[JsMethod(Name = "setShadow")]
		public void SetShadow(qx.html.Decorator value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property tabIndex.</para>
		/// </summary>
		/// <param name="value">New value for property tabIndex.</param>
		[JsMethod(Name = "setTabIndex")]
		public void SetTabIndex(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property textColor.</para>
		/// </summary>
		/// <param name="value">New value for property textColor.</param>
		[JsMethod(Name = "setTextColor")]
		public void SetTextColor(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property toolTip.</para>
		/// </summary>
		/// <param name="value">New value for property toolTip.</param>
		[JsMethod(Name = "setToolTip")]
		public void SetToolTip(qx.ui.tooltip.ToolTip value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property toolTipIcon.</para>
		/// </summary>
		/// <param name="value">New value for property toolTipIcon.</param>
		[JsMethod(Name = "setToolTipIcon")]
		public void SetToolTipIcon(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property toolTipText.</para>
		/// </summary>
		/// <param name="value">New value for property toolTipText.</param>
		[JsMethod(Name = "setToolTipText")]
		public void SetToolTipText(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property visibility.</para>
		/// </summary>
		/// <param name="value">New value for property visibility.</param>
		[JsMethod(Name = "setVisibility")]
		public void SetVisibility(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property zIndex.</para>
		/// </summary>
		/// <param name="value">New value for property zIndex.</param>
		[JsMethod(Name = "setZIndex")]
		public void SetZIndex(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Make this widget visible.</para>
		/// </summary>
		[JsMethod(Name = "show")]
		public void Show() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Renders the appearance using the current widget states.</para>
		/// <para>Used exclusively by {qx.ui.core.queue.Appearance}.</para>
		/// </summary>
		[JsMethod(Name = "syncAppearance")]
		public void SyncAppearance() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This method is called during the flush of the
		/// <see cref="qx.ui.core.queue.Widget widget queue"/>.</para>
		/// </summary>
		/// <param name="jobs">A map of jobs.</param>
		[JsMethod(Name = "syncWidget")]
		public void SyncWidget(object jobs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property anonymous.</para>
		/// </summary>
		[JsMethod(Name = "toggleAnonymous")]
		public void ToggleAnonymous() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property blockToolTip.</para>
		/// </summary>
		[JsMethod(Name = "toggleBlockToolTip")]
		public void ToggleBlockToolTip() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property draggable.</para>
		/// </summary>
		[JsMethod(Name = "toggleDraggable")]
		public void ToggleDraggable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property droppable.</para>
		/// </summary>
		[JsMethod(Name = "toggleDroppable")]
		public void ToggleDroppable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property enabled.</para>
		/// </summary>
		[JsMethod(Name = "toggleEnabled")]
		public void ToggleEnabled() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property focusable.</para>
		/// </summary>
		[JsMethod(Name = "toggleFocusable")]
		public void ToggleFocusable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property keepActive.</para>
		/// </summary>
		[JsMethod(Name = "toggleKeepActive")]
		public void ToggleKeepActive() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property keepFocus.</para>
		/// </summary>
		[JsMethod(Name = "toggleKeepFocus")]
		public void ToggleKeepFocus() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property nativeContextMenu.</para>
		/// </summary>
		[JsMethod(Name = "toggleNativeContextMenu")]
		public void ToggleNativeContextMenu() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property selectable.</para>
		/// </summary>
		[JsMethod(Name = "toggleSelectable")]
		public void ToggleSelectable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Refreshes the appearance of this widget and all
		/// registered child controls.</para>
		/// </summary>
		[JsMethod(Name = "updateAppearance")]
		public void UpdateAppearance() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the &#8220;parent&#8221; widget contains the &#8220;child&#8221; widget.</para>
		/// </summary>
		/// <param name="parent">The parent widget</param>
		/// <param name="child">The child widget</param>
		/// <returns>Whether one of the &#8220;child&#8221;&#8216;s parents is &#8220;parent&#8221;</returns>
		[JsMethod(Name = "contains")]
		public static bool Contains(qx.ui.core.Widget parent, qx.ui.core.Widget child) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the widget, which contains the given DOM element.</para>
		/// </summary>
		/// <param name="element">The DOM element to search the widget for.</param>
		/// <param name="considerAnonymousState">If true, anonymous widget will not be returned.</param>
		/// <returns>The widget containing the element.</returns>
		[JsMethod(Name = "getWidgetByElement")]
		public static qx.ui.core.Widget GetWidgetByElement(qx.html.Element element, bool considerAnonymousState = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Mark the message for translation but return the original message.</para>
		/// </summary>
		/// <param name="messageId">the message ID</param>
		/// <returns>messageId</returns>
		[JsMethod(Name = "marktr")]
		public string Marktr(string messageId) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Translate a message
		/// Mark the message for translation.</para>
		/// </summary>
		/// <param name="messageId">message id (may contain format strings)</param>
		/// <param name="varargs">variable number of arguments applied to the format string</param>
		/// <returns>The translated message or localized string</returns>
		[JsMethod(Name = "tr")]
		public object Tr(string messageId, object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Translate a message with translation hint
		/// Mark the messages for translation.</para>
		/// </summary>
		/// <param name="hint">hint for the translator of the message. Will be included in the .po file.</param>
		/// <param name="messageId">message id (may contain format strings)</param>
		/// <param name="varargs">variable number of arguments applied to the format string</param>
		/// <returns>The translated message or localized string</returns>
		[JsMethod(Name = "trc")]
		public object Trc(string hint, string messageId, object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Translate a plural message
		/// Mark the messages for translation.</para>
		/// <para>Depending on the third argument the plural or the singular form is chosen.</para>
		/// </summary>
		/// <param name="singularMessageId">message id of the singular form (may contain format strings)</param>
		/// <param name="pluralMessageId">message id of the plural form (may contain format strings)</param>
		/// <param name="count">if greater than 1 the plural form otherwise the singular form is returned.</param>
		/// <param name="varargs">variable number of arguments applied to the format string</param>
		/// <returns>The translated message or localized string</returns>
		[JsMethod(Name = "trn")]
		public object Trn(string singularMessageId, string pluralMessageId, double count, object varargs) { throw new NotImplementedException(); }

		#endregion Methods
    }
}