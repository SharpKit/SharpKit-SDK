// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.ui.form.validation
{
    /// <summary>
	/// <para>This validation manager is responsible for validation of forms.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.ui.form.validation.Manager", OmitOptionalParameters = true, Export = false)]
    public partial class Manager : qx.core.Object
    {
		#region Events

		/// <summary>
		/// <para>Change event for the valid state.</para>
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeValid;

		/// <summary>
		/// <para>Signals that the validation is done. This is not needed on synchronous
		/// validation (validation is done right after the call) but very important
		/// in the case an asynchronous validator will be used.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnComplete;

		#endregion Events

		#region Properties

		/// <summary>
		/// <para>The context for the form validation.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "context", NativeField = true)]
		public object Context { get; set; }

		/// <summary>
		/// <para>The invalid message should store the message why the form validation
		/// failed. It will be added to the array returned by
		/// <see cref="GetInvalidMessages"/>.</para>
		/// </summary>
		[JsProperty(Name = "invalidMessage", NativeField = true)]
		public string InvalidMessage { get; set; }

		/// <summary>
		/// <para>This message will be shown if a required field is empty and no individual
		/// <see cref="qx.ui.form.MForm.RequiredInvalidMessage"/> is given.</para>
		/// </summary>
		[JsProperty(Name = "requiredFieldMessage", NativeField = true)]
		public string RequiredFieldMessage { get; set; }

		/// <summary>
		/// <para>{Function | AsyncValidator}
		/// The validator of the form itself. You can set a function (for
		/// synchronous validation) or a <see cref="qx.ui.form.validation.AsyncValidator"/>.
		/// In both cases, the function can have all added form items as first
		/// argument and the manager as a second argument. The manager should be used
		/// to set the <see cref="InvalidMessage"/>.</para>
		/// <para>Keep in mind that the validator is optional if you don&#8217;t need the
		/// validation in the context of the whole form.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "validator", NativeField = true)]
		public object Validator { get; set; }

		#endregion Properties

		#region Methods

		public Manager() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add a form item to the validation manager.</para>
		/// <para>The form item has to implement at least two interfaces:
		/// 
		/// <item>The <see cref="qx.ui.form.IForm"/> Interface</item>
		/// <item>One of the following interfaces:
		/// <list type="bullet">
		/// <item><see cref="qx.ui.form.IBooleanForm"/></item>
		/// <item><see cref="qx.ui.form.IColorForm"/></item>
		/// <item><see cref="qx.ui.form.IDateForm"/></item>
		/// <item><see cref="qx.ui.form.INumberForm"/></item>
		/// <item><see cref="qx.ui.form.IStringForm"/></item>
		/// </list>
		/// </item>
		/// 
		/// The validator can be a synchronous or asynchronous validator. In
		/// both cases the validator can either returns a boolean or fire an
		/// <see cref="qx.core.ValidationError"/>. For synchronous validation, a plain
		/// JavaScript function should be used. For all asynchronous validations,
		/// a <see cref="qx.ui.form.validation.AsyncValidator"/> is needed to wrap the
		/// plain function.</para>
		/// </summary>
		/// <param name="formItem">The form item to add.</param>
		/// <param name="validator">The validator.</param>
		/// <param name="context">The context of the validator.</param>
		[JsMethod(Name = "add")]
		public void Add(qx.ui.core.Widget formItem, object validator, object context = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property context.</para>
		/// </summary>
		[JsMethod(Name = "getContext")]
		public object GetContext() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Selects invalid form items</para>
		/// </summary>
		/// <returns>invalid form items</returns>
		[JsMethod(Name = "getInvalidFormItems")]
		public JsArray GetInvalidFormItems() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property invalidMessage.</para>
		/// </summary>
		[JsMethod(Name = "getInvalidMessage")]
		public string GetInvalidMessage() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns an array of all invalid messages of the invalid form items and
		/// the form manager itself.</para>
		/// </summary>
		/// <returns>All invalid messages.</returns>
		[JsMethod(Name = "getInvalidMessages")]
		public string GetInvalidMessages() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns registered form items from the validation manager.</para>
		/// </summary>
		/// <returns>The form items which will be validated.</returns>
		[JsMethod(Name = "getItems")]
		public JsArray GetItems() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property requiredFieldMessage.</para>
		/// </summary>
		[JsMethod(Name = "getRequiredFieldMessage")]
		public string GetRequiredFieldMessage() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the valid state of the manager.</para>
		/// </summary>
		/// <returns>The valid state of the manager.</returns>
		[JsMethod(Name = "getValid")]
		public bool GetValid() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property validator.</para>
		/// </summary>
		[JsMethod(Name = "getValidator")]
		public object GetValidator() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property context
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property context.</param>
		[JsMethod(Name = "initContext")]
		public void InitContext(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property invalidMessage
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property invalidMessage.</param>
		[JsMethod(Name = "initInvalidMessage")]
		public void InitInvalidMessage(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property requiredFieldMessage
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property requiredFieldMessage.</param>
		[JsMethod(Name = "initRequiredFieldMessage")]
		public void InitRequiredFieldMessage(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property validator
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property validator.</param>
		[JsMethod(Name = "initValidator")]
		public void InitValidator(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the valid state of the manager.</para>
		/// </summary>
		/// <returns>The valid state of the manager.</returns>
		[JsMethod(Name = "isValid")]
		public bool IsValid() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove a form item from the validation manager.</para>
		/// </summary>
		/// <param name="formItem">The form item to remove.</param>
		/// <returns>The removed form item or null if the item could not be found.</returns>
		[JsMethod(Name = "remove")]
		public qx.ui.core.Widget Remove(qx.ui.core.Widget formItem) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the validator.</para>
		/// </summary>
		[JsMethod(Name = "reset")]
		public void Reset() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property context.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetContext")]
		public void ResetContext() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property invalidMessage.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetInvalidMessage")]
		public void ResetInvalidMessage() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property requiredFieldMessage.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetRequiredFieldMessage")]
		public void ResetRequiredFieldMessage() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property validator.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetValidator")]
		public void ResetValidator() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property context.</para>
		/// </summary>
		/// <param name="value">New value for property context.</param>
		[JsMethod(Name = "setContext")]
		public void SetContext(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property invalidMessage.</para>
		/// </summary>
		/// <param name="value">New value for property invalidMessage.</param>
		[JsMethod(Name = "setInvalidMessage")]
		public void SetInvalidMessage(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property requiredFieldMessage.</para>
		/// </summary>
		/// <param name="value">New value for property requiredFieldMessage.</param>
		[JsMethod(Name = "setRequiredFieldMessage")]
		public void SetRequiredFieldMessage(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property validator.</para>
		/// </summary>
		/// <param name="value">New value for property validator.</param>
		[JsMethod(Name = "setValidator")]
		public void SetValidator(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Invokes the validation. If only synchronous validators are set, the
		/// result of the whole validation is available at the end of the method
		/// and can be returned. If an asynchronous validator is set, the result
		/// is still unknown at the end of this method so nothing will be returned.
		/// In both cases, a <see cref="Complete"/> event will be fired if the validation
		/// has ended. The result of the validation can then be accessed with the
		/// <see cref="GetValid"/> method.</para>
		/// </summary>
		/// <returns>The validation result, if available.</returns>
		[JsMethod(Name = "validate")]
		public object Validate() { throw new NotImplementedException(); }

		#endregion Methods
    }
}