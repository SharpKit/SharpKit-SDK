// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;
using qx.ui.core;

namespace qx.ui.menu
{
    /// <summary>
	/// <para>The menu is a popup like control which supports buttons. It comes
	/// with full keyboard navigation and an improved timeout based mouse
	/// control behavior.</para>
	/// <para>This class is the container for all derived instances of
	/// <see cref="qx.ui.menu.AbstractButton"/>.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.ui.menu.Menu", OmitOptionalParameters = true, Export = false)]
    public partial class Menu : qx.ui.core.Widget
    {
		#region Properties

		/// <summary>
		/// <para>Whether the item can grow horizontally.</para>
		/// </summary>
		[JsProperty(Name = "allowGrowX", NativeField = true)]
		public bool AllowGrowX { get; set; }

		/// <summary>
		/// <para>Whether the item can grow vertically.</para>
		/// </summary>
		[JsProperty(Name = "allowGrowY", NativeField = true)]
		public bool AllowGrowY { get; set; }

		/// <summary>
		/// <para>The appearance ID. This ID is used to identify the appearance theme
		/// entry to use for this widget. This controls the styling of the element.</para>
		/// </summary>
		[JsProperty(Name = "appearance", NativeField = true)]
		public string Appearance { get; set; }

		/// <summary>
		/// <para>Default arrow column width if no sub menus are rendered</para>
		/// </summary>
		[JsProperty(Name = "arrowColumnWidth", NativeField = true)]
		public double ArrowColumnWidth { get; set; }

		/// <summary>
		/// <para>Blocks the background if value is true</para>
		/// </summary>
		[JsProperty(Name = "blockBackground", NativeField = true)]
		public bool BlockBackground { get; set; }

		/// <summary>
		/// <para>Color of the blocker</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "blockerColor", NativeField = true)]
		public string BlockerColor { get; set; }

		/// <summary>
		/// <para>Opacity of the blocker</para>
		/// </summary>
		[JsProperty(Name = "blockerOpacity", NativeField = true)]
		public double BlockerOpacity { get; set; }

		/// <summary>
		/// <para>Interval in ms after which sub menus should be closed</para>
		/// </summary>
		[JsProperty(Name = "closeInterval", NativeField = true)]
		public double CloseInterval { get; set; }

		/// <summary>
		/// <para>Default icon column width if no icons are rendered.
		/// This property is ignored as soon as an icon is present.</para>
		/// </summary>
		[JsProperty(Name = "iconColumnWidth", NativeField = true)]
		public double IconColumnWidth { get; set; }

		/// <summary>
		/// <para>If this property if enabled, the widget and all of its child widgets
		/// will never get activated. The activation keeps at the currently
		/// activated widget.</para>
		/// <para>This is mainly useful for widget authors. Please use with caution!</para>
		/// </summary>
		[JsProperty(Name = "keepActive", NativeField = true)]
		public bool KeepActive { get; set; }

		/// <summary>
		/// <para>If this property is enabled, the widget and all of its child widgets
		/// will never get focused. The focus keeps at the currently
		/// focused widget.</para>
		/// <para>This only works for widgets which are not <see cref="Focusable"/>.</para>
		/// <para>This is mainly useful for widget authors. Please use with caution!</para>
		/// </summary>
		[JsProperty(Name = "keepFocus", NativeField = true)]
		public bool KeepFocus { get; set; }

		/// <summary>
		/// <para>The currently opened button (sub menu is visible)</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "openedButton", NativeField = true)]
		public qx.ui.core.Widget OpenedButton { get; set; }

		/// <summary>
		/// <para>Widget that opened the menu</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "opener", NativeField = true)]
		public qx.ui.core.Widget Opener { get; set; }

		/// <summary>
		/// <para>Interval in ms after which sub menus should be opened</para>
		/// </summary>
		[JsProperty(Name = "openInterval", NativeField = true)]
		public double OpenInterval { get; set; }

		/// <summary>
		/// <para>The currently selected button</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "selectedButton", NativeField = true)]
		public qx.ui.core.Widget SelectedButton { get; set; }

		/// <summary>
		/// <para>The spacing between each cell of the menu buttons</para>
		/// </summary>
		[JsProperty(Name = "spacingX", NativeField = true)]
		public double SpacingX { get; set; }

		/// <summary>
		/// <para>The spacing between each menu button</para>
		/// </summary>
		[JsProperty(Name = "spacingY", NativeField = true)]
		public double SpacingY { get; set; }

		/// <summary>
		/// <para>Controls the visibility. Valid values are:</para>
		/// <list type="bullet">
		/// <item>visible: Render the widget</item>
		/// <item>hidden: Hide the widget but don't relayout the widget's parent.</item>
		/// <item>excluded: Hide the widget and relayout the parent as if the
		/// widget was not a child of its parent.</item>
		/// </list>
		/// </summary>
		/// <remarks>
		/// Possible values: "visible","hidden","excluded"
		/// </remarks>
		[JsProperty(Name = "visibility", NativeField = true)]
		public object Visibility { get; set; }

		/// <summary>
		/// <para>Whether the widget should moved using DOM methods.</para>
		/// </summary>
		[JsProperty(Name = "domMove", NativeField = true)]
		public bool DomMove { get; set; }

		/// <summary>
		/// <para>Offsets in one group</para>
		/// </summary>
		[JsProperty(Name = "offset", NativeField = true)]
		public object Offset { get; set; }

		/// <summary>
		/// <para>Bottom offset of the mouse pointer (in pixel)</para>
		/// </summary>
		[JsProperty(Name = "offsetBottom", NativeField = true)]
		public double OffsetBottom { get; set; }

		/// <summary>
		/// <para>Left offset of the mouse pointer (in pixel)</para>
		/// </summary>
		[JsProperty(Name = "offsetLeft", NativeField = true)]
		public double OffsetLeft { get; set; }

		/// <summary>
		/// <para>Right offset of the mouse pointer (in pixel)</para>
		/// </summary>
		[JsProperty(Name = "offsetRight", NativeField = true)]
		public double OffsetRight { get; set; }

		/// <summary>
		/// <para>Top offset of the mouse pointer (in pixel)</para>
		/// </summary>
		[JsProperty(Name = "offsetTop", NativeField = true)]
		public double OffsetTop { get; set; }

		/// <summary>
		/// <para>Selects the algorithm to place the widget horizontally. direct
		/// uses <see cref="qx.util.placement.DirectAxis"/>, keep-align
		/// uses <see cref="qx.util.placement.KeepAlignAxis"/> and best-fit
		/// uses <see cref="qx.util.placement.BestFitAxis"/>.</para>
		/// </summary>
		/// <remarks>
		/// Possible values: "direct","keep-align","best-fit"
		/// </remarks>
		[JsProperty(Name = "placementModeX", NativeField = true)]
		public object PlacementModeX { get; set; }

		/// <summary>
		/// <para>Selects the algorithm to place the widget vertically. direct
		/// uses <see cref="qx.util.placement.DirectAxis"/>, keep-align
		/// uses <see cref="qx.util.placement.KeepAlignAxis"/> and best-fit
		/// uses <see cref="qx.util.placement.BestFitAxis"/>.</para>
		/// </summary>
		/// <remarks>
		/// Possible values: "direct","keep-align","best-fit"
		/// </remarks>
		[JsProperty(Name = "placementModeY", NativeField = true)]
		public object PlacementModeY { get; set; }

		/// <summary>
		/// <para>Whether the widget should be placed relative to an other widget or to
		/// the mouse cursor.</para>
		/// </summary>
		/// <remarks>
		/// Possible values: "widget","mouse"
		/// </remarks>
		[JsProperty(Name = "placeMethod", NativeField = true)]
		public object PlaceMethod { get; set; }

		/// <summary>
		/// <para>Position of the aligned object in relation to the opener.</para>
		/// <para>Please note than changes to this property are only applied
		/// when re-aligning the widget.</para>
		/// <para>The first part of the value is the edge to attach to. The second
		/// part the alignment of the orthogonal edge after the widget
		/// has been attached.</para>
		/// <para>The default value &#8220;bottom-left&#8221; for example means that the
		/// widget should be shown directly under the given target and
		/// then should be aligned to be left edge:</para>
		/// 
		/// +--------+
		/// | target |
		/// +--------+
		/// +-------------+
		/// |   widget    |
		/// +-------------+
		/// </code>
		/// </summary>
		/// <remarks>
		/// Possible values: "top-left","top-center","top-right","bottom-left","bottom-center","bottom-right","left-top","left-middle","left-bottom","right-top","right-middle","right-bottom"
		/// </remarks>
		[JsProperty(Name = "position", NativeField = true)]
		public object Position { get; set; }

		#endregion Properties

		#region Methods

		public Menu() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Convenience method to add a separator to the menu</para>
		/// </summary>
		[JsMethod(Name = "addSeparator")]
		public void AddSeparator() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property arrowColumnWidth.</para>
		/// </summary>
		[JsMethod(Name = "getArrowColumnWidth")]
		public double GetArrowColumnWidth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property blockBackground.</para>
		/// </summary>
		[JsMethod(Name = "getBlockBackground")]
		public bool GetBlockBackground() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property blockerColor.</para>
		/// </summary>
		[JsMethod(Name = "getBlockerColor")]
		public string GetBlockerColor() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property blockerOpacity.</para>
		/// </summary>
		[JsMethod(Name = "getBlockerOpacity")]
		public double GetBlockerOpacity() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the widget which contains the children and
		/// is relevant for laying them out. This is from the user point of
		/// view and may not be identical to the technical structure.</para>
		/// </summary>
		/// <returns>Widget which contains the children.</returns>
		[JsMethod(Name = "getChildrenContainer")]
		public qx.ui.core.Widget GetChildrenContainer() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property closeInterval.</para>
		/// </summary>
		[JsMethod(Name = "getCloseInterval")]
		public double GetCloseInterval() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the column sizes detected during the pre-layout phase</para>
		/// </summary>
		/// <returns>List of all column widths</returns>
		[JsMethod(Name = "getColumnSizes")]
		public JsArray GetColumnSizes() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property iconColumnWidth.</para>
		/// </summary>
		[JsMethod(Name = "getIconColumnWidth")]
		public double GetIconColumnWidth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property openedButton.</para>
		/// </summary>
		[JsMethod(Name = "getOpenedButton")]
		public qx.ui.core.Widget GetOpenedButton() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property opener.</para>
		/// </summary>
		[JsMethod(Name = "getOpener")]
		public qx.ui.core.Widget GetOpener() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property openInterval.</para>
		/// </summary>
		[JsMethod(Name = "getOpenInterval")]
		public double GetOpenInterval() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the parent menu. Returns null if the menu doesn&#8217;t have a
		/// parent menu.</para>
		/// </summary>
		/// <returns>The parent menu.</returns>
		[JsMethod(Name = "getParentMenu")]
		public Menu GetParentMenu() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Return all selectable menu items.</para>
		/// </summary>
		/// <returns>selectable widgets</returns>
		[JsMethod(Name = "getSelectables")]
		public qx.ui.core.Widget GetSelectables() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property selectedButton.</para>
		/// </summary>
		[JsMethod(Name = "getSelectedButton")]
		public qx.ui.core.Widget GetSelectedButton() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property spacingX.</para>
		/// </summary>
		[JsMethod(Name = "getSpacingX")]
		public double GetSpacingX() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property spacingY.</para>
		/// </summary>
		[JsMethod(Name = "getSpacingY")]
		public double GetSpacingY() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property arrowColumnWidth
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property arrowColumnWidth.</param>
		[JsMethod(Name = "initArrowColumnWidth")]
		public void InitArrowColumnWidth(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property blockBackground
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property blockBackground.</param>
		[JsMethod(Name = "initBlockBackground")]
		public void InitBlockBackground(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property blockerColor
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property blockerColor.</param>
		[JsMethod(Name = "initBlockerColor")]
		public void InitBlockerColor(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property blockerOpacity
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property blockerOpacity.</param>
		[JsMethod(Name = "initBlockerOpacity")]
		public void InitBlockerOpacity(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property closeInterval
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property closeInterval.</param>
		[JsMethod(Name = "initCloseInterval")]
		public void InitCloseInterval(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property iconColumnWidth
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property iconColumnWidth.</param>
		[JsMethod(Name = "initIconColumnWidth")]
		public void InitIconColumnWidth(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property openedButton
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property openedButton.</param>
		[JsMethod(Name = "initOpenedButton")]
		public void InitOpenedButton(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property opener
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property opener.</param>
		[JsMethod(Name = "initOpener")]
		public void InitOpener(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property openInterval
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property openInterval.</param>
		[JsMethod(Name = "initOpenInterval")]
		public void InitOpenInterval(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property selectedButton
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property selectedButton.</param>
		[JsMethod(Name = "initSelectedButton")]
		public void InitSelectedButton(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property spacingX
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property spacingX.</param>
		[JsMethod(Name = "initSpacingX")]
		public void InitSpacingX(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property spacingY
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property spacingY.</param>
		[JsMethod(Name = "initSpacingY")]
		public void InitSpacingY(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property blockBackground equals true.</para>
		/// </summary>
		[JsMethod(Name = "isBlockBackground")]
		public void IsBlockBackground() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Opens the menu and configures the opener</para>
		/// </summary>
		[JsMethod(Name = "open")]
		public void Open() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Opens the menu at the mouse cursor position</para>
		/// </summary>
		/// <param name="e">Mouse event to align to</param>
		[JsMethod(Name = "openAtMouse")]
		public void OpenAtMouse(qx.eventx.type.Mouse e) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Opens the menu in relation to the given point</para>
		/// </summary>
		/// <param name="point">Coordinate of any point with the keys left and top.</param>
		[JsMethod(Name = "openAtPoint")]
		public void OpenAtPoint(object point) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property arrowColumnWidth.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetArrowColumnWidth")]
		public void ResetArrowColumnWidth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property blockBackground.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetBlockBackground")]
		public void ResetBlockBackground() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property blockerColor.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetBlockerColor")]
		public void ResetBlockerColor() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property blockerOpacity.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetBlockerOpacity")]
		public void ResetBlockerOpacity() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property closeInterval.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetCloseInterval")]
		public void ResetCloseInterval() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property iconColumnWidth.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetIconColumnWidth")]
		public void ResetIconColumnWidth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property openedButton.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOpenedButton")]
		public void ResetOpenedButton() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property opener.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOpener")]
		public void ResetOpener() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property openInterval.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOpenInterval")]
		public void ResetOpenInterval() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property selectedButton.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetSelectedButton")]
		public void ResetSelectedButton() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property spacingX.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetSpacingX")]
		public void ResetSpacingX() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property spacingY.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetSpacingY")]
		public void ResetSpacingY() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property arrowColumnWidth.</para>
		/// </summary>
		/// <param name="value">New value for property arrowColumnWidth.</param>
		[JsMethod(Name = "setArrowColumnWidth")]
		public void SetArrowColumnWidth(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property blockBackground.</para>
		/// </summary>
		/// <param name="value">New value for property blockBackground.</param>
		[JsMethod(Name = "setBlockBackground")]
		public void SetBlockBackground(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property blockerColor.</para>
		/// </summary>
		/// <param name="value">New value for property blockerColor.</param>
		[JsMethod(Name = "setBlockerColor")]
		public void SetBlockerColor(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property blockerOpacity.</para>
		/// </summary>
		/// <param name="value">New value for property blockerOpacity.</param>
		[JsMethod(Name = "setBlockerOpacity")]
		public void SetBlockerOpacity(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property closeInterval.</para>
		/// </summary>
		/// <param name="value">New value for property closeInterval.</param>
		[JsMethod(Name = "setCloseInterval")]
		public void SetCloseInterval(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property iconColumnWidth.</para>
		/// </summary>
		/// <param name="value">New value for property iconColumnWidth.</param>
		[JsMethod(Name = "setIconColumnWidth")]
		public void SetIconColumnWidth(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property openedButton.</para>
		/// </summary>
		/// <param name="value">New value for property openedButton.</param>
		[JsMethod(Name = "setOpenedButton")]
		public void SetOpenedButton(qx.ui.core.Widget value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property opener.</para>
		/// </summary>
		/// <param name="value">New value for property opener.</param>
		[JsMethod(Name = "setOpener")]
		public void SetOpener(qx.ui.core.Widget value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property openInterval.</para>
		/// </summary>
		/// <param name="value">New value for property openInterval.</param>
		[JsMethod(Name = "setOpenInterval")]
		public void SetOpenInterval(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property selectedButton.</para>
		/// </summary>
		/// <param name="value">New value for property selectedButton.</param>
		[JsMethod(Name = "setSelectedButton")]
		public void SetSelectedButton(qx.ui.core.Widget value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property spacingX.</para>
		/// </summary>
		/// <param name="value">New value for property spacingX.</param>
		[JsMethod(Name = "setSpacingX")]
		public void SetSpacingX(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property spacingY.</para>
		/// </summary>
		/// <param name="value">New value for property spacingY.</param>
		[JsMethod(Name = "setSpacingY")]
		public void SetSpacingY(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This method is called during the flush of the
		/// <see cref="qx.ui.core.queue.Widget widget queue"/>.</para>
		/// </summary>
		/// <param name="jobs">A map of jobs.</param>
		[JsMethod(Name = "syncWidget")]
		public void SyncWidget(object jobs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property blockBackground.</para>
		/// </summary>
		[JsMethod(Name = "toggleBlockBackground")]
		public void ToggleBlockBackground() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the move direction for an element which hides always visible element.
		/// See <see cref="SetMoveDirection"/> for more details.</para>
		/// </summary>
		/// <returns>The move direction.</returns>
		[JsMethod(Name = "getMoveDirection")]
		public static string GetMoveDirection() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the given always visible element. See <see cref="SetVisibleElement"/>
		/// for more details.</para>
		/// </summary>
		/// <returns>The given widget.</returns>
		[JsMethod(Name = "getVisibleElement")]
		public static qx.ui.core.Widget GetVisibleElement() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set the move direction for an element which hides always visible element.
		/// The value has only an effect when the <see cref="SetVisibleElement"/> is set.</para>
		/// </summary>
		/// <param name="direction">The direction left or top.</param>
		[JsMethod(Name = "setMoveDirection")]
		public static void SetMoveDirection(string direction) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set the always visible element. If an element is set, the
		/// <see cref="MoveTo"/> method takes care of every move and tries not to cover
		/// the given element with a movable widget like a popup or context menu.</para>
		/// </summary>
		/// <param name="elem">The widget which should always be visible.</param>
		[JsMethod(Name = "setVisibleElement")]
		public static void SetVisibleElement(qx.ui.core.Widget elem) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property domMove.</para>
		/// </summary>
		[JsMethod(Name = "getDomMove")]
		public bool GetDomMove() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the location data like {qx.bom.element.Location#get} does,
		/// but does not rely on DOM elements coordinates to be rendered. Instead,
		/// this method works with the available layout data available in the moment
		/// when it is executed.
		/// This works best when called in some type of resize or
		/// move event which are supported by all widgets out of the
		/// box.</para>
		/// </summary>
		/// <param name="widget">Any widget</param>
		/// <returns>Returns a map with left, top, right and bottom which contains the distance of the widget relative coords the document.</returns>
		[JsMethod(Name = "getLayoutLocation")]
		public object GetLayoutLocation(qx.ui.core.Widget widget) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property offsetBottom.</para>
		/// </summary>
		[JsMethod(Name = "getOffsetBottom")]
		public double GetOffsetBottom() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property offsetLeft.</para>
		/// </summary>
		[JsMethod(Name = "getOffsetLeft")]
		public double GetOffsetLeft() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property offsetRight.</para>
		/// </summary>
		[JsMethod(Name = "getOffsetRight")]
		public double GetOffsetRight() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property offsetTop.</para>
		/// </summary>
		[JsMethod(Name = "getOffsetTop")]
		public double GetOffsetTop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property placementModeX.</para>
		/// </summary>
		[JsMethod(Name = "getPlacementModeX")]
		public object GetPlacementModeX() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property placementModeY.</para>
		/// </summary>
		[JsMethod(Name = "getPlacementModeY")]
		public object GetPlacementModeY() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property placeMethod.</para>
		/// </summary>
		[JsMethod(Name = "getPlaceMethod")]
		public object GetPlaceMethod() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property position.</para>
		/// </summary>
		[JsMethod(Name = "getPosition")]
		public object GetPosition() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property domMove
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property domMove.</param>
		[JsMethod(Name = "initDomMove")]
		public void InitDomMove(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property offsetBottom
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property offsetBottom.</param>
		[JsMethod(Name = "initOffsetBottom")]
		public void InitOffsetBottom(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property offsetLeft
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property offsetLeft.</param>
		[JsMethod(Name = "initOffsetLeft")]
		public void InitOffsetLeft(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property offsetRight
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property offsetRight.</param>
		[JsMethod(Name = "initOffsetRight")]
		public void InitOffsetRight(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property offsetTop
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property offsetTop.</param>
		[JsMethod(Name = "initOffsetTop")]
		public void InitOffsetTop(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property placementModeX
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property placementModeX.</param>
		[JsMethod(Name = "initPlacementModeX")]
		public void InitPlacementModeX(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property placementModeY
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property placementModeY.</param>
		[JsMethod(Name = "initPlacementModeY")]
		public void InitPlacementModeY(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property placeMethod
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property placeMethod.</param>
		[JsMethod(Name = "initPlaceMethod")]
		public void InitPlaceMethod(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property position
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property position.</param>
		[JsMethod(Name = "initPosition")]
		public void InitPosition(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property domMove equals true.</para>
		/// </summary>
		[JsMethod(Name = "isDomMove")]
		public void IsDomMove() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the position. Uses low-level, high-performance DOM
		/// methods when the property <see cref="DomMove"/> is enabled.
		/// Checks if an always visible element is set and moves the widget to not
		/// overlay the always visible widget if possible. The algorithm tries to
		/// move the widget as far left as necessary but not of the screen.
		/// (<see cref="SetVisibleElement"/>)</para>
		/// </summary>
		/// <param name="left">The left position</param>
		/// <param name="top">The top position</param>
		[JsMethod(Name = "moveTo")]
		public void MoveTo(double left, double top) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Places the widget to any (rendered) DOM element.</para>
		/// </summary>
		/// <param name="elem">DOM element to align to</param>
		/// <param name="liveupdate">Flag indicating if the position of the widget should be checked and corrected automatically.</param>
		[JsMethod(Name = "placeToElement")]
		public void PlaceToElement(qx.html.Element elem, bool liveupdate) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Places the widget to the mouse cursor position.</para>
		/// </summary>
		/// <param name="eventx">Mouse event to align to</param>
		[JsMethod(Name = "placeToMouse")]
		public void PlaceToMouse(qx.eventx.type.Mouse eventx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Places the widget in relation to the given point</para>
		/// </summary>
		/// <param name="point">Coordinate of any point with the keys left and top.</param>
		[JsMethod(Name = "placeToPoint")]
		public void PlaceToPoint(object point) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Places the widget to another (at least laid out) widget. The DOM
		/// element is not needed, but the bounds are needed to compute the
		/// location of the widget to align to.</para>
		/// </summary>
		/// <param name="target">Target coords align coords</param>
		/// <param name="liveupdate">Flag indicating if the position of the widget should be checked and corrected automatically.</param>
		/// <returns>true if the widget was successfully placed</returns>
		[JsMethod(Name = "placeToWidget")]
		public bool PlaceToWidget(qx.ui.core.Widget target, bool liveupdate) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property domMove.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetDomMove")]
		public void ResetDomMove() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property offset.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOffset")]
		public void ResetOffset() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property offsetBottom.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOffsetBottom")]
		public void ResetOffsetBottom() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property offsetLeft.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOffsetLeft")]
		public void ResetOffsetLeft() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property offsetRight.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOffsetRight")]
		public void ResetOffsetRight() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property offsetTop.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetOffsetTop")]
		public void ResetOffsetTop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property placementModeX.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPlacementModeX")]
		public void ResetPlacementModeX() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property placementModeY.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPlacementModeY")]
		public void ResetPlacementModeY() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property placeMethod.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPlaceMethod")]
		public void ResetPlaceMethod() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property position.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPosition")]
		public void ResetPosition() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property domMove.</para>
		/// </summary>
		/// <param name="value">New value for property domMove.</param>
		[JsMethod(Name = "setDomMove")]
		public void SetDomMove(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the values of the property group offset.</para>
		/// <para>This setter supports a shorthand mode compatible with the way margins and paddins are set in CSS.</para>
		/// </summary>
		/// <param name="offsetTop">Sets the value of the property #offsetTop.</param>
		/// <param name="offsetRight">Sets the value of the property #offsetRight.</param>
		/// <param name="offsetBottom">Sets the value of the property #offsetBottom.</param>
		/// <param name="offsetLeft">Sets the value of the property #offsetLeft.</param>
		[JsMethod(Name = "setOffset")]
		public void SetOffset(object offsetTop, object offsetRight, object offsetBottom, object offsetLeft) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property offsetBottom.</para>
		/// </summary>
		/// <param name="value">New value for property offsetBottom.</param>
		[JsMethod(Name = "setOffsetBottom")]
		public void SetOffsetBottom(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property offsetLeft.</para>
		/// </summary>
		/// <param name="value">New value for property offsetLeft.</param>
		[JsMethod(Name = "setOffsetLeft")]
		public void SetOffsetLeft(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property offsetRight.</para>
		/// </summary>
		/// <param name="value">New value for property offsetRight.</param>
		[JsMethod(Name = "setOffsetRight")]
		public void SetOffsetRight(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property offsetTop.</para>
		/// </summary>
		/// <param name="value">New value for property offsetTop.</param>
		[JsMethod(Name = "setOffsetTop")]
		public void SetOffsetTop(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property placementModeX.</para>
		/// </summary>
		/// <param name="value">New value for property placementModeX.</param>
		[JsMethod(Name = "setPlacementModeX")]
		public void SetPlacementModeX(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property placementModeY.</para>
		/// </summary>
		/// <param name="value">New value for property placementModeY.</param>
		[JsMethod(Name = "setPlacementModeY")]
		public void SetPlacementModeY(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property placeMethod.</para>
		/// </summary>
		/// <param name="value">New value for property placeMethod.</param>
		[JsMethod(Name = "setPlaceMethod")]
		public void SetPlaceMethod(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property position.</para>
		/// </summary>
		/// <param name="value">New value for property position.</param>
		[JsMethod(Name = "setPosition")]
		public void SetPosition(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property domMove.</para>
		/// </summary>
		[JsMethod(Name = "toggleDomMove")]
		public void ToggleDomMove() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds a new child widget.</para>
		/// <para>The supported keys of the layout options map depend on the layout manager
		/// used to position the widget. The options are documented in the class
		/// documentation of each layout manager <see cref="qx.ui.layout"/>.</para>
		/// </summary>
		/// <param name="child">the item to add.</param>
		/// <param name="options">Optional layout data for item.</param>
		/// <returns>This object (for chaining support)</returns>
		[JsMethod(Name = "add")]
		public Widget Add(LayoutItem child, object options = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add an item after another already inserted item</para>
		/// <para>This method works on the widget&#8217;s children list. Some layout managers
		/// (e.g. <see cref="qx.ui.layout.HBox"/>) use the children order as additional
		/// layout information. Other layout manager (e.g. <see cref="qx.ui.layout.Grid"/>)
		/// ignore the children order for the layout process.</para>
		/// </summary>
		/// <param name="child">item to add</param>
		/// <param name="after">item, after which the new item will be inserted</param>
		/// <param name="options">Optional layout data for item.</param>
		[JsMethod(Name = "addAfter")]
		public void AddAfter(LayoutItem child, LayoutItem after, object options = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add a child at the specified index</para>
		/// <para>This method works on the widget&#8217;s children list. Some layout managers
		/// (e.g. <see cref="qx.ui.layout.HBox"/>) use the children order as additional
		/// layout information. Other layout manager (e.g. <see cref="qx.ui.layout.Grid"/>)
		/// ignore the children order for the layout process.</para>
		/// </summary>
		/// <param name="child">item to add</param>
		/// <param name="index">Index, at which the item will be inserted</param>
		/// <param name="options">Optional layout data for item.</param>
		[JsMethod(Name = "addAt")]
		public void AddAt(LayoutItem child, double index, object options = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add an item before another already inserted item</para>
		/// <para>This method works on the widget&#8217;s children list. Some layout managers
		/// (e.g. <see cref="qx.ui.layout.HBox"/>) use the children order as additional
		/// layout information. Other layout manager (e.g. <see cref="qx.ui.layout.Grid"/>)
		/// ignore the children order for the layout process.</para>
		/// </summary>
		/// <param name="child">item to add</param>
		/// <param name="before">item before the new item will be inserted.</param>
		/// <param name="options">Optional layout data for item.</param>
		[JsMethod(Name = "addBefore")]
		public void AddBefore(LayoutItem child, LayoutItem before, object options = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the children list</para>
		/// </summary>
		/// <returns>The children array (Arrays are reference types, please to not modify them in-place)</returns>
		[JsMethod(Name = "getChildren")]
		public LayoutItem GetChildren() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the widget contains children.</para>
		/// </summary>
		/// <returns>Returns true when the widget has children.</returns>
		[JsMethod(Name = "hasChildren")]
		public bool HasChildren() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the index position of the given item if it is
		/// a child item. Otherwise it returns -1.</para>
		/// <para>This method works on the widget&#8217;s children list. Some layout managers
		/// (e.g. <see cref="qx.ui.layout.HBox"/>) use the children order as additional
		/// layout information. Other layout manager (e.g. <see cref="qx.ui.layout.Grid"/>)
		/// ignore the children order for the layout process.</para>
		/// </summary>
		/// <param name="child">the item to query for</param>
		/// <returns>The index position or -1 when the given item is no child of this layout.</returns>
		[JsMethod(Name = "indexOf")]
		public double IndexOf(LayoutItem child) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove the given child item.</para>
		/// </summary>
		/// <param name="child">the item to remove</param>
		/// <returns>This object (for chaining support)</returns>
		[JsMethod(Name = "remove")]
		public Widget Remove(LayoutItem child) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove all children.</para>
		/// </summary>
		/// <returns>An array containing the removed children.</returns>
		[JsMethod(Name = "removeAll")]
		public JsArray RemoveAll() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove the item at the specified index.</para>
		/// <para>This method works on the widget&#8217;s children list. Some layout managers
		/// (e.g. <see cref="qx.ui.layout.HBox"/>) use the children order as additional
		/// layout information. Other layout manager (e.g. <see cref="qx.ui.layout.Grid"/>)
		/// ignore the children order for the layout process.</para>
		/// </summary>
		/// <param name="index">Index of the item to remove.</param>
		/// <returns>The removed item</returns>
		[JsMethod(Name = "removeAt")]
		public qx.ui.core.LayoutItem RemoveAt(double index) { throw new NotImplementedException(); }

		#endregion Methods
    }
}