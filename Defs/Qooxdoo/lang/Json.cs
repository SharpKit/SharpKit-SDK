// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.lang
{
    /// <summary>
	/// <para>JSON (JavaScript Object Notation) parser, serializer for qooxdoo</para>
	/// <para>This class implements EcmaScript 3.1 JSON support.</para>
	/// <para>http://wiki.ecmascript.org/doku.php?id=es3.1:json_support</para>
	/// <para>If the browser supports native JSON the browser implementation is used.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.lang.Json", OmitOptionalParameters = true, Export = false)]
    public partial class Json 
    {
		#region Methods

		public Json() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This method parses a JSON text to produce an object or array.
		/// It can throw a SyntaxError exception.</para>
		/// <para>The optional reviver parameter is a function that can filter and
		/// transform the results. It receives each of the keys and values,
		/// and its return value is used instead of the original value.
		/// If it returns what it received, then the structure is not modified.
		/// If it returns undefined then the member is deleted.</para>
		/// <para>Example:</para>
		/// <code>
		/// // Parse the text. Values that look like ISO date strings will
		/// // be converted to Date objects.
		/// myData = JSON.parse(text, function (key, value)
		/// {
		/// if (typeof value === 'string')
		/// {
		/// var a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
		/// if (a) {
		/// return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]));
		/// }
		/// }
		/// return value;
		/// });
		/// myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
		/// var d;
		/// if (typeof value === 'string' &&
		/// value.slice(0, 5) === 'Date(' &&
		/// value.slice(-1) === ')') {
		/// d = new Date(value.slice(5, -1));
		/// if (d) {
		/// return d;
		/// }
		/// }
		/// return value;
		/// });
		/// </code>
		/// </summary>
		/// <param name="text">JSON string to parse</param>
		/// <param name="reviver">Optional reviver function to filter and transform the results</param>
		/// <returns>The parsed JSON object</returns>
		[JsMethod(Name = "parse")]
		public static object Parse(string text, Action<object> reviver) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This method produces a JSON text from a JavaScript value.</para>
		/// <para>When an object value is found, if the object contains a toJSON
		/// method, its toJSON method will be called and the result will be
		/// stringified. A toJSON method does not serialize: it returns the
		/// value represented by the name/value pair that should be serialized,
		/// or undefined if nothing should be serialized. The toJSON method
		/// will be passed the key associated with the value, and this will be
		/// bound to the object holding the key.</para>
		/// <para>For example, this would serialize Dates as ISO strings.</para>
		/// <code>
		/// Date.prototype.toJSON = function (key) {
		/// function f(n) {
		/// // Format integers to have at least two digits.
		/// return n < 10 ? '0' + n : n;
		/// }
		/// return this.getUTCFullYear()   + '-' +
		/// f(this.getUTCMonth() + 1) + '-' +
		/// f(this.getUTCDate())      + 'T' +
		/// f(this.getUTCHours())     + ':' +
		/// f(this.getUTCMinutes())   + ':' +
		/// f(this.getUTCSeconds())   + 'Z';
		/// };
		/// </code>
		/// <para>You can provide an optional replacer method. It will be passed the
		/// key and value of each member, with this bound to the containing
		/// object. The value that is returned from your method will be
		/// serialized. If your method returns undefined, then the member will
		/// be excluded from the serialization.</para>
		/// <para>If the replacer parameter is an array of strings, then it will be
		/// used to select the members to be serialized. It filters the results
		/// such that only members with keys listed in the replacer array are
		/// stringified.</para>
		/// <para>Values that do not have JSON representations, such as undefined or
		/// functions, will not be serialized. Such values in objects will be
		/// dropped; in arrays they will be replaced with null. You can use
		/// a replacer function to replace those with JSON values.
		/// JSON.stringify(undefined) returns undefined.</para>
		/// <para>The optional space parameter produces a stringification of the
		/// value that is filled with line breaks and indentation to make it
		/// easier to read.</para>
		/// <para>If the space parameter is a non-empty string, then that string will
		/// be used for indentation. If the space parameter is a number, then
		/// the indentation will be that many spaces.</para>
		/// <para>Example:</para>
		/// <code>
		/// text = JSON.stringify(['e', {pluribus: 'unum'}]);
		/// // text is '["e",{"pluribus":"unum"}]'
		/// text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
		/// // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'
		/// text = JSON.stringify([new Date()], function (key, value) {
		/// return this[key] instanceof Date ?
		/// 'Date(' + this[key] + ')' : value;
		/// });
		/// // text is '["Date(---current time---)"]'
		/// </code>
		/// </summary>
		/// <param name="value">any JavaScript value, usually an object or array.</param>
		/// <param name="replacer">an optional parameter that determines how object values are stringified for objects. It can be a function or an array of strings.</param>
		/// <param name="space">an optional parameter that specifies the indentation of nested structures. If it is omitted, the text will be packed without extra whitespace. If it is a number, it will specify the number of spaces to indent at each level. If it is a string (such as &#8217;\t&#8217; or &#8217;&nbsp;&#8217;), it contains the characters used to indent at each level.</param>
		/// <returns>The JSON string of the value</returns>
		[JsMethod(Name = "stringify")]
		public static string Stringify(object value, Action<object> replacer, string space) { throw new NotImplementedException(); }

		#endregion Methods
    }
}