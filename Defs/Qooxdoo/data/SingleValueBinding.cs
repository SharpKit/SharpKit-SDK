// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.data
{
    /// <summary>
	/// <para>The data binding package is still under development so there will be changes
	/// to the API. This Features is for testing purpose only.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.data.SingleValueBinding", OmitOptionalParameters = true, Export = false)]
    public partial class SingleValueBinding 
    {
		#region Methods

		public SingleValueBinding() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>The function is responsible for binding a source objects property to
		/// a target objects property. Both properties have to have the usual qooxdoo
		/// getter and setter. The source property also needs to fire change-events
		/// on every change of its value.
		/// Please keep in mind, that this binding is unidirectional. If you need
		/// a binding in both directions, you have to use two of this bindings.</para>
		/// <para>It&#8217;s also possible to bind some kind of a hierarchy as a source. This
		/// means that you can separate the source properties with a dot and bind
		/// by that the object referenced to this property chain.
		/// Example with an object &#8216;a&#8217; which has object &#8216;b&#8217; stored in its &#8216;child&#8217;
		/// property. Object b has a string property named abc:</para>
		/// 
		/// qx.data.SingleValueBinding.bind(a, "child.abc", textfield, "value");
		/// </code>
		/// <para>In that case, if the property abc of b changes, the textfield will
		/// automatically contain the new value. Also if the child of a changes, the
		/// new value (abc of the new child) will be in the textfield.</para>
		/// <para>There is also a possibility of binding an array. Therefor the array
		/// <see cref="qx.data.IListData"/> is needed because this array has change events
		/// which the native does not. Imagine a qooxdoo object a which has a
		/// children property containing an array holding more of its own kind.
		/// Every object has a name property as a string.</para>
		/// 
		/// var svb = qx.data.SingleValueBinding;
		/// // bind the first childs name of 'a' to a textfield
		/// svb.bind(a, "children[0].name", textfield, "value");
		/// // bind the last childs name of 'a' to a textfield
		/// svb.bind(a, "children[last].name", textfield2, "value");
		/// // also deeper bindinds are possible
		/// svb.bind(a, "children[0].children[0].name", textfield3, "value");
		/// </code>
		/// <para>As you can see in this example, the abc property of a&#8217;s b will be bound
		/// to the textfield. If now the value of b changed or even the a will get a
		/// new b, the binding still shows the right value.</para>
		/// </summary>
		/// <param name="sourceObject">The source of the binding.</param>
		/// <param name="sourcePropertyChain">The property chain which represents the source property.</param>
		/// <param name="targetObject">The object which the source should be bind to.</param>
		/// <param name="targetPropertyChain">The property chain to the target object.</param>
		/// <param name="options">A map containing the options. converter: A converter function which takes four parameters and should return the converted value. The first parameter is the data to convert and the second one is the corresponding model object, which is only set in case of the use of an controller. The third parameter is the source object for the binding and the fourth parameter the target object. If no conversion has been done, the given value should be returned. onUpdate: A callback function can be given here. This method will be called if the binding was updated successful. There will be three parameter you do get in that method call: the source object, the target object and the data as third parameter. onSetFail: A callback function can be given here. This method will be called if the set of the value fails.</param>
		/// <returns>Returns the internal id for that binding. This can be used for referencing the binding or e.g. for removing. This is not an atomic id so you can&#8217;t you use it as a hash-map index.</returns>
		[JsMethod(Name = "bind")]
		public static object Bind(qx.core.Object sourceObject, string sourcePropertyChain, qx.core.Object targetObject, string targetPropertyChain, object options = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a map containing for every bound object an array of data binding
		/// information. The key of the map is the hashcode of the bound objects.
		/// Every binding is represented by an array containing id, sourceObject,
		/// sourceEvent, targetObject and targetProperty.</para>
		/// </summary>
		/// <returns>Map containing all bindings.</returns>
		[JsMethod(Name = "getAllBindings")]
		public static object GetAllBindings() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns an array which lists all bindings.</para>
		/// </summary>
		/// <param name="objectx">The object of which the bindings should be returned.</param>
		/// <returns>An array of binding informations. Every binding information is an array itself containing id, sourceObject, sourceEvent, targetObject and targetProperty in that order.</returns>
		[JsMethod(Name = "getAllBindingsForObject")]
		public static JsArray GetAllBindingsForObject(qx.core.Object objectx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all binding in the whole application. After that not a single
		/// binding is left.</para>
		/// </summary>
		[JsMethod(Name = "removeAllBindings")]
		public static void RemoveAllBindings() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all bindings for the given object.</para>
		/// </summary>
		/// <param name="objectx">The object of which the bindings should be removed.</param>
		[JsMethod(Name = "removeAllBindingsForObject")]
		public static void RemoveAllBindingsForObject(qx.core.Object objectx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the binding with the given id from the given sourceObject. The
		/// id hast to be the id returned by any of the bind functions.</para>
		/// </summary>
		/// <param name="sourceObject">The source object of the binding.</param>
		/// <param name="id">The id of the binding.</param>
		[JsMethod(Name = "removeBindingFromObject")]
		public static void RemoveBindingFromObject(qx.core.Object sourceObject, object id) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Internal helper for getting the current set value at the property chain.</para>
		/// </summary>
		/// <param name="o">The source of the binding.</param>
		/// <param name="propertyChain">The property chain which represents the source property.</param>
		/// <returns>Returns the set value if defined.</returns>
		[JsMethod(Name = "resolvePropertyChain")]
		public static object ResolvePropertyChain(qx.core.Object o, string propertyChain) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Debug function which shows all bindings in the log console. To get only
		/// one binding in the console use <see cref="ShowBindingInLog"/></para>
		/// </summary>
		[JsMethod(Name = "showAllBindingsInLog")]
		public static void ShowAllBindingsInLog() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Debug function which shows some valuable information about the given
		/// binding in console. For that it uses <see cref="qx.log.Logger"/>.</para>
		/// </summary>
		/// <param name="objectx">the source of the binding.</param>
		/// <param name="id">The id of the binding.</param>
		[JsMethod(Name = "showBindingInLog")]
		public static void ShowBindingInLog(qx.core.Object objectx, object id) { throw new NotImplementedException(); }

		#endregion Methods
    }
}