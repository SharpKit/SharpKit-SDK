// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;
using qx.data.marshal;

namespace qx.data
{
    /// <summary>
	/// <para>The data array is a special array used in the data binding context of
	/// qooxdoo. It does not extend the native array of JavaScript but its a wrapper
	/// for it. All the native methods are included in the implementation and it
	/// also fires events if the content or the length of the array changes in
	/// any way. Also the .length property is available on the array.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.data.Array", OmitOptionalParameters = true, Export = false)]
    public partial class Array : qx.core.Object, qx.data.IListData
    {
		#region Events

		/// <summary>
		/// <para>The change event which will be fired if there is a change in the data
		/// structure.The data should contain a map with three key value pairs:
		/// <item>start: The start index of the change.</item>
		/// <item>end: The end index of the change.</item>
		/// <item>type: The type of the change as a String. This can be &#8216;add&#8217;,
		/// &#8216;remove&#8217; or &#8216;order&#8217;</item>
		/// <item>item: The item which has been changed.</item></para>
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChange;

		/// <summary>
		/// <para>The changeLength event will be fired every time the length of the
		/// data structure changes.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnChangeLength;

		/// <summary>
		/// <para>The change event which will be fired on every change in the model no
		/// matter what property changes. This event bubbles so the root model will
		/// fire a change event on every change of its children properties too.</para>
		/// <para>Note that properties are required to call
		/// <see cref="#_applyEventPropagation"/> on apply for changes to be tracked as
		/// desired. It is already taken care of that properties created with the
		/// <see cref="qx.data.marshal.Json"/> marshaler call this method.</para>
		/// <para>The data will contain a map with the following three keys
		/// <item>value: The new value of the property</item>
		/// <item>old: The old value of the property.</item>
		/// <item>name: The name of the property changed including its parent
		/// properties separated by dots.</item>
		/// <item>item: The item which has the changed property.</item>
		/// Due to that, the getOldData method will always return null
		/// because the old data is contained in the map.</para>
		/// </summary>
		public event Action<qx.eventx.type.Data> OnChangeBubble;

		#endregion Events

		#region Properties

		/// <summary>
		/// <para>Flag to set the dispose behavior of the array. If the property is set to
		/// true, the array will dispose its content on dispose, too.</para>
		/// </summary>
		[JsProperty(Name = "autoDisposeItems", NativeField = true)]
		public bool AutoDisposeItems { get; set; }

		#endregion Properties

		#region Methods

		public Array() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Creates a new instance of an array.</para>
		/// </summary>
		/// <param name="param">The parameter can be some types.  Without a parameter a new blank array will be created.  If there is more than one parameter is given, the parameter will be added directly to the new array.  If the parameter is a number, a new Array with the given length will be created.  If the parameter is a JavaScript array, a new array containing the given elements will be created.</param>
		public Array(object param) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Append the items of the given array.</para>
		/// </summary>
		/// <param name="array">The items of this array will be appended.</param>
		[JsMethod(Name = "append")]
		public void Append(object array) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Concatenates the current and the given array into a new one.</para>
		/// </summary>
		/// <param name="array">The javaScript array which should be concatenated to the current array.</param>
		/// <returns>A new array containing the values of both former arrays.</returns>
		[JsMethod(Name = "concat")]
		public qx.data.Array Concat(JsArray array) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check if the given item is in the current data structure.</para>
		/// </summary>
		/// <param name="item">The item which is possibly in the data structure.</param>
		/// <returns>true, if the array contains the given item.</returns>
		[JsMethod(Name = "contains")]
		public bool Contains(object item) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Return a copy of the given arr</para>
		/// </summary>
		/// <returns>copy of this</returns>
		[JsMethod(Name = "copy")]
		public qx.data.Array Copy() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the given array has the same content as this.
		/// Checks only the equality of the arrays&#8217; content.</para>
		/// </summary>
		/// <param name="array">The array to check.</param>
		/// <returns>Whether the two arrays are equal.</returns>
		[JsMethod(Name = "equals")]
		public bool Equals(qx.data.Array array) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Invokes the given function for every item in the array.</para>
		/// </summary>
		/// <param name="callback">The function which will be call for every item in the array. It will be invoked with three parameters: the item, the index and the array itself.</param>
		/// <param name="context">The context in which the callback will be invoked.</param>
		[JsMethod(Name = "forEach")]
		public void ForEach(Action<object> callback, object context) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property autoDisposeItems.</para>
		/// </summary>
		[JsMethod(Name = "getAutoDisposeItems")]
		public bool GetAutoDisposeItems() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the item at the given index</para>
		/// </summary>
		/// <param name="index">The index requested of the data element.</param>
		/// <returns>The element at the given index.</returns>
		[JsMethod(Name = "getItem")]
		public object GetItem(double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the current length of the data structure.</para>
		/// </summary>
		/// <returns>The current length of the data structure.</returns>
		[JsMethod(Name = "getLength")]
		public double GetLength() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the index of the item in the array. If the item is not in the
		/// array, -1 will be returned.</para>
		/// </summary>
		/// <param name="item">The item of which the index should be returned.</param>
		/// <returns>The Index of the given item.</returns>
		[JsMethod(Name = "indexOf")]
		public double IndexOf(object item) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property autoDisposeItems
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property autoDisposeItems.</param>
		[JsMethod(Name = "initAutoDisposeItems")]
		public void InitAutoDisposeItems(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert an element into the array after a given item.</para>
		/// </summary>
		/// <param name="after">Insert item after this object.</param>
		/// <param name="item">Object to be inserted.</param>
		[JsMethod(Name = "insertAfter")]
		public void InsertAfter(object after, object item) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert an element at a given position.</para>
		/// </summary>
		/// <param name="index">Position where to insert the item.</param>
		/// <param name="item">The element to insert.</param>
		[JsMethod(Name = "insertAt")]
		public void InsertAt(double index, object item) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert an item into the array before a given item.</para>
		/// </summary>
		/// <param name="before">Insert item before this object.</param>
		/// <param name="item">The item to be inserted.</param>
		[JsMethod(Name = "insertBefore")]
		public void InsertBefore(object before, object item) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property autoDisposeItems equals true.</para>
		/// </summary>
		[JsMethod(Name = "isAutoDisposeItems")]
		public void IsAutoDisposeItems() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the array as a string using the given connector string to
		/// connect the values.</para>
		/// </summary>
		/// <param name="connector">the string which should be used to past in between of the array values.</param>
		/// <returns>The array as a string.</returns>
		[JsMethod(Name = "join")]
		public string Join(string connector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the highest value in the given array.
		/// Supports numeric values only.</para>
		/// </summary>
		/// <returns>The highest of all values or undefined if the array is empty.</returns>
		[JsMethod(Name = "max")]
		public double Max() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the lowest value in the array. Supports
		/// numeric values only.</para>
		/// </summary>
		/// <returns>The lowest of all values or undefined if the array is empty.</returns>
		[JsMethod(Name = "min")]
		public double Min() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes and returns the last element of the array.
		/// An change event will be fired.</para>
		/// </summary>
		/// <returns>The last element of the array.</returns>
		[JsMethod(Name = "pop")]
		public object Pop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds an element at the end of the array.</para>
		/// </summary>
		/// <param name="varargs">Multiple elements. Every element will be added to the end of the array. An change event will be fired.</param>
		/// <returns>The new length of the array.</returns>
		[JsMethod(Name = "push")]
		public double Push(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove the given item.</para>
		/// </summary>
		/// <param name="item">Item to be removed from the array.</param>
		/// <returns>The removed item.</returns>
		[JsMethod(Name = "remove")]
		public object Remove(object item) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove all elements from the array.</para>
		/// </summary>
		/// <returns>A native array containing the removed elements.</returns>
		[JsMethod(Name = "removeAll")]
		public JsArray RemoveAll() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove an element from the array at the given index.</para>
		/// </summary>
		/// <param name="index">Index of the item to be removed.</param>
		/// <returns>The removed item.</returns>
		[JsMethod(Name = "removeAt")]
		public object RemoveAt(double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property autoDisposeItems.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetAutoDisposeItems")]
		public void ResetAutoDisposeItems() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reverses the order of the array. An change event will be fired.</para>
		/// </summary>
		[JsMethod(Name = "reverse")]
		public void Reverse() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property autoDisposeItems.</para>
		/// </summary>
		/// <param name="value">New value for property autoDisposeItems.</param>
		[JsMethod(Name = "setAutoDisposeItems")]
		public void SetAutoDisposeItems(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the given item at the given position in the data structure. A
		/// change event has to be fired.</para>
		/// </summary>
		/// <param name="index">The index of the data element.</param>
		/// <param name="item">The new item to set.</param>
		[JsMethod(Name = "setItem")]
		public void SetItem(double index, object item) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the first element of the array and returns it. An change event
		/// will be fired.</para>
		/// </summary>
		/// <returns>the former first element.</returns>
		[JsMethod(Name = "shift")]
		public object Shift() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a new array based on the range specified by the parameters.</para>
		/// </summary>
		/// <param name="from">The start index.</param>
		/// <param name="to">The end index. If omitted, slice extracts to the end of the array.</param>
		/// <returns>A new array containing the given range of values.</returns>
		[JsMethod(Name = "slice")]
		public qx.data.Array Slice(double from, double? to = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sorts the array. If a function is given, this will be used to
		/// compare the items. changeBubble event will only be fired,
		/// if sorting result differs from original array.</para>
		/// </summary>
		/// <param name="func">A compare function comparing two parameters and should return a number.</param>
		[JsMethod(Name = "sort")]
		public void Sort(Action<object> func) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Method to remove and add new element to the data. For every remove or
		/// add a change event should be fired.</para>
		/// </summary>
		/// <param name="startIndex">The index where the splice should start</param>
		/// <param name="amount">Defines number of element which will be removed at the given position.</param>
		/// <param name="varargs">All following parameters will be added at the given position to the array.</param>
		/// <returns>An array containing the removed elements.</returns>
		[JsMethod(Name = "splice")]
		public qx.data.Array Splice(double startIndex, double amount, object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the sum of all values in the array. Supports
		/// numeric values only.</para>
		/// </summary>
		/// <returns>The sum of all values.</returns>
		[JsMethod(Name = "sum")]
		public double Sum() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the list data as native array.</para>
		/// </summary>
		/// <returns>The native array.</returns>
		[JsMethod(Name = "toArray")]
		public JsArray ToArray() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property autoDisposeItems.</para>
		/// </summary>
		[JsMethod(Name = "toggleAutoDisposeItems")]
		public void ToggleAutoDisposeItems() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the toString of the original Array</para>
		/// </summary>
		/// <returns>The array as a string.</returns>
		[JsMethod(Name = "toString")]
		public string ToString() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds the given items to the beginning of the array. For every element,
		/// a change event will be fired.</para>
		/// </summary>
		/// <param name="varargs">As many elements as you want to add to the beginning.</param>
		/// <returns>The new length of the array</returns>
		[JsMethod(Name = "unshift")]
		public double Unshift(object varargs) { throw new NotImplementedException(); }

		#endregion Methods
    }
}