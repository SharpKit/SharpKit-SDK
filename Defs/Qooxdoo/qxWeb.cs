// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx
{
    /// <summary>
	/// <para>The Core module&#8217;s responsibility is to query the DOM for elements and offer
	/// these elements as a collection. The Core module itself does not offer any methods to
	/// work with the collection. These methods are added by the other included modules,
	/// such as Manipulating or Attributes.</para>
	/// <para>Core also provides the plugin API which allows modules to attach either
	/// static functions to the global q object or define methods on the
	/// collection it returns.</para>
	/// <para>By default, the core module is assigned to a global module named q.
	/// In case q is already defined, the name qxWeb
	/// is used instead.</para>
	/// user manual.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qxWeb", OmitOptionalParameters = true, Export = false)]
    public partial class qxWeb : qx.type.BaseArray
    {
		#region Methods

		public qxWeb() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This is an API for module development and can be used to attach new methods
		/// to <see cref="q"/>.</para>
		/// </summary>
		/// <param name="module">A map containing the methods to attach.</param>
		[JsMethod(Name = "$attach")]
		public static void Attach(object module) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This is an API for module development and can be used to attach new initialization
		/// methods to <see cref="q"/> which will be called when a new collection is
		/// created.</para>
		/// </summary>
		/// <param name="init">The initialization method for a module.</param>
		[JsMethod(Name = "$attachInit")]
		public static void AttachInit(Action<object> init) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This is an API for module development and can be used to attach new methods
		/// to <see cref="q"/>.</para>
		/// </summary>
		/// <param name="module">A map containing the methods to attach.</param>
		[JsMethod(Name = "$attachStatic")]
		public static void AttachStatic(object module) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Internal helper to initialize collections.</para>
		/// </summary>
		/// <param name="arg">An array of Elements which will be initialized as q. All items in the array which are not either a window object or a node object will be ignored.</param>
		/// <returns>A new initialized collection.</returns>
		[JsMethod(Name = "$init")]
		public static q Init(object arg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Define a new class using the qooxdoo class system.</para>
		/// </summary>
		/// <param name="name">Name of the class. If null, the class will not be attached to a namespace.</param>
		/// <param name="config">Class definition structure.</param>
		/// <returns>The defined class.</returns>
		[JsMethod(Name = "define")]
		public static Action<object> Define(string name, object config) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Accepts a selector string and returns a set of found items. The optional context
		/// element can be used to reduce the amount of found elements to children of the
		/// context element.</para>
		/// Sizzle is used as selector engine.
		/// Check out the documentation
		/// for more details.
		/// </summary>
		/// <param name="selector">Valid selector (CSS3 + extensions) or DOM element or Array of DOM Elements.</param>
		/// <param name="context">Only the children of this element are considered.</param>
		public qxWeb(object selector, qx.html.Element context) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a copy of the collection including the given elements.</para>
		/// </summary>
		/// <param name="varargs">As many items as you want to add.</param>
		/// <returns>A new collection containing all items.</returns>
		[JsMethod(Name = "concat")]
		public q Concat(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a new collection containing only those elements that passed the
		/// given filter. This can be either a selector expression or a filter
		/// function.</para>
		/// </summary>
		/// <param name="selector">Selector expression or filter function</param>
		/// <returns>New collection containing the elements that passed the filter</returns>
		[JsMethod(Name = "filter")]
		public q Filter(object selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a new collection containing the modified elements. For more details, check out the
		/// MDN documentation.</para>
		/// </summary>
		/// <param name="callback">Function which produces the new element.</param>
		/// <param name="thisarg">Context of the callback.</param>
		/// <returns>New collection containing the elements that passed the filter</returns>
		[JsMethod(Name = "map")]
		public q Map(Action<object> callback, object thisarg) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a copy of the collection within the given range.</para>
		/// </summary>
		/// <param name="begin">The index to begin.</param>
		/// <param name="end">The index to end.</param>
		/// <returns>A new collection containing a slice of the original collection.</returns>
		[JsMethod(Name = "slice")]
		public q Slice(double begin, double end) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the given number of items and returns the removed items as a new collection.
		/// This method can also add items. Take a look at the
		/// documentation of MDN for more details.</para>
		/// </summary>
		/// <param name="index">The index to begin.</param>
		/// <param name="howMany">the amount of items to remove.</param>
		/// <param name="varargs">As many items as you want to add.</param>
		/// <returns>A new collection containing the removed items.</returns>
		[JsMethod(Name = "splice")]
		public q Splice(double index, double howMany, object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a new collection containing the offset parent of each item in the
		/// current set.</para>
		/// </summary>
		/// <returns>New collection containing offset parents</returns>
		[JsMethod(Name = "getOffsetParent")]
		public qxWeb GetOffsetParent() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Shows any elements with &#8220;display: none&#8221; in the collection. If an element
		/// was hidden by using the <see cref="Hide"/> method, its previous
		/// &#8220;display&#8221; style value will be re-applied. Otherwise, the
		/// default &#8220;display&#8221; value for the element type will be applied.</para>
		/// </summary>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "show")]
		public qxWeb Show() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the transform-style property.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-style-property</para>
		/// </summary>
		/// <param name="value">Either flat or preserve-3d.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "setTransformStyle")]
		public qxWeb SetTransformStyle(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Updates the placeholders for input&#8217;s and textarea&#8217;s in the collection.
		/// This includes positioning, styles and DOM positioning.
		/// In case the browser supports native placeholders, this methods simply
		/// does nothing.</para>
		/// </summary>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "updatePlaceholder")]
		public qxWeb UpdatePlaceholder() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the perspective-origin property.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-origin-property</para>
		/// </summary>
		/// <param name="value">CSS position values like 50% 50% or left top.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "setTransformPerspectiveOrigin")]
		public qxWeb SetTransformPerspectiveOrigin(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Modifies the given style property on all elements in the collection.</para>
		/// </summary>
		/// <param name="name">Name of the style property to modify</param>
		/// <param name="value">The value to apply</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setStyle")]
		public qxWeb SetStyle(string name, object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set of elements containing all of the unique immediate children of
		/// each of the matched set of elements.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector to match</param>
		/// <returns>Collection containing the child elements</returns>
		[JsMethod(Name = "getChildren")]
		public qxWeb GetChildren(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the blockers from all items in the collection</para>
		/// </summary>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "unblock")]
		public qxWeb Unblock() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the backface-visibility property of the first element.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#backface-visibility-property</para>
		/// </summary>
		/// <returns>true, if the backface is visible.</returns>
		[JsMethod(Name = "getTransformBackfaceVisibility")]
		public bool GetTransformBackfaceVisibility() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Searches the child elements of each item in the collection and returns
		/// a new collection containing the children that match the provided selector</para>
		/// </summary>
		/// <param name="selector">Selector expression to match the child elements against</param>
		/// <returns>New collection containing the matching child elements</returns>
		[JsMethod(Name = "find")]
		public qxWeb Find(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts content before each element in the collection. This can either
		/// be an HTML string, an array of HTML strings, a single DOM element or an
		/// array of elements.</para>
		/// </summary>
		/// <param name="content">HTML string(s) or DOM element(s)</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "before")]
		public qxWeb Before(object content) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Manipulates the play state of the animation.
		/// This can be used to pause an animation when running.</para>
		/// </summary>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "pause")]
		public qxWeb Pause() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing the preceding sibling elements of each
		/// item in the current set (ignoring text and comment nodes) up to but not
		/// including any element that matches the given selector.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing preceding siblings</returns>
		[JsMethod(Name = "getPrevUntil")]
		public qxWeb GetPrevUntil(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set containing the closest matching ancestor for each item in
		/// the collection.
		/// If the item itself matches, it is added to the new set. Otherwise, the
		/// item&#8217;s parent chain will be traversed until a match is found.</para>
		/// </summary>
		/// <param name="selector">Selector expression to match</param>
		/// <returns>New collection containing the closest matching ancestors</returns>
		[JsMethod(Name = "getClosest")]
		public qxWeb GetClosest(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the content height of the first element in the collection.
		/// This is the maximum height the element can use, excluding borders,
		/// margins, padding or scroll bars.</para>
		/// </summary>
		/// <returns>Computed content height</returns>
		[JsMethod(Name = "getContentHeight")]
		public double GetContentHeight() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the values of multiple style properties for each item in the
		/// collection</para>
		/// </summary>
		/// <param name="names">List of style property names</param>
		/// <returns>Map of style property name/value pairs</returns>
		[JsMethod(Name = "getStyles")]
		public object GetStyles(string names) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replaces a class name on each element in the collection</para>
		/// </summary>
		/// <param name="oldName">Class name to remove</param>
		/// <param name="newName">Class name to add</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "replaceClass")]
		public qxWeb ReplaceClass(string oldName, string newName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds an element to the collection</para>
		/// </summary>
		/// <param name="el">DOM element to add to the collection</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "add")]
		public qxWeb Add(qx.html.Element el) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set of elements containing all ancestors of each element in the
		/// collection.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="filter">Optional selector to match</param>
		/// <returns>Collection containing the ancestor elements</returns>
		[JsMethod(Name = "getAncestors")]
		public qxWeb GetAncestors(string filter = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing only the elements that have descendants
		/// matching the given selector</para>
		/// </summary>
		/// <param name="selector">Selector expression</param>
		/// <returns>a new collection containing only elements with matching descendants</returns>
		[JsMethod(Name = "has")]
		public qxWeb Has(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds a class name to each element in the collection</para>
		/// </summary>
		/// <param name="name">Class name</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "addClass")]
		public qxWeb AddClass(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fades out all elements in the collection.</para>
		/// </summary>
		/// <param name="duration">The duration in milliseconds.</param>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "fadeOut")]
		public qxWeb FadeOut(double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes a class name from each element in the collection</para>
		/// </summary>
		/// <param name="name">The class name to remove</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "removeClass")]
		public qxWeb RemoveClass(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Stops a running animation.</para>
		/// </summary>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "stop")]
		public qxWeb Stop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the left scroll position of the first element in the collection.</para>
		/// </summary>
		/// <returns>Current left scroll position</returns>
		[JsMethod(Name = "getScrollLeft")]
		public double GetScrollLeft() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Focuses the first element in the collection</para>
		/// </summary>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "focus")]
		public qxWeb Focus() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Executes the provided callback function once for each item in the
		/// collection.</para>
		/// </summary>
		/// <param name="fn">Callback function</param>
		/// <param name="ctx">Context object</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "forEach")]
		public qxWeb ForEach(Action<object> fn, object ctx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove elements from the collection that do not pass the given filter.
		/// This can be either a selector expression or a filter function</para>
		/// </summary>
		/// <param name="selector">Selector or filter function</param>
		/// <returns>Reduced collection</returns>
		[JsMethod(Name = "not")]
		public qxWeb Not(object selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing the following sibling elements of each
		/// item in the current set (ignoring text and comment nodes) up to but not
		/// including any element that matches the given selector.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing following siblings</returns>
		[JsMethod(Name = "getNextUntil")]
		public qxWeb GetNextUntil(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets multiple attributes for each item in the collection.</para>
		/// </summary>
		/// <param name="attributes">A map of attribute name/value pairs</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setAttributes")]
		public qxWeb SetAttributes(object attributes) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Starts an animation in reversed order. For further details, take a look at
		/// the <see cref="Animate"/> method.</para>
		/// </summary>
		/// <param name="desc">The animation&#8217;s description.</param>
		/// <param name="duration">The duration in milliseconds of the animation, which will override the duration given in the description.</param>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "animateReverse")]
		public qxWeb AnimateReverse(object desc, double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes each element in the current collection from the DOM</para>
		/// </summary>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "remove")]
		public qxWeb Remove() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the perspective property of the first element.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-property</para>
		/// </summary>
		/// <returns>The set property, e.g. 500</returns>
		[JsMethod(Name = "getTransformPerspective")]
		public string GetTransformPerspective() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the values of multiple attributes for the first item in the collection</para>
		/// </summary>
		/// <param name="names">List of attribute names</param>
		/// <returns>Map of attribute name/value pairs</returns>
		[JsMethod(Name = "getAttributes")]
		public object GetAttributes(string names) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing the previous sibling element of each item in
		/// the current set (ignoring text and comment nodes).
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing previous siblings</returns>
		[JsMethod(Name = "getPrev")]
		public qxWeb GetPrev(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds multiple class names to each element in the collection</para>
		/// </summary>
		/// <param name="names">List of class names to add</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "addClasses")]
		public qxWeb AddClasses(string names) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the content width of the first element in the collection.
		/// This is the maximum width the element can use, excluding borders,
		/// margins, padding or scroll bars.</para>
		/// </summary>
		/// <returns>Computed content width</returns>
		[JsMethod(Name = "getContentWidth")]
		public double GetContentWidth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the class name of the first element in the collection</para>
		/// </summary>
		/// <returns>Class name</returns>
		[JsMethod(Name = "getClass")]
		public string GetClass() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the HTML content of each item in the collection</para>
		/// </summary>
		/// <param name="html">HTML string</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setHtml")]
		public qxWeb SetHtml(string html) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Starts the animation with the given description.
		/// The description should be a map, which could look like this:</para>
		/// <code>
		/// {
		/// "duration": 1000,
		/// "keep": 100,
		/// "keyFrames": {
		/// 0 : {"opacity": 1, "scale": 1},
		/// 100 : {"opacity": 0, "scale": 0}
		/// },
		/// "origin": "50% 50%",
		/// "repeat": 1,
		/// "timing": "ease-out",
		/// "alternate": false,
		/// "delay": 2000
		/// }
		/// </code>
		/// <para>duration is the time in milliseconds one animation cycle should take.</para>
		/// <para>keep is the key frame to apply at the end of the animation. (optional)</para>
		/// <para>keyFrames is a map of separate frames. Each frame is defined by a
		/// number which is the percentage value of time in the animation. The value
		/// is a map itself which holds css properties or transforms
		/// (Transforms only for CSS Animations).</para>
		/// <para>origin maps to the transform origin <see cref="qx.bom.element.Transform.SetOrigin"/>
		/// (Only for CSS animations).</para>
		/// <para>repeat is the amount of time the animation should be run in
		/// sequence. You can also use &#8220;infinite&#8221;.</para>
		/// <para>timing takes one of these predefined values:
		/// ease | linear | ease-in
		/// | ease-out | ease-in-out |
		/// cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)
		/// (cubic-bezier only available for CSS animations)</para>
		/// <para>alternate defines if every other animation should be run in reverse order.</para>
		/// <para>delay is the time in milliseconds the animation should wait before start.</para>
		/// </summary>
		/// <param name="desc">The animation&#8217;s description.</param>
		/// <param name="duration">The duration in milliseconds of the animation, which will override the duration given in the description.</param>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "animate")]
		public qxWeb Animate(object desc, double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reduce the set of matched elements to a single element.</para>
		/// </summary>
		/// <param name="index">The position of the element in the collection</param>
		/// <returns>A new collection containing one element</returns>
		[JsMethod(Name = "eq")]
		public qxWeb Eq(double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Appends content to each element in the current set. Accepts an HTML string,
		/// a single DOM element or an array of elements</para>
		/// </summary>
		/// <param name="html">HTML string or DOM element(s) to append</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "append")]
		public qxWeb Append(object html) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a new set of elements containing the child nodes of each item in the
		/// current set.</para>
		/// </summary>
		/// <returns>New collection containing the child nodes</returns>
		[JsMethod(Name = "getContents")]
		public qxWeb GetContents() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scales by the given value. For further details, take
		/// a look at the <see cref="Transform"/> method.</para>
		/// </summary>
		/// <param name="value">The value to scale.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "scale")]
		public qxWeb Scale(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Hides all elements in the collection by setting their &#8220;display&#8221;
		/// style to &#8220;none&#8221;. The previous value is stored so it can be re-applied
		/// when <see cref="Show"/> is called.</para>
		/// </summary>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "hide")]
		public qxWeb Hide() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the backface-visibility property.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#backface-visibility-property</para>
		/// </summary>
		/// <param name="value">true if the backface should be visible.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "setTransformBackfaceVisibility")]
		public qxWeb SetTransformBackfaceVisibility(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Blurs each element in the collection</para>
		/// </summary>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "blur")]
		public qxWeb Blur() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Applies the given value to each element in the collection.
		/// Normally the value is given as a string/number value and applied to the
		/// field content (textfield, textarea) or used to detect whether the field
		/// is checked (checkbox, radiobutton).
		/// Supports array values for selectboxes (multiple selection) and checkboxes
		/// or radiobuttons (for convenience).
		/// Please note: To modify the value attribute of a checkbox or radiobutton
		/// use @link{#set} instead.</para>
		/// </summary>
		/// <param name="value">The value to apply</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setValue")]
		public qxWeb SetValue(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing all sibling elements of the items in the
		/// current set.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing sibling elements</returns>
		[JsMethod(Name = "getSiblings")]
		public qxWeb GetSiblings(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the given list of class names on each item in the collection</para>
		/// </summary>
		/// <param name="names">Class names</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "toggleClasses")]
		public qxWeb ToggleClasses(string names) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns whether an animation is running or not.</para>
		/// </summary>
		/// <returns>true, if an animation is running.</returns>
		[JsMethod(Name = "isPlaying")]
		public bool IsPlaying() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Registers a listener for the given event type on each item in the
		/// collection. This can be either native or custom events.</para>
		/// </summary>
		/// <param name="type">Type of the event to listen for</param>
		/// <param name="listener">Listener callback</param>
		/// <param name="context">Context the callback function will be executed in. Default: The element on which the listener was registered</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "on")]
		public qxWeb On(string type, Action<qx.eventx.type.Data> listener, object context) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds an overlay to all items in the collection that intercepts mouse
		/// events.</para>
		/// </summary>
		/// <param name="color">The color for the blocker element (any CSS color value)</param>
		/// <param name="opacity">The CSS opacity value for the blocker</param>
		/// <param name="zIndex">The zIndex value for the blocker</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "block")]
		public qxWeb Block(string color = "transparent", double opacity = 0, double zIndex = 10000) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the perspective property.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-property</para>
		/// </summary>
		/// <param name="value">The perspective layer. Numbers between 100 and 5000 give the best results.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "setTransformPerspective")]
		public qxWeb SetTransformPerspective(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the given attribute from all elements in the collection</para>
		/// </summary>
		/// <param name="name">Attribute name</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "removeAttribute")]
		public qxWeb RemoveAttribute(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the value of the given attribute for the first item in the
		/// collection.</para>
		/// </summary>
		/// <param name="name">Attribute name</param>
		/// <returns>Attribute value</returns>
		[JsMethod(Name = "getAttribute")]
		public object GetAttribute(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Checks if one or more listeners for the given event type are attached to
		/// the first element in the collection</para>
		/// </summary>
		/// <param name="type">Event type, e.g. mousedown</param>
		/// <returns>true if one or more listeners are attached</returns>
		[JsMethod(Name = "hasListener")]
		public bool HasListener(string type) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the rendered width of the first element in the collection</para>
		/// </summary>
		/// <returns>The first item&#8217;s rendered width</returns>
		[JsMethod(Name = "getWidth")]
		public double GetWidth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Wraps each element in the collection in a copy of an HTML structure.
		/// Elements will be appended to the deepest nested element in the structure
		/// as determined by a depth-first search.</para>
		/// </summary>
		/// <param name="wrapper">Selector expression, HTML string, DOM element or list of DOM elements</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "wrap")]
		public qxWeb Wrap(object wrapper) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Skews by the given value. For further details, take
		/// a look at the <see cref="Transform"/> method.</para>
		/// </summary>
		/// <param name="value">The value to skew e.g. &#8220;90deg&#8221;.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "skew")]
		public qxWeb Skew(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Method to apply multiple transforms at once to the given element. It
		/// takes a map containing the transforms you want to apply plus the values
		/// e.g.{scale: 2, rotate: &#8220;5deg&#8221;}.
		/// The values can be either singular, which means a single value will
		/// be added to the CSS. If you give an array, the values will be split up
		/// and each array entry will be used for the X, Y or Z dimension in that
		/// order e.g. {scale: [2, 0.5]} will result in a element
		/// double the size in X direction and half the size in Y direction.
		/// Make sure your browser supports all transformations you apply.</para>
		/// </summary>
		/// <param name="transforms">The map containing the transforms and value.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "transform")]
		public qxWeb Transform(object transforms) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the transform-style property of the first element.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-style-property</para>
		/// </summary>
		/// <returns>The set property, either flat or preserve-3d.</returns>
		[JsMethod(Name = "getTransformStyle")]
		public string GetTransformStyle() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the given class name on each item in the collection</para>
		/// </summary>
		/// <param name="name">Class name</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "toggleClass")]
		public qxWeb ToggleClass(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts the current collection after each target item. The collection
		/// items are moved after the first target. For subsequent targets,
		/// clones of the collection items are created and inserted.</para>
		/// </summary>
		/// <param name="target">Selector expression or DOM element</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "insertAfter")]
		public qxWeb InsertAfter(object target) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Translates by the given value. For further details, take
		/// a look at the <see cref="Transform"/> method.</para>
		/// </summary>
		/// <param name="value">The value to translate e.g. &#8220;10px&#8221;.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "translate")]
		public qxWeb Translate(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the transform-origin property of the first element.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-origin-property</para>
		/// </summary>
		/// <returns>The set property, e.g. 50% 50% or null, of the collection is empty.</returns>
		[JsMethod(Name = "getTransformOrigin")]
		public string GetTransformOrigin() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set of elements containing the parent of each element in the
		/// collection.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector to match</param>
		/// <returns>Collection containing the parent elements</returns>
		[JsMethod(Name = "getParents")]
		public qxWeb GetParents(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all content from the elements in the collection</para>
		/// </summary>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "empty")]
		public qxWeb Empty() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing all preceding sibling elements of each
		/// item in the current set (ignoring text and comment nodes).
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing preceding siblings</returns>
		[JsMethod(Name = "getPrevAll")]
		public qxWeb GetPrevAll(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the transform-origin property.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#transform-origin-property</para>
		/// </summary>
		/// <param name="value">CSS position values like 50% 50% or left top.</param>
		/// <returns>This reference for chaining.</returns>
		[JsMethod(Name = "setTransformOrigin")]
		public qxWeb SetTransformOrigin(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes multiple class names from each element in the collection</para>
		/// </summary>
		/// <param name="names">List of class names to remove</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "removeClasses")]
		public qxWeb RemoveClasses(string names) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scrolls the elements of the collection to the given coordinate.</para>
		/// </summary>
		/// <param name="value">Top scroll position</param>
		/// <param name="duration">Optional: Duration in ms for animated scrolling</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setScrollTop")]
		public qxWeb SetScrollTop(double value, double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets a property on each item in the collection</para>
		/// </summary>
		/// <param name="name">Property name</param>
		/// <param name="value">Property value</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setProperty")]
		public qxWeb SetProperty(string name, object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the distance between the first element in the collection and its
		/// offset parent</para>
		/// </summary>
		/// <returns>a map with the keys left and top containing the distance between the elements</returns>
		[JsMethod(Name = "getPosition")]
		public object GetPosition() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the value of the given property for the first item in the
		/// collection</para>
		/// </summary>
		/// <param name="name">Property name</param>
		/// <returns>Property value</returns>
		[JsMethod(Name = "getProperty")]
		public object GetProperty(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scrolls the elements of the collection to the given coordinate.</para>
		/// </summary>
		/// <param name="value">Left scroll position</param>
		/// <param name="duration">Optional: Duration in ms for animated scrolling</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setScrollLeft")]
		public qxWeb SetScrollLeft(double value, double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets an HTML attribute on each item in the collection</para>
		/// </summary>
		/// <param name="name">Attribute name</param>
		/// <param name="value">Attribute value</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setAttribute")]
		public qxWeb SetAttribute(string name, object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the currently configured value for the first item in the collection.
		/// Works with simple input fields as well as with select boxes or option
		/// elements. Returns an array for select boxes with multi selection. In all
		/// other cases, a string is returned.</para>
		/// </summary>
		/// <returns></returns>
		[JsMethod(Name = "getValue")]
		public object GetValue() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the perspective-origin property of the first element.</para>
		/// <para>Spec: http://www.w3.org/TR/css3-3d-transforms/#perspective-origin-property</para>
		/// </summary>
		/// <returns>The set property, e.g. 50% 50%</returns>
		[JsMethod(Name = "getTransformPerspectiveOrigin")]
		public string GetTransformPerspectiveOrigin() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the values of multiple properties for the first item in the collection</para>
		/// </summary>
		/// <param name="names">List of property names</param>
		/// <returns>Map of property name/value pairs</returns>
		[JsMethod(Name = "getProperties")]
		public object GetProperties(string names) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes multiple attributes from each item in the collection.</para>
		/// </summary>
		/// <param name="attributes">List of attribute names</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "removeAttributes")]
		public qxWeb RemoveAttributes(string attributes) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fire an event of the given type.</para>
		/// </summary>
		/// <param name="type">Event type</param>
		/// <param name="data">Optional data that will be passed to the listener callback function.</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "emit")]
		public qxWeb Emit(string type, object data) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set of elements containing all ancestors of each element in the
		/// collection, up to (but not including) the element matched by the provided
		/// selector.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Selector that indicates where to stop including ancestor elements</param>
		/// <param name="filter">Optional selector to match</param>
		/// <returns>Collection containing the ancestor elements</returns>
		[JsMethod(Name = "getAncestorsUntil")]
		public qxWeb GetAncestorsUntil(string selector, string filter = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing the next sibling element of each item in
		/// the current set (ignoring text and comment nodes).
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing next siblings</returns>
		[JsMethod(Name = "getNext")]
		public qxWeb GetNext(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the top scroll position of the first element in the collection.</para>
		/// </summary>
		/// <returns>Current top scroll position</returns>
		[JsMethod(Name = "getScrollTop")]
		public double GetScrollTop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Checks if at least one element in the collection passes the provided
		/// filter. This can be either a selector expression or a filter
		/// function</para>
		/// </summary>
		/// <param name="selector">Selector expression or filter function</param>
		/// <returns>true if at least one element matches</returns>
		[JsMethod(Name = "is")]
		public bool Is(object selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing all following sibling elements of each
		/// item in the current set (ignoring text and comment nodes).
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing following siblings</returns>
		[JsMethod(Name = "getNextAll")]
		public qxWeb GetNextAll(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the HTML content of the first item in the collection</para>
		/// </summary>
		/// <returns>HTML content or null if the collection is empty</returns>
		[JsMethod(Name = "getHtml")]
		public string GetHtml() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the computed location of the given element in the context of the
		/// document dimensions.</para>
		/// </summary>
		/// <returns>A map with the keys left>, top>, right> and bottom> which contains the distance of the element relative to the document.</returns>
		[JsMethod(Name = "getOffset")]
		public object GetOffset() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the rendered height of the first element in the collection.</para>
		/// </summary>
		/// <returns>The first item&#8217;s rendered height</returns>
		[JsMethod(Name = "getHeight")]
		public double GetHeight() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets multiple style properties for each item in the collection.</para>
		/// </summary>
		/// <param name="styles">A map of style property name/value pairs</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setStyles")]
		public qxWeb SetStyles(object styles) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Appends all items in the collection to the specified parents. If multiple
		/// parents are given, the items will be moved to the first parent, while
		/// clones of the items will be appended to subsequent parents.</para>
		/// </summary>
		/// <param name="parent">Parent selector expression or list of parent elements</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "appendTo")]
		public qxWeb AppendTo(object parent) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fades in all elements in the collection.</para>
		/// </summary>
		/// <param name="duration">The duration in milliseconds.</param>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "fadeIn")]
		public qxWeb FadeIn(double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets multiple properties for each item in the collection.</para>
		/// </summary>
		/// <param name="properties">A map of property name/value pairs</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "setProperties")]
		public qxWeb SetProperties(object properties) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Manipulates the play state of the animation.
		/// This can be used to continue an animation when paused.</para>
		/// </summary>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "play")]
		public qxWeb Play() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reduces the collection to the last element.</para>
		/// </summary>
		/// <returns>A new collection containing one element</returns>
		[JsMethod(Name = "getLast")]
		public qxWeb GetLast() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts the current collection before each target item. The collection
		/// items are moved before the first target. For subsequent targets,
		/// clones of the collection items are created and inserted.</para>
		/// </summary>
		/// <param name="target">Selector expression or DOM element</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "insertBefore")]
		public qxWeb InsertBefore(object target) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Clones the items in the current collection and returns them in a new set.
		/// Event listeners can also be cloned.</para>
		/// </summary>
		/// <param name="events">clone event listeners. Default:  false</param>
		/// <returns>New collection with clones</returns>
		[JsMethod(Name = "clone")]
		public qxWeb Clone(bool events) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts content after each element in the collection. This can either
		/// be an HTML string, an array of HTML strings, a single DOM element or an
		/// array of elements.</para>
		/// </summary>
		/// <param name="content">HTML string(s) or DOM element(s)</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "after")]
		public qxWeb After(object content) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the value of the given style property for the first item in the
		/// collection.</para>
		/// </summary>
		/// <param name="name">Style property name</param>
		/// <returns>Style property value</returns>
		[JsMethod(Name = "getStyle")]
		public object GetStyle(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reduces the collection to the first element.</para>
		/// </summary>
		/// <returns>A new collection containing one element</returns>
		[JsMethod(Name = "getFirst")]
		public qxWeb GetFirst() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Unregisters event listeners for the given type from each element in the
		/// collection.</para>
		/// </summary>
		/// <param name="type">Type of the event</param>
		/// <param name="listener">Listener callback</param>
		/// <param name="context">Listener callback context</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "off")]
		public qxWeb Off(string type, Action<qx.eventx.type.Data> listener, object context) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Checks if the first element in the collection has the given class name</para>
		/// </summary>
		/// <param name="name">Class name to check for</param>
		/// <returns>true if the first item has the given class name</returns>
		[JsMethod(Name = "hasClass")]
		public bool HasClass(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns whether an animation has ended or not.</para>
		/// </summary>
		/// <returns>true, if an animation has ended.</returns>
		[JsMethod(Name = "isEnded")]
		public bool IsEnded() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Moves the first element in the collection, aligning it with the given
		/// target.</para>
		/// </summary>
		/// <param name="target">Placement target</param>
		/// <param name="position">Alignment of the object with the target, any of &#8220;top-left&#8221;, &#8220;top-center&#8221;, &#8220;top-right&#8221;, &#8220;bottom-left&#8221;, &#8220;bottom-center&#8221;, &#8220;bottom-right&#8221;, &#8220;left-top&#8221;, &#8220;left-middle&#8221;, &#8220;left-bottom&#8221;, &#8220;right-top&#8221;, &#8220;right-middle&#8221;, &#8220;right-bottom&#8221;</param>
		/// <param name="offsets">Map with the desired offsets between the two elements. Must contain the keys left, top, right and bottom</param>
		/// <param name="modeX">Horizontal placement mode. Valid values are:  direct: place the element directly at the given location. keep-align: if the element is partially outside of the visible area, it is moved to the best fitting &#8216;edge&#8217; and &#8216;alignment&#8217; of the target. It is guaranteed the the new position attaches the object to one of the target edges and that it is aligned with a target edge. best-fit: If the element is partially outside of the visible area, it is moved into the view port, ignoring any offset and position values. </param>
		/// <param name="modeY">Vertical placement mode. Accepts the same values as the &#8216;modeX&#8217; argument.</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "placeTo")]
		public qxWeb PlaceTo(qx.html.Element target, string position, object offsets = null, string modeX = "direct", string modeY = "direct") { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Attaches a listener for the given event that will be executed only once.</para>
		/// </summary>
		/// <param name="type">Type of the event to listen for</param>
		/// <param name="listener">Listener callback</param>
		/// <param name="context">Context the callback function will be executed in. Default: The element on which the listener was registered</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "once")]
		public qxWeb Once(string type, Action<qx.eventx.type.Data> listener, object context) { throw new NotImplementedException(); }

		#endregion Methods
    }
}