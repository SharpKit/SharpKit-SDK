// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.module
{
    /// <summary>
	/// <para>DOM traversal module</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.module.Traversing", OmitOptionalParameters = true, Export = false)]
    public partial class Traversing 
    {
		#region Methods

		public Traversing() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds an element to the collection</para>
		/// </summary>
		/// <param name="el">DOM element to add to the collection</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "add")]
		public static qxWeb Add(qx.html.Element el) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reduce the set of matched elements to a single element.</para>
		/// </summary>
		/// <param name="index">The position of the element in the collection</param>
		/// <returns>A new collection containing one element</returns>
		[JsMethod(Name = "eq")]
		public static qxWeb Eq(double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Searches the child elements of each item in the collection and returns
		/// a new collection containing the children that match the provided selector</para>
		/// </summary>
		/// <param name="selector">Selector expression to match the child elements against</param>
		/// <returns>New collection containing the matching child elements</returns>
		[JsMethod(Name = "find")]
		public static qxWeb Find(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Executes the provided callback function once for each item in the
		/// collection.</para>
		/// </summary>
		/// <param name="fn">Callback function</param>
		/// <param name="ctx">Context object</param>
		/// <returns>The collection for chaining</returns>
		[JsMethod(Name = "forEach")]
		public static qxWeb ForEach(Action<object> fn, object ctx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set of elements containing all ancestors of each element in the
		/// collection.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="filter">Optional selector to match</param>
		/// <returns>Collection containing the ancestor elements</returns>
		[JsMethod(Name = "getAncestors")]
		public static qxWeb GetAncestors(string filter = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set of elements containing all ancestors of each element in the
		/// collection, up to (but not including) the element matched by the provided
		/// selector.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Selector that indicates where to stop including ancestor elements</param>
		/// <param name="filter">Optional selector to match</param>
		/// <returns>Collection containing the ancestor elements</returns>
		[JsMethod(Name = "getAncestorsUntil")]
		public static qxWeb GetAncestorsUntil(string selector, string filter = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set of elements containing all of the unique immediate children of
		/// each of the matched set of elements.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector to match</param>
		/// <returns>Collection containing the child elements</returns>
		[JsMethod(Name = "getChildren")]
		public static qxWeb GetChildren(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set containing the closest matching ancestor for each item in
		/// the collection.
		/// If the item itself matches, it is added to the new set. Otherwise, the
		/// item&#8217;s parent chain will be traversed until a match is found.</para>
		/// </summary>
		/// <param name="selector">Selector expression to match</param>
		/// <returns>New collection containing the closest matching ancestors</returns>
		[JsMethod(Name = "getClosest")]
		public static qxWeb GetClosest(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a new set of elements containing the child nodes of each item in the
		/// current set.</para>
		/// </summary>
		/// <returns>New collection containing the child nodes</returns>
		[JsMethod(Name = "getContents")]
		public static qxWeb GetContents() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reduces the collection to the first element.</para>
		/// </summary>
		/// <returns>A new collection containing one element</returns>
		[JsMethod(Name = "getFirst")]
		public static qxWeb GetFirst() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reduces the collection to the last element.</para>
		/// </summary>
		/// <returns>A new collection containing one element</returns>
		[JsMethod(Name = "getLast")]
		public static qxWeb GetLast() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing the next sibling element of each item in
		/// the current set (ignoring text and comment nodes).
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing next siblings</returns>
		[JsMethod(Name = "getNext")]
		public static qxWeb GetNext(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing all following sibling elements of each
		/// item in the current set (ignoring text and comment nodes).
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing following siblings</returns>
		[JsMethod(Name = "getNextAll")]
		public static qxWeb GetNextAll(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing the following sibling elements of each
		/// item in the current set (ignoring text and comment nodes) up to but not
		/// including any element that matches the given selector.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing following siblings</returns>
		[JsMethod(Name = "getNextUntil")]
		public static qxWeb GetNextUntil(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a new collection containing the offset parent of each item in the
		/// current set.</para>
		/// </summary>
		/// <returns>New collection containing offset parents</returns>
		[JsMethod(Name = "getOffsetParent")]
		public static qxWeb GetOffsetParent() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a set of elements containing the parent of each element in the
		/// collection.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector to match</param>
		/// <returns>Collection containing the parent elements</returns>
		[JsMethod(Name = "getParents")]
		public static qxWeb GetParents(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing the previous sibling element of each item in
		/// the current set (ignoring text and comment nodes).
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing previous siblings</returns>
		[JsMethod(Name = "getPrev")]
		public static qxWeb GetPrev(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing all preceding sibling elements of each
		/// item in the current set (ignoring text and comment nodes).
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing preceding siblings</returns>
		[JsMethod(Name = "getPrevAll")]
		public static qxWeb GetPrevAll(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing the preceding sibling elements of each
		/// item in the current set (ignoring text and comment nodes) up to but not
		/// including any element that matches the given selector.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing preceding siblings</returns>
		[JsMethod(Name = "getPrevUntil")]
		public static qxWeb GetPrevUntil(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing all sibling elements of the items in the
		/// current set.
		/// This set can be filtered with an optional expression that will cause only
		/// elements matching the selector to be collected.</para>
		/// </summary>
		/// <param name="selector">Optional selector expression</param>
		/// <returns>New set containing sibling elements</returns>
		[JsMethod(Name = "getSiblings")]
		public static qxWeb GetSiblings(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets a collection containing only the elements that have descendants
		/// matching the given selector</para>
		/// </summary>
		/// <param name="selector">Selector expression</param>
		/// <returns>a new collection containing only elements with matching descendants</returns>
		[JsMethod(Name = "has")]
		public static qxWeb Has(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Checks if at least one element in the collection passes the provided
		/// filter. This can be either a selector expression or a filter
		/// function</para>
		/// </summary>
		/// <param name="selector">Selector expression or filter function</param>
		/// <returns>true if at least one element matches</returns>
		[JsMethod(Name = "is")]
		public static bool Is(object selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the first element in the collection is inserted into
		/// the document for which it was created.</para>
		/// </summary>
		/// <returns>true when the element is inserted into the document.</returns>
		[JsMethod(Name = "isRendered")]
		public static bool IsRendered() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove elements from the collection that do not pass the given filter.
		/// This can be either a selector expression or a filter function</para>
		/// </summary>
		/// <param name="selector">Selector or filter function</param>
		/// <returns>Reduced collection</returns>
		[JsMethod(Name = "not")]
		public static qxWeb Not(object selector) { throw new NotImplementedException(); }

		#endregion Methods
    }
}