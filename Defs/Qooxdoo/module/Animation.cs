// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.module
{
    /// <summary>
	/// <para>Cross browser animation layer. It uses feature detection to check if CSS
	/// animations are available and ready to use. If not, a JavaScript-based
	/// fallback will be used.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.module.Animation", OmitOptionalParameters = true, Export = false)]
    public partial class Animation 
    {
		#region Events

		/// <summary>
		/// <para>Fired when an animation has ended.</para>
		/// </summary>
		public event Action<object> OnAnimationEnd;

		/// <summary>
		/// <para>Fired when an animation has ended one iteration.</para>
		/// </summary>
		public event Action<object> OnAnimationIteration;

		/// <summary>
		/// <para>Fired when an animation starts.</para>
		/// </summary>
		public event Action<object> OnAnimationStart;

		#endregion Events

		#region Methods

		public Animation() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Starts the animation with the given description.
		/// The description should be a map, which could look like this:</para>
		/// <code>
		/// {
		/// "duration": 1000,
		/// "keep": 100,
		/// "keyFrames": {
		/// 0 : {"opacity": 1, "scale": 1},
		/// 100 : {"opacity": 0, "scale": 0}
		/// },
		/// "origin": "50% 50%",
		/// "repeat": 1,
		/// "timing": "ease-out",
		/// "alternate": false,
		/// "delay": 2000
		/// }
		/// </code>
		/// <para>duration is the time in milliseconds one animation cycle should take.</para>
		/// <para>keep is the key frame to apply at the end of the animation. (optional)</para>
		/// <para>keyFrames is a map of separate frames. Each frame is defined by a
		/// number which is the percentage value of time in the animation. The value
		/// is a map itself which holds css properties or transforms
		/// (Transforms only for CSS Animations).</para>
		/// <para>origin maps to the transform origin <see cref="qx.bom.element.Transform.SetOrigin"/>
		/// (Only for CSS animations).</para>
		/// <para>repeat is the amount of time the animation should be run in
		/// sequence. You can also use &#8220;infinite&#8221;.</para>
		/// <para>timing takes one of these predefined values:
		/// ease | linear | ease-in
		/// | ease-out | ease-in-out |
		/// cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)
		/// (cubic-bezier only available for CSS animations)</para>
		/// <para>alternate defines if every other animation should be run in reverse order.</para>
		/// <para>delay is the time in milliseconds the animation should wait before start.</para>
		/// </summary>
		/// <param name="desc">The animation&#8217;s description.</param>
		/// <param name="duration">The duration in milliseconds of the animation, which will override the duration given in the description.</param>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "animate")]
		public static qxWeb Animate(object desc, double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Starts an animation in reversed order. For further details, take a look at
		/// the <see cref="Animate"/> method.</para>
		/// </summary>
		/// <param name="desc">The animation&#8217;s description.</param>
		/// <param name="duration">The duration in milliseconds of the animation, which will override the duration given in the description.</param>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "animateReverse")]
		public static qxWeb AnimateReverse(object desc, double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fades in all elements in the collection.</para>
		/// </summary>
		/// <param name="duration">The duration in milliseconds.</param>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "fadeIn")]
		public static qxWeb FadeIn(double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fades out all elements in the collection.</para>
		/// </summary>
		/// <param name="duration">The duration in milliseconds.</param>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "fadeOut")]
		public static qxWeb FadeOut(double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns whether an animation has ended or not.</para>
		/// </summary>
		/// <returns>true, if an animation has ended.</returns>
		[JsMethod(Name = "isEnded")]
		public static bool IsEnded() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns whether an animation is running or not.</para>
		/// </summary>
		/// <returns>true, if an animation is running.</returns>
		[JsMethod(Name = "isPlaying")]
		public static bool IsPlaying() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Manipulates the play state of the animation.
		/// This can be used to pause an animation when running.</para>
		/// </summary>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "pause")]
		public static qxWeb Pause() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Manipulates the play state of the animation.
		/// This can be used to continue an animation when paused.</para>
		/// </summary>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "play")]
		public static qxWeb Play() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Stops a running animation.</para>
		/// </summary>
		/// <returns>The collection for chaining.</returns>
		[JsMethod(Name = "stop")]
		public static qxWeb Stop() { throw new NotImplementedException(); }

		#endregion Methods
    }
}