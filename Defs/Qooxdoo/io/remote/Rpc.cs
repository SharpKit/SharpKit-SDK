// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.io.remote
{
    [JsType(JsMode.Prototype, Name = "qx.io.remote.Rpc", OmitOptionalParameters = true, Export = false)]
    public partial class Rpc : qx.core.Object
    {
		#region Events

		/// <summary>
		/// <para>Fired when call aborted.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnAborted;

		/// <summary>
		/// <para>Fired when call is completed.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnCompleted;

		/// <summary>
		/// <para>Fired when call failed.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnFailed;

		/// <summary>
		/// <para>Fired when call timed out.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnTimeout;

		#endregion Events

		#region Properties

		/// <summary>
		/// <para>Indicate that the request is cross domain.</para>
		/// <para>A request is cross domain if the request&#8217;s URL points to a host other
		/// than the local host. This switches the concrete implementation that is
		/// used for sending the request from qx.io.remote.transport.XmlHttp to
		/// qx.io.remote.transport.Script because only the latter can handle cross
		/// domain requests.</para>
		/// </summary>
		[JsProperty(Name = "crossDomain", NativeField = true)]
		public bool CrossDomain { get; set; }

		/// <summary>
		/// <para>Password to use for HTTP authentication. Null if HTTP authentication
		/// is not used.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "password", NativeField = true)]
		public string Password { get; set; }

		/// <summary>
		/// <para>EXPERIMENTAL</para>
		/// <para>Whether to use the original qooxdoo RPC protocol or the
		/// now-standardized Version 2 protocol.  Defaults to the original qooxdoo
		/// protocol for backward compatibility.</para>
		/// <para>Valid values are &#8220;qx1&#8221; and &#8220;2.0&#8221;.</para>
		/// </summary>
		[JsProperty(Name = "protocol", NativeField = true)]
		public object Protocol { get; set; }

		/// <summary>
		/// <para>Data sent as &#8220;out of band&#8221; data in the request to the server.  The
		/// format of the data is opaque to RPC and may be recognized only by
		/// particular servers It is up to the server to decide what to do with
		/// it: whether to ignore it, handle it locally before calling the
		/// specified method, or pass it on to the method.  This server data is
		/// not sent to the server if it has been set to &#8216;null&#8217;.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "serverData", NativeField = true)]
		public object ServerData { get; set; }

		/// <summary>
		/// <para>The service name.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "serviceName", NativeField = true)]
		public string ServiceName { get; set; }

		/// <summary>
		/// <para>The timeout for asynchronous calls in milliseconds.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "timeout", NativeField = true)]
		public double Timeout { get; set; }

		/// <summary>
		/// <para>The URL at which the service is located.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "url", NativeField = true)]
		public string Url { get; set; }

		/// <summary>
		/// <para>Use Basic HTTP Authentication</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "useBasicHttpAuth", NativeField = true)]
		public bool UseBasicHttpAuth { get; set; }

		/// <summary>
		/// <para>Username to use for HTTP authentication. Null if HTTP authentication
		/// is not used.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "username", NativeField = true)]
		public string Username { get; set; }

		#endregion Properties

		#region Methods

		public Rpc() { throw new NotImplementedException(); }

		/// <param name="url">identifies the url where the service is found.  Note that if the url is to a domain (server) other than where the qooxdoo script came from, i.e. it is cross-domain, then you must also call the setCrossDomain(true) method to enable the ScriptTransport instead of the XmlHttpTransport, since the latter can not handle cross-domain requests.</param>
		/// <param name="serviceName">identifies the service. For the Java implementation, this is the fully qualified name of the class that offers the service methods (e.g. &#8220;my.pkg.MyService&#8221;).</param>
		public Rpc(string url, string serviceName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Creates an URL for talking to a local service. A local service is one that
		/// lives in the same application as the page calling the service. For backends
		/// that don&#8217;t support this auto-generation, this method returns null.</para>
		/// </summary>
		/// <param name="instanceId">an optional identifier for the server side instance that should be used. All calls to the same service with the same instance id are routed to the same object instance on the server. The instance id can also be used to provide additional data for the service instantiation on the server.</param>
		/// <returns>the url.</returns>
		[JsMethod(Name = "makeServerURL")]
		public static string MakeServerURL(string instanceId = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Aborts an asynchronous server call. Consequently, the callback function
		/// provided to callAsync or callAsyncListeners
		/// will be called with an exception.</para>
		/// </summary>
		/// <param name="opaqueCallRef">the call reference as returned by callAsync or callAsyncListeners</param>
		[JsMethod(Name = "abort")]
		public void Abort(object opaqueCallRef) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Makes an asynchronous server call. The method arguments (if any) follow
		/// after the method name (as normal JavaScript arguments, separated by
		/// commas, not as an array).</para>
		/// <para>When an answer from the server arrives, the handler
		/// function is called with the result of the call as the first, an
		/// exception as the second parameter, and the id (aka sequence number) of
		/// the invoking request as the third parameter. If the call was
		/// successful, the second parameter is null. If there was a
		/// problem, the second parameter contains an exception, and the first one
		/// is null.</para>
		/// <para>The return value of this method is a call reference that you can store
		/// if you want to abort the request later on. This value should be treated
		/// as opaque and can change completely in the future! The only thing you
		/// can rely on is that the abort method will accept this
		/// reference and that you can retrieve the sequence number of the request
		/// by invoking the getSequenceNumber() method (see below).</para>
		/// <para>If a specific method is being called, asynchronously, a number of times
		/// in succession, the getSequenceNumber() method may be used to
		/// disambiguate which request a response corresponds to.  The sequence
		/// number value is a value which increments with each request.)</para>
		/// </summary>
		/// <param name="handler">the callback function.</param>
		/// <param name="methodName">the name of the method to call.</param>
		/// <returns>the method call reference.</returns>
		[JsMethod(Name = "callAsync")]
		public object CallAsync(Action<object> handler, string methodName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Makes an asynchronous server call and dispatches an event upon completion
		/// or failure. The method arguments (if any) follow after the method name
		/// (as normal JavaScript arguments, separated by commas, not as an array).</para>
		/// <para>When an answer from the server arrives (or fails to arrive on time), if
		/// an exception occurred, a &#8220;failed&#8221;, &#8220;timeout&#8221; or &#8220;aborted&#8221; event, as
		/// appropriate, is dispatched to any waiting event listeners.  If no
		/// exception occurred, a &#8220;completed&#8221; event is dispatched.</para>
		/// <para>When a &#8220;failed&#8221;, &#8220;timeout&#8221; or &#8220;aborted&#8221; event is dispatched, the event
		/// data contains an object with the properties &#8216;origin&#8217;, &#8216;code&#8217;, &#8216;message&#8217;
		/// and &#8216;id&#8217;.  The object has a toString() function which may be called to
		/// convert the exception to a string.</para>
		/// <para>When a &#8220;completed&#8221; event is dispatched, the event data contains a
		/// map with the JSON-RPC sequence number and result:</para>
		/// <para>{
		/// id: rpc_id,
		/// result: json-rpc result
		/// }</para>
		/// <para>The return value of this method is a call reference that you can store
		/// if you want to abort the request later on. This value should be treated
		/// as opaque and can change completely in the future! The only thing you
		/// can rely on is that the abort method will accept this
		/// reference and that you can retrieve the sequence number of the request
		/// by invoking the getSequenceNumber() method (see below).</para>
		/// <para>If a specific method is being called, asynchronously, a number of times
		/// in succession, the getSequenceNumber() method may be used to
		/// disambiguate which request a response corresponds to.  The sequence
		/// number value is a value which increments with each request.)</para>
		/// </summary>
		/// <param name="coalesce">coalesce all failure types (&#8220;failed&#8221;, &#8220;timeout&#8221;, and &#8220;aborted&#8221;) to &#8220;failed&#8221;. This is reasonable in many cases, as the provided exception contains adequate disambiguating information.</param>
		/// <param name="methodName">the name of the method to call.</param>
		/// <returns>the method call reference.</returns>
		[JsMethod(Name = "callAsyncListeners")]
		public object CallAsyncListeners(bool coalesce, string methodName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Makes a synchronous server call. The method arguments (if any) follow
		/// after the method name (as normal JavaScript arguments, separated by
		/// commas, not as an array).</para>
		/// <para>If a problem occurs when making the call, an exception is thrown.</para>
		/// <para>WARNING.  With some browsers, the synchronous interface
		/// causes the browser to hang while awaiting a response!  If the server
		/// decides to pause for a minute or two, your browser may do nothing
		/// (including refreshing following window changes) until the response is
		/// received.  Instead, use the asynchronous interface.</para>
		/// <para>YOU HAVE BEEN WARNED.</para>
		/// </summary>
		/// <param name="methodName">the name of the method to call.</param>
		/// <returns>the result returned by the server.</returns>
		[JsMethod(Name = "callSync")]
		public object CallSync(string methodName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Factory method to create a request object. By default, a POST request
		/// will be made, and the expected response type will be
		/// &#8220;application/json&#8221;. Classes extending this one may override this method
		/// to obtain a Request object with different parameters.</para>
		/// </summary>
		/// <returns></returns>
		[JsMethod(Name = "createRequest")]
		public qx.io.remote.Request CreateRequest() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Factory method to create the object containing the remote procedure
		/// call data. By default, a qooxdoo-style RPC request is built, which
		/// contains the following members: &#8220;service&#8221;, &#8220;method&#8221;, &#8220;id&#8221;, and
		/// &#8220;params&#8221;. If a different style of RPC request is desired, a class
		/// extending this one may override this method.</para>
		/// </summary>
		/// <param name="id">The unique sequence number of this request.</param>
		/// <param name="method">The name of the method to be called</param>
		/// <param name="parameters">An array containing the arguments to the called method.</param>
		/// <param name="serverData">&#8220;Out-of-band&#8221; data to be provided to the server.</param>
		/// <returns>The object to be converted to JSON and passed to the JSON-RPC server.</returns>
		[JsMethod(Name = "createRpcData")]
		public object CreateRpcData(double id, string method, JsArray parameters, object serverData) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Helper method to rewrite a URL with a stale session id (so that it includes
		/// the correct session id afterwards).</para>
		/// </summary>
		/// <param name="url">the URL to examine.</param>
		/// <returns>the (possibly re-written) URL.</returns>
		[JsMethod(Name = "fixUrl")]
		public string FixUrl(string url) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property crossDomain.</para>
		/// </summary>
		[JsMethod(Name = "getCrossDomain")]
		public bool GetCrossDomain() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property password.</para>
		/// </summary>
		[JsMethod(Name = "getPassword")]
		public string GetPassword() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property protocol.</para>
		/// </summary>
		[JsMethod(Name = "getProtocol")]
		public object GetProtocol() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property serverData.</para>
		/// </summary>
		[JsMethod(Name = "getServerData")]
		public object GetServerData() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property serviceName.</para>
		/// </summary>
		[JsMethod(Name = "getServiceName")]
		public string GetServiceName() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property timeout.</para>
		/// </summary>
		[JsMethod(Name = "getTimeout")]
		public double GetTimeout() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property url.</para>
		/// </summary>
		[JsMethod(Name = "getUrl")]
		public string GetUrl() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property useBasicHttpAuth.</para>
		/// </summary>
		[JsMethod(Name = "getUseBasicHttpAuth")]
		public bool GetUseBasicHttpAuth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property username.</para>
		/// </summary>
		[JsMethod(Name = "getUsername")]
		public string GetUsername() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property crossDomain
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property crossDomain.</param>
		[JsMethod(Name = "initCrossDomain")]
		public void InitCrossDomain(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property password
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property password.</param>
		[JsMethod(Name = "initPassword")]
		public void InitPassword(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property protocol
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property protocol.</param>
		[JsMethod(Name = "initProtocol")]
		public void InitProtocol(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property serverData
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property serverData.</param>
		[JsMethod(Name = "initServerData")]
		public void InitServerData(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property serviceName
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property serviceName.</param>
		[JsMethod(Name = "initServiceName")]
		public void InitServiceName(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property timeout
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property timeout.</param>
		[JsMethod(Name = "initTimeout")]
		public void InitTimeout(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property url
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property url.</param>
		[JsMethod(Name = "initUrl")]
		public void InitUrl(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property useBasicHttpAuth
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property useBasicHttpAuth.</param>
		[JsMethod(Name = "initUseBasicHttpAuth")]
		public void InitUseBasicHttpAuth(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property username
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property username.</param>
		[JsMethod(Name = "initUsername")]
		public void InitUsername(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property crossDomain equals true.</para>
		/// </summary>
		[JsMethod(Name = "isCrossDomain")]
		public void IsCrossDomain() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property useBasicHttpAuth equals true.</para>
		/// </summary>
		[JsMethod(Name = "isUseBasicHttpAuth")]
		public void IsUseBasicHttpAuth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Refreshes a server session by retrieving the session id again from the
		/// server.</para>
		/// <para>The specified handler function is called when the refresh is
		/// complete. The first parameter can be true (indicating that
		/// a refresh either wasn&#8217;t necessary at this time or it was successful) or
		/// false (indicating that a refresh would have been necessary
		/// but can&#8217;t be performed because the server backend doesn&#8217;t support
		/// it). If there is a non-null second parameter, it&#8217;s an exception
		/// indicating that there was an error when refreshing the session.</para>
		/// </summary>
		/// <param name="handler">a callback function that is called when the refresh is complete (or failed).</param>
		[JsMethod(Name = "refreshSession")]
		public void RefreshSession(Action<object> handler) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property crossDomain.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetCrossDomain")]
		public void ResetCrossDomain() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property password.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPassword")]
		public void ResetPassword() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property protocol.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetProtocol")]
		public void ResetProtocol() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property serverData.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetServerData")]
		public void ResetServerData() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property serviceName.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetServiceName")]
		public void ResetServiceName() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property timeout.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetTimeout")]
		public void ResetTimeout() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property url.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetUrl")]
		public void ResetUrl() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property useBasicHttpAuth.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetUseBasicHttpAuth")]
		public void ResetUseBasicHttpAuth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property username.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetUsername")]
		public void ResetUsername() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property crossDomain.</para>
		/// </summary>
		/// <param name="value">New value for property crossDomain.</param>
		[JsMethod(Name = "setCrossDomain")]
		public void SetCrossDomain(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property password.</para>
		/// </summary>
		/// <param name="value">New value for property password.</param>
		[JsMethod(Name = "setPassword")]
		public void SetPassword(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property protocol.</para>
		/// </summary>
		/// <param name="value">New value for property protocol.</param>
		[JsMethod(Name = "setProtocol")]
		public void SetProtocol(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property serverData.</para>
		/// </summary>
		/// <param name="value">New value for property serverData.</param>
		[JsMethod(Name = "setServerData")]
		public void SetServerData(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property serviceName.</para>
		/// </summary>
		/// <param name="value">New value for property serviceName.</param>
		[JsMethod(Name = "setServiceName")]
		public void SetServiceName(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property timeout.</para>
		/// </summary>
		/// <param name="value">New value for property timeout.</param>
		[JsMethod(Name = "setTimeout")]
		public void SetTimeout(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property url.</para>
		/// </summary>
		/// <param name="value">New value for property url.</param>
		[JsMethod(Name = "setUrl")]
		public void SetUrl(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property useBasicHttpAuth.</para>
		/// </summary>
		/// <param name="value">New value for property useBasicHttpAuth.</param>
		[JsMethod(Name = "setUseBasicHttpAuth")]
		public void SetUseBasicHttpAuth(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property username.</para>
		/// </summary>
		/// <param name="value">New value for property username.</param>
		[JsMethod(Name = "setUsername")]
		public void SetUsername(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property crossDomain.</para>
		/// </summary>
		[JsMethod(Name = "toggleCrossDomain")]
		public void ToggleCrossDomain() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property useBasicHttpAuth.</para>
		/// </summary>
		[JsMethod(Name = "toggleUseBasicHttpAuth")]
		public void ToggleUseBasicHttpAuth() { throw new NotImplementedException(); }

		#endregion Methods
    }
}