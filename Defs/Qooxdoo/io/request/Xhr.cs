// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.io.request
{
    /// <summary>
	/// <para>Send HTTP requests and handle responses using the HTTP client API.</para>
	/// <para>Configuration of the request is done with properties. Events are fired for
	/// various states in the life cycle of a request, such as &#8220;success&#8221;. Request
	/// data is transparently processed.</para>
	/// <para>Here is how to request a JSON file and listen to the &#8220;success&#8221; event:</para>
	/// <code>
	/// var req = new qx.io.request.Xhr("/some/path/file.json");
	/// req.addListener("success", function(e) {
	/// var req = e.getTarget();
	/// // Response parsed according to the server's
	/// // response content type, e.g. JSON
	/// req.getResponse();
	/// }, this);
	/// // Send request
	/// req.send();
	/// </code>
	/// <para>Some noteable features:</para>
	/// <list type="bullet">
	/// <item>Abstraction of low-level request</item>
	/// <item>Convenient setup using properties</item>
	/// <item>Fine-grained events</item>
	/// <item>Symbolic phases</item>
	/// <item>Transparent processing of request data</item>
	/// <item>Stream-lined authentication</item>
	/// <item>Automagic parsing of response based on content type</item>
	/// </list
	/// <para>Cross-origin requests are supported, but require browser support
	/// (see caniuse.com) and backend configuration
	/// (see MDN).
	/// Note that IE&#8217;s XDomainRequest is not currently supported.
	/// For a cross-browser alternative, consider <see cref="qx.io.request.Jsonp"/>.</para>
	/// <para>In order to debug requests, set the environment flag
	/// qx.debug.io.</para>
	/// <para>Internally uses <see cref="qx.bom.request.Xhr"/>.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.io.request.Xhr", OmitOptionalParameters = true, Export = false)]
    public partial class Xhr : qx.io.request.AbstractRequest
    {
		#region Events

		/// <summary>
		/// <para>Fired when request completes without error.</para>
		/// <para>Every request not canceled or aborted completes. This means that
		/// even requests receiving a response with erroneous HTTP status
		/// fire a &#8220;load&#8221; event. If you are only interested in successful
		/// responses, listen to the <see cref="Success"/> event instead.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnLoad;

		/// <summary>
		/// <para>Fired on every change of the transport&#8217;s readyState.</para>
		/// <para>See <see cref="qx.bom.request.Xhr"/> for available readyStates.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnReadyStateChange;

		/// <summary>
		/// <para>Fired when request completes without error but erroneous HTTP status.</para>
		/// <para>Refer to <see cref="qx.util.Request.IsSuccessful"/> for a list of HTTP
		/// status considered successful.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnStatusError;

		/// <summary>
		/// <para>Fired when request completes without eror and transport&#8217;s status
		/// indicates success.</para>
		/// <para>Refer to <see cref="qx.util.Request.IsSuccessful"/> for a list of HTTP
		/// status considered successful.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnSuccess;

		#endregion Events

		#region Properties

		/// <summary>
		/// <para>The content type to accept. By default, every content type
		/// is accepted.</para>
		/// <para>Note: Some backends send distinct representations of the same
		/// resource depending on the content type accepted. For instance,
		/// a backend may respond with either a JSON (the accept header
		/// indicates so) or a HTML representation (the default, no accept
		/// header given).</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "accept", NativeField = true)]
		public string Accept { get; set; }

		/// <summary>
		/// <para>Whether the request should be executed asynchronously.</para>
		/// </summary>
		[JsProperty(Name = "async", NativeField = true)]
		public bool Async { get; set; }

		/// <summary>
		/// <para>Whether to allow request to be answered from cache.</para>
		/// <para>Allowed values:</para>
		/// <list type="bullet">
		/// <item>true: Allow caching (Default)</item>
		/// <item>false: Prohibit caching. Appends nocache parameter to URL.</item>
		/// <item>String: Any Cache-Control request directive</item>
		/// </list
		/// <para>If a string is given, it is inserted in the request&#8217;s Cache-Control
		/// header. A request&#8217;s Cache-Control header may contain a number of directives
		/// controlling the behavior of any caches in between client and origin
		/// server.</para>
		/// <list type="bullet">
		/// <item>&#8220;no-cache&#8221;: Force caches to submit request in order to
		/// validate the freshness of the representation. Note that the requested
		/// resource may still be served from cache if the representation is
		/// considered fresh. Use this directive to ensure freshness but save
		/// bandwidth when possible.</item>
		/// <item>&#8220;no-store&#8221;: Do not keep a copy of the representation under
		/// any conditions.</item>
		/// </list
		/// <para>See 
		/// Caching tutorial for an excellent introduction to Caching in general.
		/// Refer to the corresponding section in the
		/// 
		/// HTTP 1.1 specification for more details and advanced directives.</para>
		/// <para>It is recommended to choose an appropriate Cache-Control directive rather
		/// than prohibit caching using the nocache parameter.</para>
		/// </summary>
		[JsProperty(Name = "cache", NativeField = true)]
		public object Cache { get; set; }

		/// <summary>
		/// <para>The HTTP method.</para>
		/// </summary>
		[JsProperty(Name = "method", NativeField = true)]
		public object Method { get; set; }

		#endregion Properties

		#region Methods

		public Xhr() { throw new NotImplementedException(); }

		/// <param name="url">The URL of the resource to request.</param>
		/// <param name="method">The HTTP method.</param>
		public Xhr(string url, string method) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property accept.</para>
		/// </summary>
		[JsMethod(Name = "getAccept")]
		public string GetAccept() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property async.</para>
		/// </summary>
		[JsMethod(Name = "getAsync")]
		public bool GetAsync() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property cache.</para>
		/// </summary>
		[JsMethod(Name = "getCache")]
		public object GetCache() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property method.</para>
		/// </summary>
		[JsMethod(Name = "getMethod")]
		public object GetMethod() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property accept
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property accept.</param>
		[JsMethod(Name = "initAccept")]
		public void InitAccept(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property async
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property async.</param>
		[JsMethod(Name = "initAsync")]
		public void InitAsync(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property cache
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property cache.</param>
		[JsMethod(Name = "initCache")]
		public void InitCache(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property method
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property method.</param>
		[JsMethod(Name = "initMethod")]
		public void InitMethod(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property async equals true.</para>
		/// </summary>
		[JsMethod(Name = "isAsync")]
		public void IsAsync() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property accept.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetAccept")]
		public void ResetAccept() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property async.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetAsync")]
		public void ResetAsync() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property cache.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetCache")]
		public void ResetCache() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property method.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetMethod")]
		public void ResetMethod() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property accept.</para>
		/// </summary>
		/// <param name="value">New value for property accept.</param>
		[JsMethod(Name = "setAccept")]
		public void SetAccept(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property async.</para>
		/// </summary>
		/// <param name="value">New value for property async.</param>
		[JsMethod(Name = "setAsync")]
		public void SetAsync(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property cache.</para>
		/// </summary>
		/// <param name="value">New value for property cache.</param>
		[JsMethod(Name = "setCache")]
		public void SetCache(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property method.</para>
		/// </summary>
		/// <param name="value">New value for property method.</param>
		[JsMethod(Name = "setMethod")]
		public void SetMethod(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set parser used to parse response once request has
		/// completed successfully.</para>
		/// <para>Usually, the parser is correctly inferred from the
		/// content type of the response. This method allows to force the
		/// parser being used, e.g. if the content type returned from
		/// the backend is wrong or the response needs special parsing.</para>
		/// <para>Parsers most typically used can be referenced symbolically.
		/// To cover edge cases, a function can be given. When parsing
		/// the response, this function is called with the raw response as
		/// first argument.</para>
		/// </summary>
		/// <param name="parser">Can be:  * A parser defined in qx.io.request.Xhr#PARSER, referenced by string.  * The function to invoke. Receives the raw response as argument.</param>
		/// <returns>The parser function</returns>
		[JsMethod(Name = "setParser")]
		public Action<object> SetParser(object parser) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property async.</para>
		/// </summary>
		[JsMethod(Name = "toggleAsync")]
		public void ToggleAsync() { throw new NotImplementedException(); }

		#endregion Methods
    }
}