// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.io.rest
{
    /// <summary>
	/// <para>Client-side wrapper of a REST resource.</para>
	/// <para>Each instance represents a resource in terms of REST. A number of actions
	/// (usually HTTP methods) unique to the resource can be defined and invoked.
	/// A resource with its actions is configured declaratively by passing a resource
	/// description to the constructor, or programatically using <see cref="Map"/>.</para>
	/// <para>Each action is associated to a route. A route is a combination of method,
	/// URL pattern and optional parameter constraints.</para>
	/// <para>An action is invoked by calling a method with the same name. When a URL
	/// pattern of a route contains positional parameters, those parameters must be
	/// passed when invoking the associated action. Also, constraints defined in the
	/// route must be satisfied.</para>
	/// <para>When an action is invoked, a request is configured according to the associated
	/// route, is passed the URL parameters, request body data, and finally send.
	/// What kind of request is send can be configured by overwriting <see cref="#_getRequest"/>.</para>
	/// <para>No contraints on the action&#8217;s name or the scope of the URLs are imposed. However,
	/// if you want to follow RESTful design patterns it is recommended to name actions
	/// the same as the HTTP action.</para>
	/// <code>
	/// var description = {
	/// "get": { method: "GET", url: "/photo/{id}" },
	/// "put": { method: "PUT", url: "/photo/{id}"},
	/// "post": { method: "POST", url: "/photos/"}
	/// };
	/// var photo = new qx.io.rest.Resource(description);
	/// // Can also be written: photo.invoke("get", {id: 1});
	/// photo.get({id: 1});
	/// // Additionally sets request data
	/// // In a RESTful environment this creates a new resource with the given 'id'
	/// photo.put({id: 1}, {title: "Monkey"});
	/// // Additionally sets request data
	/// // In a RESTful environment this adds a new resource to the resource collection 'photos'
	/// photo.post(null, {title: "Monkey"});
	/// </code>
	/// <para>To check for existence of URL parameters or constrain them to a certain format, you
	/// can add a check property to the description. See <see cref="Map"/> for details.</para>
	/// <code>
	/// var description = {
	/// "get": { method: "GET", url: "/photo/{id}", check: { id: /\d+/ } }
	/// };
	/// var photo = new qx.io.rest.Resource(description);
	/// // photo.get({id: "FAIL"});
	/// // -- Error: "Parameter 'id' is invalid"
	/// </code>
	/// <para>If your description happens to use the same action more than once, consider
	/// defining another resource.</para>
	/// <code>
	/// var description = {
	/// "get": { method: "GET", url: "/photos"},
	/// };
	/// // Distinguish "photo" (singular) and "photos" (plural) resource
	/// var photos = new qx.io.rest.Resource(description);
	/// photos.get();
	/// </code>
	/// <para>Basically, all routes of a resource should point to the same URL (resource in
	/// terms of HTTP). One acceptable exception of this constraint are resources where
	/// required parameters are part of the URL (/photos/1/) or filter
	/// resources. For instance:</para>
	/// <code>
	/// var description = {
	/// "get": { method: "GET", url: "/photos/{tag}" }
	/// };
	/// var photos = new qx.io.rest.Resource(description);
	/// photos.get();
	/// photos.get({tag: "wildlife"})
	/// </code>
	/// <para>Strictly speaking, the photos instance represents two distinct resources
	/// and could therefore just as well mapped to two distinct resources (for instance,
	/// named photos and photosTagged). What style to choose depends on the kind of data
	/// returned. For instance, it seems sensible to stick with one resource if the filter
	/// only limits the result set (i.e. the invidual results have the same properties).</para>
	/// <para>In order to respond to successful (or erroneous) invocations of actions,
	/// either listen to the generic &#8220;success&#8221; or &#8220;error&#8221; event and get the action
	/// from the event data, or listen to action specific events defined at runtime.
	/// Action specific events follow the pattern &#8221;&lt;action&gt;Success&#8221; and
	/// &#8221;&lt;action&gt;Error&#8221;, e.g. &#8220;indexSuccess&#8221;.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.io.rest.Resource", OmitOptionalParameters = true, Export = false)]
    public partial class Resource : qx.core.Object
    {
		#region Events

		/// <summary>
		/// <para>Fired when any request associated to action given in prefix fails.</para>
		/// <para>For example, &#8220;indexError&#8221; is fired when index() failed.</para>
		/// </summary>
		public event Action<qx.eventx.type.Rest> OnActionError;

		/// <summary>
		/// <para>Fired when request associated to action given in prefix was successful.</para>
		/// <para>For example, &#8220;indexSuccess&#8221; is fired when index() was
		/// successful.</para>
		/// </summary>
		public event Action<qx.eventx.type.Rest> OnActionSuccess;

		/// <summary>
		/// <para>Fired when any request fails.</para>
		/// <para>The action the failed request is associated to, as well as the
		/// request itself, can be retrieved from the event&#8217;s properties.
		/// Additionally, an action specific event is fired that follows the pattern
		/// &#8221;Error&#8221;, e.g. &#8220;indexError&#8221;.</para>
		/// </summary>
		public event Action<qx.eventx.type.Rest> OnError;

		/// <summary>
		/// <para>Fired when any request was successful.</para>
		/// <para>The action the successful request is associated to, as well as the
		/// request itself, can be retrieved from the event&#8217;s properties.
		/// Additionally, an action specific event is fired that follows the pattern
		/// &#8221;Success&#8221;, e.g. &#8220;indexSuccess&#8221;.</para>
		/// </summary>
		public event Action<qx.eventx.type.Rest> OnSuccess;

		#endregion Events

		#region Methods

		public Resource() { throw new NotImplementedException(); }

		/// <param name="description">Each key of the map is interpreted as action name. The value associated to the key must be a map with the properties method and url. check is optional. Also see #map.  For example:   { get: {method: "GET", url: "/photos/{id}", check: { id: /\d+/ } } </param>
		public Resource(object description) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get placeholders from URL.</para>
		/// </summary>
		/// <param name="url">The URL to parse for placeholders.</param>
		/// <returns>Array of placeholders without the placeholder prefix.</returns>
		[JsMethod(Name = "placeholdersFromUrl")]
		public static JsArray PlaceholdersFromUrl(string url) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Abort action.</para>
		/// <para>Example:</para>
		/// <code>
		/// // Abort all invocations of action
		/// res.get({id: 1});
		/// res.get({id: 2});
		/// res.abort();
		/// // Abort specific invocation of action (by id)
		/// var actionId = res.get({id: 1});
		/// res.abort(actionId);
		/// </code>
		/// </summary>
		/// <param name="varargs">Action of which all invocations to abort (when string), or a single invocation of an action to abort (when number)</param>
		[JsMethod(Name = "abort")]
		public void Abort(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Configure request.</para>
		/// </summary>
		/// <param name="callback">Function called before request is send. Receives request, action, params and data.   res.configureRequest(function(req, action, params, data) { if (action === "index") { req.setAccept("application/json"); } }); </param>
		[JsMethod(Name = "configureRequest")]
		public void ConfigureRequest(Action<object> callback) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Invoke action with parameters.</para>
		/// <para>Internally called by actions dynamically created.</para>
		/// <para>May be overriden to customize action and parameter handling.</para>
		/// </summary>
		/// <param name="action">Action to invoke.</param>
		/// <param name="paramsx">Map of parameters inserted into URL when a matching positional parameter is found.</param>
		/// <param name="data">Data to be send as part of the request. See qx.io.request.AbstractRequest#requestData.</param>
		/// <returns>Id of the action&#8217;s invocation.</returns>
		[JsMethod(Name = "invoke")]
		public double Invoke(string action, object paramsx, object data) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Long-poll action.</para>
		/// <para>Use Ajax long-polling to continously fetch a resource as soon as the
		/// server signals new data. The server determines when new data is available,
		/// while the client keeps open a request. Requires configuration on the
		/// server side. Basically, the server must not close a connection until
		/// new data is available. For a high level introduction to long-polling,
		/// refer to 
		/// Ajax with long polling.</para>
		/// <para>Uses <see cref="Refresh"/> internally. Make sure you understand the
		/// implications of IE&#8217;s tendency to cache overly agressive.</para>
		/// <para>Note no interval is given on the client side.</para>
		/// </summary>
		/// <param name="action">Action to poll.</param>
		/// <returns>Id of handler responsible for long-polling. To stop polling, remove handler using qx.core.Object#removeListenerById.</returns>
		[JsMethod(Name = "longPoll")]
		public string LongPoll(string action) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Map action to combination of method and URL pattern.</para>
		/// <code>
		/// res.map("get", "GET", "/photos/{id}", {id: /\d+/});
		/// // GET /photos/123
		/// res.get({id: "123"});
		/// </code>
		/// </summary>
		/// <param name="action">Action to associate to request.</param>
		/// <param name="method">Method to configure request with.</param>
		/// <param name="url">URL to configure request with. May contain positional parameters ({param}) that are replaced by values given when the action is invoked. Parameters are optional, unless a check is defined. A default value can be provided ({param=default}).</param>
		/// <param name="check">Map defining parameter constraints, where the key is the URL parameter and the value a regular expression (to match string) or qx.io.rest.Resource.REQUIRED (to verify existence).</param>
		[JsMethod(Name = "map")]
		public void Map(string action, string method, string url, object check) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Periodically invoke action.</para>
		/// <para>Replays parameters given when action was invoked originally. When the
		/// action was not yet invoked and requires parameters, parameters must be
		/// given.</para>
		/// <para>Please note that IE tends to cache overly agressive. One work-around is
		/// to disable caching on the client side by configuring the request with
		/// setCache(false). If you control the server, a better
		/// work-around is to include appropriate headers to explicitly control
		/// caching. This way you still avoid requests that can be correctly answered
		/// from cache (e.g. when nothing has changed since the last poll). Please
		/// refer to 
		/// XMLHttpRequest Caching Test for available options.</para>
		/// </summary>
		/// <param name="action">Action to poll.</param>
		/// <param name="interval">Interval in ms.</param>
		/// <param name="paramsx">Map of parameters. See #invoke.</param>
		/// <param name="immediately">true, if the poll should invoke a call immediately.</param>
		/// <returns>Timer that periodically invokes action. Use to stop or resume. Is automatically disposed on disposal of object.</returns>
		[JsMethod(Name = "poll")]
		public qx.eventx.Timer Poll(string action, double interval, object paramsx, bool immediately = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resend request associated to action.</para>
		/// <para>Replays parameters given when action was invoked originally.</para>
		/// </summary>
		/// <param name="action">Action to refresh.</param>
		[JsMethod(Name = "refresh")]
		public void Refresh(string action) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set base URL.</para>
		/// <para>The base URL is prepended to the URLs given in the description.
		/// Changes affect all future invocations.</para>
		/// </summary>
		/// <param name="baseUrl">Base URL.</param>
		[JsMethod(Name = "setBaseUrl")]
		public void SetBaseUrl(string baseUrl) { throw new NotImplementedException(); }

		#endregion Methods
    }
}