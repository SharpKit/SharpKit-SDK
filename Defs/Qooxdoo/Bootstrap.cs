// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx
{
    /// <summary>
	/// <para>Internal class that is responsible for bootstrapping the qooxdoo
	/// framework at load time.</para>
	/// <para>Does support:</para>
	/// <list type="bullet">
	/// <item>Construct</item>
	/// <item>Statics</item>
	/// <item>Members</item>
	/// <item>Extend</item>
	/// <item>Defer</item>
	/// </list
	/// <para>Does not support:</para>
	/// <list type="bullet">
	/// <item>Super class calls</item>
	/// <item>Mixins, Interfaces, Properties, ...</item>
	/// </list
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.Bootstrap", OmitOptionalParameters = true, Export = false)]
    public partial class Bootstrap 
    {
		#region Methods

		public Bootstrap() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a function whose &#8220;this&#8221; is altered.</para>
		/// <para>Syntax</para>
		/// <code>qx.Bootstrap.bind(myFunction, [self, [varargs...]]);</code>
		/// <para>Example</para>
		/// <code>
		/// function myFunction()
		/// {
		/// this.setStyle('color', 'red');
		/// // note that 'this' here refers to myFunction, not an element
		/// // we'll need to bind this function to the element we want to alter
		/// };
		/// var myBoundFunction = qx.Bootstrap.bind(myFunction, myElement);
		/// myBoundFunction(); // this will make the element myElement red.
		/// </code>
		/// </summary>
		/// <param name="func">Original function to wrap</param>
		/// <param name="self">The object that the &#8220;this&#8221; of the function will refer to.</param>
		/// <param name="varargs">The arguments to pass to the function.</param>
		/// <returns>The bound function.</returns>
		[JsMethod(Name = "bind")]
		public static Action<object> Bind(Action<object> func, object self = null, JsArguments varargs = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sending a message at level &#8220;debug&#8221; to the logger.</para>
		/// </summary>
		/// <param name="objectx">Contextual object (either instance or static class)</param>
		/// <param name="message">Any number of arguments supported. An argument may have any JavaScript data type. All data is serialized immediately and does not keep references to other objects.</param>
		[JsMethod(Name = "debug")]
		public static void Debug(object objectx, object message) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sending a message at level &#8220;error&#8221; to the logger.</para>
		/// </summary>
		/// <param name="objectx">Contextual object (either instance or static class)</param>
		/// <param name="message">Any number of arguments supported. An argument may have any JavaScript data type. All data is serialized immediately and does not keep references to other objects.</param>
		[JsMethod(Name = "error")]
		public static void Error(object objectx, object message) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inherit a clazz from a super class.</para>
		/// <para>This function differentiates between class and constructor because the
		/// constructor written by the user might be wrapped and the base
		/// property has to be attached to the constructor, while the superclass
		/// property has to be attached to the wrapped constructor.</para>
		/// </summary>
		/// <param name="clazz">The class&#8217;s wrapped constructor</param>
		/// <param name="construct">The unwrapped constructor</param>
		/// <param name="superClass">The super class</param>
		/// <param name="name">fully qualified class name</param>
		/// <param name="basename">the base name</param>
		[JsMethod(Name = "extendClass")]
		public static void ExtendClass(Action<object> clazz, Action<object> construct, Action<object> superClass, Action<object> name, Action<object> basename) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Convert the first character of the string to lower case.</para>
		/// </summary>
		/// <param name="str">the string</param>
		/// <returns>the string with a lower case first character</returns>
		[JsMethod(Name = "firstLow")]
		public static string FirstLow(string str) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Convert the first character of the string to upper case.</para>
		/// </summary>
		/// <param name="str">the string</param>
		/// <returns>the string with an upper case first character</returns>
		[JsMethod(Name = "firstUp")]
		public static string FirstUp(string str) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Find a class by its name</para>
		/// </summary>
		/// <param name="name">class name to resolve</param>
		/// <returns>the class</returns>
		[JsMethod(Name = "getByName")]
		public static Class GetByName(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the internal class of the value. See
		/// http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
		/// for details.</para>
		/// </summary>
		/// <param name="value">value to get the class for</param>
		/// <returns>the internal class of the value</returns>
		[JsMethod(Name = "getClass")]
		public static string GetClass(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Minimal accessor API for the environment settings given from the
		/// generator.</para>
		/// <para>WARNING: This method only should be used if the
		/// <see cref="qx.core.Environment"/> class is not loaded!</para>
		/// </summary>
		/// <param name="key">The key to get the value from.</param>
		/// <returns>The value of the setting or undefined.</returns>
		[JsMethod(Name = "getEnvironmentSetting")]
		public static object GetEnvironmentSetting(string key) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the keys of a map as array as returned by a &#8220;for&#8230; in&#8221; statement.</para>
		/// </summary>
		/// <param name="map">the map</param>
		/// <returns>array of the keys of the map</returns>
		[JsMethod(Name = "getKeys")]
		public static JsArray GetKeys(object map) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the keys of a map as string</para>
		/// </summary>
		/// <param name="map">the map</param>
		/// <returns>String of the keys of the map The keys are separated by &#8221;, &#8221;</returns>
		[JsMethod(Name = "getKeysAsString")]
		public static string GetKeysAsString(object map) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sending a message at level &#8220;info&#8221; to the logger.</para>
		/// </summary>
		/// <param name="objectx">Contextual object (either instance or static class)</param>
		/// <param name="message">Any number of arguments supported. An argument may have any JavaScript data type. All data is serialized immediately and does not keep references to other objects.</param>
		[JsMethod(Name = "info")]
		public static void Info(object objectx, object message) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the value is an array.</para>
		/// </summary>
		/// <param name="value">Value to check.</param>
		/// <returns>Whether the value is an array.</returns>
		[JsMethod(Name = "isArray")]
		public static bool IsArray(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the value is a function.</para>
		/// </summary>
		/// <param name="value">Value to check.</param>
		/// <returns>Whether the value is a function.</returns>
		[JsMethod(Name = "isFunction")]
		public static bool IsFunction(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the value is an object. Note that built-in types like Window are
		/// not reported to be objects.</para>
		/// </summary>
		/// <param name="value">Value to check.</param>
		/// <returns>Whether the value is an object.</returns>
		[JsMethod(Name = "isObject")]
		public static bool IsObject(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the value is a string.</para>
		/// </summary>
		/// <param name="value">Value to check.</param>
		/// <returns>Whether the value is a string.</returns>
		[JsMethod(Name = "isString")]
		public static bool IsString(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the number of own properties in the object.</para>
		/// </summary>
		/// <param name="map">the map</param>
		/// <returns>number of objects in the map</returns>
		[JsMethod(Name = "objectGetLength")]
		public static double ObjectGetLength(object map) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts all keys of the source object into the
		/// target objects. Attention: The target map gets modified.</para>
		/// </summary>
		/// <param name="target">target object</param>
		/// <param name="source">object to be merged</param>
		/// <param name="overwrite">If enabled existing keys will be overwritten</param>
		/// <returns>Target with merged values from the source object</returns>
		[JsMethod(Name = "objectMergeWith")]
		public static object ObjectMergeWith(object target, object source, bool overwrite = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the display name of the given function</para>
		/// </summary>
		/// <param name="fcn">the function to set the display name for</param>
		/// <param name="classname">the name of the class the function is defined in</param>
		/// <param name="name">the function name</param>
		[JsMethod(Name = "setDisplayName")]
		public static void SetDisplayName(Action<object> fcn, string classname, string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set the names of all functions defined in the given map</para>
		/// </summary>
		/// <param name="functionMap">a map with functions as values</param>
		/// <param name="classname">the name of the class, the functions are defined in</param>
		[JsMethod(Name = "setDisplayNames")]
		public static void SetDisplayNames(object functionMap, string classname) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Minimal mutator for the environment settings given from the generator.
		/// It checks for the existance of the environment settings and sets the
		/// key if its not given from the generator. If a setting is available from
		/// the generator, the setting will be ignored.</para>
		/// <para>WARNING: This method only should be used if the
		/// <see cref="qx.core.Environment"/> class is not loaded!</para>
		/// </summary>
		/// <param name="key">The key of the setting.</param>
		/// <param name="value">The value for the setting.</param>
		[JsMethod(Name = "setEnvironmentSetting")]
		public static void SetEnvironmentSetting(string key, object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Prints the current stack trace at level &#8220;info&#8221;</para>
		/// </summary>
		/// <param name="objectx">Contextual object (either instance or static class)</param>
		[JsMethod(Name = "trace")]
		public static void Trace(object objectx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sending a message at level &#8220;warn&#8221; to the logger.</para>
		/// </summary>
		/// <param name="objectx">Contextual object (either instance or static class)</param>
		/// <param name="message">Any number of arguments supported. An argument may have any JavaScript data type. All data is serialized immediately and does not keep references to other objects.</param>
		[JsMethod(Name = "warn")]
		public static void Warn(object objectx, object message) { throw new NotImplementedException(); }

		#endregion Methods
    }
}