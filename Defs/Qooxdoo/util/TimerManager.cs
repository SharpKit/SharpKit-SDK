// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.util
{
    /// <summary>
	/// <para>Timer manipulation for handling multiple timed callbacks with the use of
	/// only a single native timer object.</para>
	/// <para>Use of these timers is via the methods start() and stop().  Examples:</para>
	/// <code>
	/// var timer = qx.util.TimerManager.getInstance();
	/// // Start a 5-second recurrent timer.
	/// // Note that the first expiration is after 3 seconds
	/// // (last parameter is 3000) but each subsequent expiration is
	/// // at 5 second intervals.
	/// timer.start(function(userData, timerId)
	/// {
	/// this.debug("Recurrent 5-second timer: " + timerId);
	/// },
	/// 5000,
	/// this,
	/// null,
	/// 3000);
	/// // Start a 1-second one-shot timer
	/// timer.start(function(userData, timerId)
	/// {
	/// this.debug("One-shot 1-second timer: " + timerId);
	/// },
	/// 0,
	/// this,
	/// null,
	/// 1000);
	/// // Start a 2-second recurrent timer that stops itself after
	/// // three iterations
	/// timer.start(function(userData, timerId)
	/// {
	/// this.debug("Recurrent 2-second timer with limit 3:" +
	/// timerId);
	/// if (++userData.count == 3)
	/// {
	/// this.debug("Stopping recurrent 2-second timer");
	/// timer.stop(timerId);
	/// }
	/// },
	/// 2000,
	/// this,
	/// { count : 0 });
	/// // Start an immediate one-shot timer
	/// timer.start(function(userData, timerId)
	/// {
	/// this.debug("Immediate one-shot timer: " + timerId);
	/// });
	/// </code>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.util.TimerManager", OmitOptionalParameters = true, Export = false)]
    public partial class TimerManager : qx.core.Object
    {
		#region Methods

		public TimerManager() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Start a new timer</para>
		/// </summary>
		/// <param name="callback">Function to be called upon expiration of the timer.  The function is passed these parameters:  userData The user data provided to the start() method timerId The timer id, as was returned by the start() method </param>
		/// <param name="recurTime">If null, the timer will not recur.  Once the callback function returns the first time, the timer will be removed from the timer queue.  If non-null, upon return from the callback function, the timer will be reset to this number of milliseconds.</param>
		/// <param name="context">Context (this) the callback function is called with.  If not provided, this Timer singleton object is used.</param>
		/// <param name="userData">Data which is passed to the callback function upon timer expiry</param>
		/// <param name="initialTime">Milliseconds before the callback function is called the very first time.  If not specified and recurTime is specified, then recurTime will be used as initialTime; otherwise initialTime will default to zero.</param>
		/// <returns>The timer id of this unique timer.  It may be provided to the stop() method to cancel a timer before expiration.</returns>
		[JsMethod(Name = "start")]
		public double Start(Action<object> callback, double recurTime, qx.core.Object context, object userData, double initialTime) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Stop a running timer</para>
		/// </summary>
		/// <param name="timerId">A timer id previously returned by start()</param>
		[JsMethod(Name = "stop")]
		public void Stop(double timerId) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a singleton instance of this class. On the first call the class
		/// is instantiated by calling the constructor with no arguments. All following
		/// calls will return this instance.</para>
		/// <para>This method has been added by setting the &#8220;type&#8221; key in the class definition
		/// (<see cref="qx.Class.Define"/>) to &#8220;singleton&#8221;.</para>
		/// </summary>
		/// <returns>The singleton instance of this class.</returns>
		[JsMethod(Name = "getInstance")]
		public static qx.util.TimerManager GetInstance() { throw new NotImplementedException(); }

		#endregion Methods
    }
}