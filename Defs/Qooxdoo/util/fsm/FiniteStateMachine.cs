// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.util.fsm
{
    /// <summary>
	/// <para>A finite state machine.</para>
	/// <para>See <see cref="qx.util.fsm.State"/> for details on creating States,
	/// and <see cref="qx.util.fsm.Transition"/> for details on creating
	/// transitions between states.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.util.fsm.FiniteStateMachine", OmitOptionalParameters = true, Export = false)]
    public partial class FiniteStateMachine : qx.core.Object
    {
		#region Properties

		/// <summary>
		/// <para>Debug flags, composed of the bitmask values in the DebugFlags constant.</para>
		/// <para>Set the debug flags from the application by or-ing together bits, akin
		/// to this:</para>
		/// <code>
		/// var FSM = qx.util.fsm.FiniteStateMachine;
		/// fsm.setDebugFlags(FSM.DebugFlags.EVENTS |
		/// FSM.DebugFlags.TRANSITIONS |
		/// FSM.DebugFlags.FUNCTION_DETAIL |
		/// FSM.DebugFlags.OBJECT_NOT_FOUND);
		/// </code>
		/// </summary>
		[JsProperty(Name = "debugFlags", NativeField = true)]
		public double DebugFlags { get; set; }

		/// <summary>
		/// <para>The maximum number of states which may pushed onto the state-stack.  It
		/// is generally a poor idea to have very many states saved on a stack.
		/// Following program logic becomes very difficult, and the code can be
		/// highly unmaintainable.  The default should be more than adequate.
		/// You&#8217;ve been warned.</para>
		/// </summary>
		[JsProperty(Name = "maxSavedStates", NativeField = true)]
		public double MaxSavedStates { get; set; }

		/// <summary>
		/// <para>The name of this finite state machine (for debug messages)</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "name", NativeField = true)]
		public string Name { get; set; }

		/// <summary>
		/// <para>The state to which we will be transitioning.  This property is valid
		/// only during a Transition&#8217;s ontransition function and a State&#8217;s onexit
		/// function.  At all other times, it is null.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "nextState", NativeField = true)]
		public string NextState { get; set; }

		/// <summary>
		/// <para>The previous state of the finite state machine, i.e. the state from
		/// which we most recently transitioned.  Note that this could be the same
		/// as the current state if a successful transition brought us back to the
		/// same state.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "previousState", NativeField = true)]
		public string PreviousState { get; set; }

		/// <summary>
		/// <para>The current state of the finite state machine.</para>
		/// </summary>
		/// <remarks>
		/// Allow nulls: true
		/// </remarks>
		[JsProperty(Name = "state", NativeField = true)]
		public string State { get; set; }

		#endregion Properties

		#region Methods

		public FiniteStateMachine() { throw new NotImplementedException(); }

		/// <param name="machineName">The name of this finite state machine</param>
		public FiniteStateMachine(string machineName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add an object (typically a widget) that is to be accessed during state
		/// transitions, to the finite state machine.</para>
		/// </summary>
		/// <param name="friendlyName">The friendly name to used for access to the object being added.</param>
		/// <param name="obj">The object to associate with the specified friendly name</param>
		/// <param name="groupNames">An optional list of group names of which this object is a member.</param>
		[JsMethod(Name = "addObject")]
		public void AddObject(string friendlyName, object obj, JsArray groupNames) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add a state to the finite state machine.</para>
		/// </summary>
		/// <param name="state">An object of class qx.util.fsm.State representing a state which is to be a part of this finite state machine.</param>
		[JsMethod(Name = "addState")]
		public void AddState(qx.util.fsm.State state) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Display all of the saved objects and their reverse mappings.</para>
		/// </summary>
		[JsMethod(Name = "displayAllObjects")]
		public void DisplayAllObjects() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Enqueue an event for processing</para>
		/// </summary>
		/// <param name="eventx">The event to be enqueued</param>
		/// <param name="bAddAtHead">If true, put the event at the head of the queue for immediate processing.  If false, place the event at the tail of the queue so that it receives in-order processing.</param>
		[JsMethod(Name = "enqueueEvent")]
		public void EnqueueEvent(qx.eventx.type.Event eventx, bool bAddAtHead) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Event listener for all event types in the finite state machine</para>
		/// </summary>
		/// <param name="eventx">The event that was dispatched.</param>
		[JsMethod(Name = "eventListener")]
		public void EventListener(qx.eventx.type.Event eventx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Create an event and send it immediately to the finite state machine.</para>
		/// </summary>
		/// <param name="type">The type of event, e.g. &#8220;execute&#8221;</param>
		/// <param name="target">The target of the event</param>
		/// <param name="data">The data, if any, to issue in the event.  If this parameter is null then a qx.event.type.Event is instantiated.  Otherwise, an event of type qx.event.type.Data is instantiated and this data is applied to it.</param>
		[JsMethod(Name = "fireImmediateEvent")]
		public void FireImmediateEvent(string type, qx.core.Object target, object data) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property debugFlags.</para>
		/// </summary>
		[JsMethod(Name = "getDebugFlags")]
		public double GetDebugFlags() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the friendly name of an object.</para>
		/// </summary>
		/// <param name="obj">The object for which the friendly name is desired</param>
		/// <returns>If the object has been previously registered via #addObject, then the friendly name of the object is returned; otherwise, null.</returns>
		[JsMethod(Name = "getFriendlyName")]
		public string GetFriendlyName(object obj) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Retrieve the list of objects which have registered, via {@link
		/// #addObject} as being members of the specified group.</para>
		/// </summary>
		/// <param name="groupName">The name of the group for which the member list is desired.</param>
		/// <returns>An array containing the friendly names of any objects which are members of the specified group.  The resultant array may be empty.</returns>
		[JsMethod(Name = "getGroupObjects")]
		public JsArray GetGroupObjects(string groupName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property maxSavedStates.</para>
		/// </summary>
		[JsMethod(Name = "getMaxSavedStates")]
		public double GetMaxSavedStates() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property name.</para>
		/// </summary>
		[JsMethod(Name = "getName")]
		public string GetName() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property nextState.</para>
		/// </summary>
		[JsMethod(Name = "getNextState")]
		public string GetNextState() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Retrieve an object previously saved via <see cref="AddObject"/>, using its
		/// Friendly Name.</para>
		/// </summary>
		/// <param name="friendlyName">The friendly name of the object to be retrieved.</param>
		/// <returns>The object which has the specified friendly name, or undefined if no object has been associated with that name.</returns>
		[JsMethod(Name = "getObject")]
		public object GetObject(string friendlyName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property previousState.</para>
		/// </summary>
		[JsMethod(Name = "getPreviousState")]
		public string GetPreviousState() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property state.</para>
		/// </summary>
		[JsMethod(Name = "getState")]
		public string GetState() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property debugFlags
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property debugFlags.</param>
		[JsMethod(Name = "initDebugFlags")]
		public void InitDebugFlags(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property maxSavedStates
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property maxSavedStates.</param>
		[JsMethod(Name = "initMaxSavedStates")]
		public void InitMaxSavedStates(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property name
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property name.</param>
		[JsMethod(Name = "initName")]
		public void InitName(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property nextState
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property nextState.</param>
		[JsMethod(Name = "initNextState")]
		public void InitNextState(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property previousState
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property previousState.</param>
		[JsMethod(Name = "initPreviousState")]
		public void InitPreviousState(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property state
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property state.</param>
		[JsMethod(Name = "initState")]
		public void InitState(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Pop the saved state stack.</para>
		/// </summary>
		/// <returns>The name of a state or a boolean flag that had most recently been pushed onto the saved-state stack.</returns>
		[JsMethod(Name = "popState")]
		public object PopState() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add the specified event to a list of events to be passed to the next
		/// state following state transition.</para>
		/// </summary>
		/// <param name="eventx">The event to add to the event queue for processing after state change.</param>
		[JsMethod(Name = "postponeEvent")]
		public void PostponeEvent(qx.eventx.type.Event eventx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Save the current or previous state on the saved-state stack.  A future
		/// transition can then provide, as its nextState value, the class
		/// constant:</para>
		/// 
		/// qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK
		/// 
		/// <para>which will cause the next state to be whatever is at the top of the
		/// saved-state stack, and remove that top element from the saved-state
		/// stack.</para>
		/// </summary>
		/// <param name="state">When true, then push the current state onto the stack.  This might be used in a transition, before the state has changed.  When false, then push the previous state onto the stack.  This might be used in an on entry function to save the previous state to return to.  If this parameter is a string, it is taken to be the name of the state to transition to.</param>
		[JsMethod(Name = "pushState")]
		public void PushState(object state) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove an object which had previously been added by <see cref="AddObject"/>.</para>
		/// </summary>
		/// <param name="friendlyName">The friendly name associated with an object, specifying which object is to be removed.</param>
		[JsMethod(Name = "removeObject")]
		public void RemoveObject(string friendlyName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replace a state in the finite state machine.  This is useful if
		/// initially &#8220;dummy&#8221; states are created which load the real state table
		/// for a series of operations (and possibly also load the gui associated
		/// with the new states at the same time).  Having portions of the finite
		/// state machine and their associated gui pages loaded at run time can
		/// help prevent long delays at application start-up time.</para>
		/// </summary>
		/// <param name="state">An object of class qx.util.fsm.State representing a state which is to be a part of this finite state machine.</param>
		/// <param name="bDispose">If true, then dispose the old state object.  If false, the old state object is returned for disposing by the caller.</param>
		/// <returns>The old state object if it was not disposed; otherwise null.</returns>
		[JsMethod(Name = "replaceState")]
		public object ReplaceState(qx.util.fsm.State state, bool bDispose) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property debugFlags.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetDebugFlags")]
		public void ResetDebugFlags() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property maxSavedStates.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetMaxSavedStates")]
		public void ResetMaxSavedStates() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property name.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetName")]
		public void ResetName() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property nextState.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetNextState")]
		public void ResetNextState() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property previousState.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetPreviousState")]
		public void ResetPreviousState() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property state.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetState")]
		public void ResetState() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Create and schedule an event to be sent to the finite state machine
		/// &#8220;shortly&#8221;.  This allows such things as letting a progress cursor
		/// display prior to handling the event.</para>
		/// </summary>
		/// <param name="type">The type of event, e.g. &#8220;execute&#8221;</param>
		/// <param name="target">The target of the event</param>
		/// <param name="data">See #fireImmediateEvent for details.</param>
		/// <param name="timeout">If provided, this is the number of milliseconds to wait before firing the event.  If not provided, a default short interval (on the order of 20 milliseconds) is used.</param>
		[JsMethod(Name = "scheduleEvent")]
		public void ScheduleEvent(string type, qx.core.Object target, object data, double timeout) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property debugFlags.</para>
		/// </summary>
		/// <param name="value">New value for property debugFlags.</param>
		[JsMethod(Name = "setDebugFlags")]
		public void SetDebugFlags(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property maxSavedStates.</para>
		/// </summary>
		/// <param name="value">New value for property maxSavedStates.</param>
		[JsMethod(Name = "setMaxSavedStates")]
		public void SetMaxSavedStates(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property name.</para>
		/// </summary>
		/// <param name="value">New value for property name.</param>
		[JsMethod(Name = "setName")]
		public void SetName(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property nextState.</para>
		/// </summary>
		/// <param name="value">New value for property nextState.</param>
		[JsMethod(Name = "setNextState")]
		public void SetNextState(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property previousState.</para>
		/// </summary>
		/// <param name="value">New value for property previousState.</param>
		[JsMethod(Name = "setPreviousState")]
		public void SetPreviousState(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property state.</para>
		/// </summary>
		/// <param name="value">New value for property state.</param>
		[JsMethod(Name = "setState")]
		public void SetState(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Start (or restart, after it has terminated) the finite state machine
		/// from the starting state.  The starting state is defined as the first
		/// state added to the finite state machine.</para>
		/// </summary>
		[JsMethod(Name = "start")]
		public void Start() { throw new NotImplementedException(); }

		#endregion Methods
    }
}