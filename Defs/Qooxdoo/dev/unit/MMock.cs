// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.dev.unit
{
    /// <summary>
	/// <para>Provides test spies, stubs and mocks as well as custom assertions.</para>
	/// <para>Here is a simple example:</para>
	/// <code>
	/// // Test
	/// qx&#046;Class.define("qx.test.Klass",
	/// {
	/// extend : qx.dev.unit.TestCase,
	/// include : qx.dev.unit.MMock,
	/// members :
	/// {
	/// "test: doSpecial on condition xyz": function() {
	/// // Set-Up
	/// var obj = new qx.Klass();
	/// // Wraps obj.doSpecial in a spy function and
	/// // replaces the original method with this spy.
	/// this.spy(obj, "doSpecial");
	/// // Run code that is expected to fulfill condition
	/// obj.onCondition("xyz");
	/// // Assert that spy was called
	/// this.assertCalled(obj.doSpecial);
	/// },
	/// tearDown: function() {
	/// // Restore all stubs, spies and overridden host objects.
	/// //
	/// // It is a good idea to always run this in the tearDown()
	/// // method, especially when overwriting global or host objects.
	/// this.getSandbox().restore();
	/// }
	/// }
	/// });
	/// // Implementation
	/// qx&#046;Class.define("qx.Klass",
	/// {
	/// extend : qx.core.Object,
	/// members :
	/// {
	/// onCondition: function(condition) {
	/// // Complex code determining mustDoSpecial
	/// // by examining condition passed
	/// if (mustDoSpecial) {
	/// this.doSpecial();
	/// }
	/// },
	/// doSpecial: function() {
	/// }
	/// }
	/// });
	/// </code>
	/// <para>This mixin provides assertions such as assertCalled() that work
	/// with spies and stubs. Besides offering a compact way to express expectations,
	/// those assertions have the advantage that meaningful error messages can be
	/// generated.</para>
	/// <para>For full list of assertions see http://sinonjs.org/docs/#assertions.
	/// Note that sinon.assert.xyz() translates as assertXyz().</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.dev.unit.MMock", OmitOptionalParameters = true, Export = false)]
    public partial class MMock 
    {
		#region Methods

		public MMock() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>EXPERIMENTAL &#8211; NOT READY FOR PRODUCTION</para>
		/// <para>Returns a deep copied, API-identical stubbed out clone of the given
		/// object.</para>
		/// <para>In contrast to the shallow <see cref="Stub"/>, also stubs out properties that
		/// belong to the prototype chain.</para>
		/// </summary>
		/// <param name="objectx">Object to stub deeply.</param>
		/// <returns>A stub.</returns>
		[JsMethod(Name = "deepStub")]
		public object DeepStub(object objectx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get requests made with faked XHR or server.</para>
		/// <para>Each request can be queried for url, method, requestHeaders,
		/// status and more.</para>
		/// <para>See http://sinonjs.org/docs/#FakeXMLHttpRequest.</para>
		/// </summary>
		/// <returns>Array of faked requests.</returns>
		[JsMethod(Name = "getRequests")]
		public JsArray GetRequests() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get sandbox.</para>
		/// <para>The sandbox holds all stubs and mocks. Run this.getSandbox().restore()
		/// to restore all mock objects.</para>
		/// </summary>
		/// <returns>Sandbox object.</returns>
		[JsMethod(Name = "getSandbox")]
		public object GetSandbox() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get fake server created by <see cref="UseFakeServer"/>.</para>
		/// </summary>
		/// <returns>Fake server.</returns>
		[JsMethod(Name = "getServer")]
		public object GetServer() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>EXPERIMENTAL &#8211; NOT READY FOR PRODUCTION</para>
		/// <para>Changes the given factory (e.g. a constructor) to return a stub. The
		/// method itself returns this stub.</para>
		/// <para>By default, the stub returned by the changed factory is the object built
		/// by the original factory, but deeply stubbed (see <see cref="DeepStub"/>).
		/// Alternatively, a custom stub may be given explicitly that is used instead.</para>
		/// </summary>
		/// <param name="objectx">Namespace to hold factory, e.g. qx.html.</param>
		/// <param name="property">Property as string that functions as constructor, e.g. &#8220;Element&#8221;.</param>
		/// <param name="customStub">Stub to inject.</param>
		/// <returns>Injected stub.</returns>
		[JsMethod(Name = "injectStub")]
		public object InjectStub(object objectx, string property, object customStub) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Mocks are slightly different from spies and stubs in that you mock an
		/// object, and then set an expectation on one or more of its objects.</para>
		/// <list type="bullet">
		/// <item>var mock = mock(obj)
		/// Creates a mock for the provided object. Does not change the object, but
		/// returns a mock object to set expectations on the object&#8217;s methods.</item>
		/// </list
		/// <list type="bullet">
		/// <item>var expectation = mock.expects(&#8220;method&#8221;)
		/// Overrides obj.method with a mock function and returns an expectation
		/// object. Expectations implement both the spy and stub interface plus
		/// the methods described below.</item>
		/// </list
		/// <para>Set expectations with following methods. All methods return the expectation
		/// itself, meaning expectations can be chained.</para>
		/// <list type="bullet">
		/// <item>expectation.atLeast(number);</item>
		/// <item>expectation.atMost(number);</item>
		/// <item>expectation.never();</item>
		/// <item>expectation.once();</item>
		/// <item>expectation.twice();</item>
		/// <item>expectation.thrice();</item>
		/// <item>expectation.exactly(number);</item>
		/// <item>expectation.withArgs(arg1, arg2, ...);</item>
		/// <item>expectation.withExactArgs(arg1, arg2, ...);</item>
		/// <item>expectation.on(obj);</item>
		/// <item>expecation.verify();</item>
		/// </list
		/// <para>See http://sinonjs.org/docs/#mocks.</para>
		/// </summary>
		/// <param name="objectx">The object to create a mock of.</param>
		/// <returns>A mock to set expectations on. See http://sinonjs.org/docs/#mocks.</returns>
		[JsMethod(Name = "mock")]
		public Action<object> Mock(object objectx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Changes the given factory (e.g. a constructor) to make a mock of the
		/// object returned. The method itself returns this mock.</para>
		/// <para>By default, the object returned by the changed factory (that a mock is
		/// made of) is a deep copied, API-identical clone of the object built by the
		/// original factory. Alternatively, the object returned can be given
		/// explicitly.</para>
		/// </summary>
		/// <param name="objectx">Namespace to hold factory, e.g. qx.html.</param>
		/// <param name="property">Property as string that functions as constructor, e.g. &#8220;Element&#8221;.</param>
		/// <param name="customObject">Object to inject.</param>
		/// <returns>Mock of the object built.</returns>
		[JsMethod(Name = "revealMock")]
		public object RevealMock(object objectx, string property, object customObject) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>EXPERIMENTAL &#8211; NOT READY FOR PRODUCTION</para>
		/// <para>Shallowly stub methods that belong to classes found in inheritance
		/// chain up to (but including) the given class.</para>
		/// </summary>
		/// <param name="objectx">Object to stub shallowly.</param>
		/// <param name="targetClazz">Class which marks the end of the chain.</param>
		/// <returns>A stub.</returns>
		[JsMethod(Name = "shallowStub")]
		public object ShallowStub(object objectx, object targetClazz) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Test spies allow introspection on how a function is used
		/// throughout the system under test.</para>
		/// <list type="bullet">
		/// <item>spy()
		/// Creates an anonymous function that records arguments,
		/// this value, exceptions and return values for all calls.</item>
		/// </list
		/// <list type="bullet">
		/// <item>spy(func)
		/// Spies on the provided function</item>
		/// </list
		/// <list type="bullet">
		/// <item>spy(object, &#8220;method&#8221;)
		/// Creates a spy for object.method and replaces the original method
		/// with the spy. The spy acts exactly like the original method in all cases.
		/// The original method can be restored by calling object.method.restore().
		/// The returned spy is the function object which replaced the original method.
		/// spy === object.method.</item>
		/// </list
		/// <list type="bullet">
		/// <item>spy.withArgs(arg1[, arg2, ...])
		/// Creates a spy that only records calls when the received arguments matches those
		/// passed to withArgs.</item>
		/// </list
		/// <para>A spy has a rich interface to introspect how the wrapped function was used:</para>
		/// <list type="bullet">
		/// <item>spy.callCount</item>
		/// <item>spy.called</item>
		/// <item>spy.calledOnce</item>
		/// <item>spy.calledTwice</item>
		/// <item>spy.calledThrice</item>
		/// <item>spy.calledBefore(anotherSpy)</item>
		/// <item>spy.calledAfter(anotherSpy)</item>
		/// <item>spy.calledOn(obj)</item>
		/// <item>spy.alwaysCalledOn(obj)</item>
		/// <item>spy.calledWith(arg1, arg2, ...)</item>
		/// <item>spy.alwaysCalledWith(arg1, arg2, ...)</item>
		/// <item>spy.calledWithExactly(arg1, arg2, ...)</item>
		/// <item>spy.alwaysCalledWithExactly(arg1, arg2, ...)</item>
		/// <item>spy.threw()</item>
		/// <item>spy.threw(&#8220;TypeError&#8221;)</item>
		/// <item>spy.threw(obj)</item>
		/// <item>spy.alwaysThrew()</item>
		/// <item>spy.alwaysThrew(&#8220;TypeError&#8221;)</item>
		/// <item>spy.alwaysThrew(obj)</item>
		/// <item>spy.returned(obj)</item>
		/// <item>spy.alwaysReturned(obj)</item>
		/// <item>spy.getCall(n)</item>
		/// <item>spy.thisValues</item>
		/// <item>spy.args</item>
		/// <item>spy.exceptions</item>
		/// <item>spy.returnValues</item>
		/// </list
		/// <para>See http://sinonjs.org/docs/#spies.</para>
		/// <para>Note: Spies are transparently added to a sandbox. To restore
		/// the original function for all spies run this.getSandbox().restore()
		/// in your tearDown() method.</para>
		/// </summary>
		/// <param name="function_or_object">Spies on the provided function or object.</param>
		/// <param name="method">The method to spy upon if an object was given.</param>
		/// <returns>The wrapped function enhanced with properties and methods that allow for introspection. See http://sinonjs.org/docs/#spies.</returns>
		[JsMethod(Name = "spy")]
		public Action<object> Spy(object function_or_object, string method = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Test stubs are functions (spies) with pre-programmed behavior.</para>
		/// <list type="bullet">
		/// <item>stub()
		/// Creates an anonymous stub function</item>
		/// </list
		/// <list type="bullet">
		/// <item>stub(object, &#8220;method&#8221;)
		/// Replaces object.method with a stub function. The original function
		/// can be restored by calling object.method.restore() (or stub.restore()).
		/// An exception is thrown if the property is not already a function,
		/// to help avoid typos when stubbing methods.</item>
		/// </list
		/// <list type="bullet">
		/// <item>stub(obj)
		/// Stubs all the object&#8217;s methods.</item>
		/// </list
		/// <list type="bullet">
		/// <item>stub.withArgs(arg1[, arg2, ...])
		/// Stubs the method only for the provided arguments. Can be used to create
		/// a stub that acts differently in response to different arguments.</item>
		/// </list
		/// <para>A stub has the interface of a spy in addition to methods that allow to define behaviour:</para>
		/// <list type="bullet">
		/// <item>stub.returns(obj)</item>
		/// <item>stub.throws()</item>
		/// <item>stub.throws(&#8220;TypeError&#8221;)</item>
		/// <item>stub.throws(obj)</item>
		/// <item>stub.callsArg(index)</item>
		/// <item>stub.callsArg(0)</item>
		/// <item>stub.callsArgWith(index, arg1, arg2, ...)</item>
		/// </list
		/// <para>See http://sinonjs.org/docs/#stubs.</para>
		/// <para>Note: Stubs are transparently added to a sandbox. To restore
		/// the original function for all stubs run this.getSandbox().restore()
		/// in your tearDown() method.</para>
		/// </summary>
		/// <param name="objectx">Object to stub. Creates an anonymous stub function if not given.</param>
		/// <param name="method">Replaces object.method with a stub function. An exception is thrown if the property is not already a function, to help avoid typos when stubbing methods.</param>
		/// <returns>A stub. Has the interface of a spy in addition to methods that allow to define behaviour. See http://sinonjs.org/docs/#stubs.</returns>
		[JsMethod(Name = "stub")]
		public Action<object> Stub(object objectx = null, string method = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>As <see cref="UseFakeXMLHttpRequest"/>, but additionally provides a high-level
		/// API to setup server responses. To setup responses, use the server
		/// returned by <see cref="GetServer"/>.</para>
		/// <para>See http://sinonjs.org/docs/#server.</para>
		/// <para>Note: The fake server is transparently added to a sandbox. To restore
		/// the original host method run this.getSandbox().restore()
		/// in your tearDown() method.</para>
		/// </summary>
		/// <returns></returns>
		[JsMethod(Name = "useFakeServer")]
		public object UseFakeServer() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replace the native XMLHttpRequest object in browsers that support it with
		/// a custom implementation which does not send actual requests.</para>
		/// <para>Note: The fake XHR is transparently added to a sandbox. To restore
		/// the original host method run this.getSandbox().restore()
		/// in your tearDown() method.</para>
		/// <para>See http://sinonjs.org/docs/#useFakeXMLHttpRequest.</para>
		/// </summary>
		/// <returns></returns>
		[JsMethod(Name = "useFakeXMLHttpRequest")]
		public object UseFakeXMLHttpRequest() { throw new NotImplementedException(); }

		#endregion Methods
    }
}