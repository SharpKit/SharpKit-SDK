// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.dom
{
    /// <summary>
	/// <para>Manages children structures of an element. Easy and convenient APIs
	/// to insert, remove and replace children.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.dom.Element", OmitOptionalParameters = true, Export = false)]
    public partial class Element 
    {
		#region Methods

		public Element() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Creates a DOM element.</para>
		/// <para>Attributes may be given directly with this call. This is critical
		/// for some attributes e.g. name, type, ... in many clients.</para>
		/// <para>Depending on the kind of attributes passed, innerHTML may be
		/// used internally to assemble the element. Please make sure you understand
		/// the security implications. See <see cref="qx.bom.Html.Clean"/>.</para>
		/// </summary>
		/// <param name="name">Tag name of the element</param>
		/// <param name="attributes">Map of attributes to apply</param>
		/// <param name="win">Window to create the element for</param>
		/// <returns>The created element node</returns>
		[JsMethod(Name = "create")]
		public static qx.html.Element Create(string name, object attributes, Window win) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all content from the given element</para>
		/// </summary>
		/// <param name="element">element to clean</param>
		/// <returns>empty string (new HTML content)</returns>
		[JsMethod(Name = "empty")]
		public static string Empty(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Creates and returns a DOM helper element.</para>
		/// </summary>
		/// <param name="win">Window to create the element for</param>
		/// <returns>The created element node</returns>
		[JsMethod(Name = "getHelperElement")]
		public static qx.html.Element GetHelperElement(Window win) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the parent element of the given element.</para>
		/// </summary>
		/// <param name="element">Element to find the parent for</param>
		/// <returns>The parent element</returns>
		[JsMethod(Name = "getParentElement")]
		public static qx.html.Element GetParentElement(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the given child is a child of parent</para>
		/// </summary>
		/// <param name="parent">parent element</param>
		/// <param name="child">child node</param>
		/// <returns>true when the given child is a child of parent</returns>
		[JsMethod(Name = "hasChild")]
		public static bool HasChild(qx.html.Element parent, Node child) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the given element has any child elements.</para>
		/// </summary>
		/// <param name="element">element to test</param>
		/// <returns>true when the given element has at least one child element</returns>
		[JsMethod(Name = "hasChildElements")]
		public static bool HasChildElements(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the given element has children.</para>
		/// </summary>
		/// <param name="element">element to test</param>
		/// <returns>true when the given element has at least one child node</returns>
		[JsMethod(Name = "hasChildren")]
		public static bool HasChildren(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts node after ref in the same parent.</para>
		/// </summary>
		/// <param name="node">Node to insert</param>
		/// <param name="refx">Node which will be used as reference for insertion</param>
		/// <returns>returns true (successful)</returns>
		[JsMethod(Name = "insertAfter")]
		public static bool InsertAfter(Node node, Node refx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts node at the given index
		/// inside parent.</para>
		/// </summary>
		/// <param name="node">node to insert</param>
		/// <param name="parent">parent element node</param>
		/// <param name="index">where to insert</param>
		/// <returns>returns true (successful)</returns>
		[JsMethod(Name = "insertAt")]
		public static bool InsertAt(Node node, qx.html.Element parent, double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts node before ref in the same parent.</para>
		/// </summary>
		/// <param name="node">Node to insert</param>
		/// <param name="refx">Node which will be used as reference for insertion</param>
		/// <returns>returns true (successful)</returns>
		[JsMethod(Name = "insertBefore")]
		public static bool InsertBefore(Node node, Node refx) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert node into parent as first child.
		/// Indexes of other children will be incremented by one.</para>
		/// </summary>
		/// <param name="node">Node to insert</param>
		/// <param name="parent">parent element node</param>
		/// <returns>returns true (successful)</returns>
		[JsMethod(Name = "insertBegin")]
		public static bool InsertBegin(Node node, qx.html.Element parent) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert node into parent as last child.</para>
		/// </summary>
		/// <param name="node">Node to insert</param>
		/// <param name="parent">parent element node</param>
		/// <returns>returns true (successful)</returns>
		[JsMethod(Name = "insertEnd")]
		public static bool InsertEnd(Node node, qx.html.Element parent) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Checks if the element is in the DOM, but note that
		/// the method is very expensive!</para>
		/// </summary>
		/// <param name="element">The DOM element to check.</param>
		/// <param name="win">The window to check for.</param>
		/// <returns>true if the element is in the DOM, false otherwise.</returns>
		[JsMethod(Name = "isInDom")]
		public static bool IsInDom(qx.html.Element element, Window win) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the given node from its parent element.</para>
		/// </summary>
		/// <param name="node">Node to remove</param>
		/// <returns>true when node was successfully removed, otherwise false</returns>
		[JsMethod(Name = "remove")]
		public static bool Remove(Node node) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the given node from the parent.</para>
		/// </summary>
		/// <param name="node">Node to remove</param>
		/// <param name="parent">parent element which contains the node</param>
		/// <returns>true when node was successfully removed, otherwise false</returns>
		[JsMethod(Name = "removeChild")]
		public static bool RemoveChild(Node node, qx.html.Element parent) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the node at the given index
		/// from the parent.</para>
		/// </summary>
		/// <param name="index">position of the node which should be removed</param>
		/// <param name="parent">parent DOM element</param>
		/// <returns>true when node was successfully removed, otherwise false</returns>
		[JsMethod(Name = "removeChildAt")]
		public static bool RemoveChildAt(double index, qx.html.Element parent) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replaces the node at index with newNode in
		/// the given parent.</para>
		/// </summary>
		/// <param name="newNode">DOM node to insert</param>
		/// <param name="index">position of old DOM node</param>
		/// <param name="parent">parent DOM element</param>
		/// <returns>true when node was successfully replaced</returns>
		[JsMethod(Name = "replaceAt")]
		public static bool ReplaceAt(Node newNode, double index, qx.html.Element parent) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replaces oldNode with newNode in the current
		/// parent of oldNode.</para>
		/// </summary>
		/// <param name="newNode">DOM node to insert</param>
		/// <param name="oldNode">DOM node to remove</param>
		/// <returns>true when node was successfully replaced</returns>
		[JsMethod(Name = "replaceChild")]
		public static bool ReplaceChild(Node newNode, Node oldNode) { throw new NotImplementedException(); }

		#endregion Methods
    }
}