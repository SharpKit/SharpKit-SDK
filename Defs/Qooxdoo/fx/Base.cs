// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.fx
{
    /// <summary>
	/// <para>Basic class for all core and combination effects.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.fx.Base", OmitOptionalParameters = true, Export = false)]
    public partial class Base : qx.core.Object
    {
		#region Events

		/// <summary>
		/// <para>This event is fired when effect ends.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnFinish;

		/// <summary>
		/// <para>This event is fired when effect starts.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnSetup;

		/// <summary>
		/// <para>This event is fired every time a frame is rendered.</para>
		/// </summary>
		public event Action<qx.eventx.type.Event> OnUpdate;

		#endregion Events

		#region Properties

		/// <summary>
		/// <para>Number of seconds the effect should wait before start.</para>
		/// </summary>
		[JsProperty(Name = "delay", NativeField = true)]
		public double Delay { get; set; }

		/// <summary>
		/// <para>Number of seconds the effect should run.</para>
		/// </summary>
		[JsProperty(Name = "duration", NativeField = true)]
		public double Duration { get; set; }

		/// <summary>
		/// <para>Number frames per seconds the effect should be rendered with.</para>
		/// </summary>
		[JsProperty(Name = "fps", NativeField = true)]
		public double Fps { get; set; }

		/// <summary>
		/// <para>Initial value of effect-specific property (color, opacity, position, etc.).</para>
		/// </summary>
		[JsProperty(Name = "from", NativeField = true)]
		public double From { get; set; }

		/// <summary>
		/// <para>Name of queue the effect should run in.</para>
		/// </summary>
		[JsProperty(Name = "queue", NativeField = true)]
		public object Queue { get; set; }

		/// <summary>
		/// <para>Flag indicating if effect should run parallel with others.</para>
		/// </summary>
		[JsProperty(Name = "sync", NativeField = true)]
		public bool Sync { get; set; }

		/// <summary>
		/// <para>End value of effect-specific property. When this value is reached, the effect will end.</para>
		/// </summary>
		[JsProperty(Name = "to", NativeField = true)]
		public double To { get; set; }

		/// <summary>
		/// <para>Function which modifies the effect-specific property during the transition
		/// between &#8220;from&#8221; and &#8220;to&#8221; value.</para>
		/// </summary>
		/// <remarks>
		/// Possible values: "linear","easeInQuad","easeOutQuad","sinodial","reverse","flicker","wobble","pulse","spring","none","full"
		/// </remarks>
		[JsProperty(Name = "transition", NativeField = true)]
		public object Transition { get; set; }

		#endregion Properties

		#region Methods

		public Base() { throw new NotImplementedException(); }

		/// <param name="element">The DOM element</param>
		public Base(object element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called after
		/// the effect actually has ended.</para>
		/// </summary>
		[JsMethod(Name = "afterFinish")]
		public void AfterFinish() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// &#8220;afterFinished&#8221; and after the effect
		/// actually has ended.</para>
		/// </summary>
		[JsMethod(Name = "afterFinishInternal")]
		public void AfterFinishInternal() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called after
		/// the effect&#8217;s &#8220;setup&#8221; method has been called.</para>
		/// </summary>
		[JsMethod(Name = "afterSetup")]
		public void AfterSetup() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// &#8220;afterSetup&#8221; and after the effect&#8217;s
		/// &#8220;setup&#8221; method has been called.</para>
		/// </summary>
		[JsMethod(Name = "afterSetupInternal")]
		public void AfterSetupInternal() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called
		/// each time after the effect&#8217;s &#8220;update&#8221; method is called.</para>
		/// </summary>
		[JsMethod(Name = "afterUpdate")]
		public void AfterUpdate() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// &#8220;afterUpdate&#8221; and each time after
		/// the effect&#8217;s &#8220;update&#8221; method is called.</para>
		/// </summary>
		[JsMethod(Name = "afterUpdateInternal")]
		public void AfterUpdateInternal() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// the effect actually ends.</para>
		/// </summary>
		[JsMethod(Name = "beforeFinish")]
		public void BeforeFinish() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// &#8220;beforeFinished&#8221; and before the effect
		/// actually ends.</para>
		/// </summary>
		[JsMethod(Name = "beforeFinishInternal")]
		public void BeforeFinishInternal() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// the effect&#8217;s &#8220;setup&#8221; method gets called.</para>
		/// </summary>
		[JsMethod(Name = "beforeSetup")]
		public void BeforeSetup() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// &#8220;beforeSetup&#8221; and before the effect&#8217;s
		/// &#8220;setup&#8221; method gets called.</para>
		/// </summary>
		[JsMethod(Name = "beforeSetupInternal")]
		public void BeforeSetupInternal() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called
		/// before the effect actually starts.</para>
		/// </summary>
		[JsMethod(Name = "beforeStart")]
		public void BeforeStart() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// &#8220;beforeStartInternal&#8221; and before the effect
		/// actually starts.</para>
		/// </summary>
		[JsMethod(Name = "beforeStartInternal")]
		public void BeforeStartInternal() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is each time before
		/// the effect&#8217;s &#8220;update&#8221; method is called.</para>
		/// </summary>
		[JsMethod(Name = "beforeUpdate")]
		public void BeforeUpdate() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called before
		/// &#8220;beforeUpdateInternal&#8221; and each time before
		/// the effect&#8217;s &#8220;update&#8221; method is called.</para>
		/// </summary>
		[JsMethod(Name = "beforeUpdateInternal")]
		public void BeforeUpdateInternal() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes effect from queue and sets state to finished.</para>
		/// </summary>
		[JsMethod(Name = "cancel")]
		public void Cancel() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Ends the effect</para>
		/// </summary>
		[JsMethod(Name = "end")]
		public void End() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called
		/// when the effect has finished.</para>
		/// <para>Fires &#8220;finish&#8221; event.</para>
		/// </summary>
		[JsMethod(Name = "finish")]
		public void Finish() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property delay.</para>
		/// </summary>
		[JsMethod(Name = "getDelay")]
		public double GetDelay() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property duration.</para>
		/// </summary>
		[JsMethod(Name = "getDuration")]
		public double GetDuration() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property fps.</para>
		/// </summary>
		[JsMethod(Name = "getFps")]
		public double GetFps() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property from.</para>
		/// </summary>
		[JsMethod(Name = "getFrom")]
		public double GetFrom() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property queue.</para>
		/// </summary>
		[JsMethod(Name = "getQueue")]
		public object GetQueue() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property sync.</para>
		/// </summary>
		[JsMethod(Name = "getSync")]
		public bool GetSync() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property to.</para>
		/// </summary>
		[JsMethod(Name = "getTo")]
		public double GetTo() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the (computed) value of the property transition.</para>
		/// </summary>
		[JsMethod(Name = "getTransition")]
		public object GetTransition() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is used to update
		/// properties before the effect starts.</para>
		/// </summary>
		[JsMethod(Name = "init")]
		public void Init() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property delay
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property delay.</param>
		[JsMethod(Name = "initDelay")]
		public void InitDelay(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property duration
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property duration.</param>
		[JsMethod(Name = "initDuration")]
		public void InitDuration(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property fps
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property fps.</param>
		[JsMethod(Name = "initFps")]
		public void InitFps(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property from
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property from.</param>
		[JsMethod(Name = "initFrom")]
		public void InitFrom(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property queue
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property queue.</param>
		[JsMethod(Name = "initQueue")]
		public void InitQueue(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property sync
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property sync.</param>
		[JsMethod(Name = "initSync")]
		public void InitSync(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property to
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property to.</param>
		[JsMethod(Name = "initTo")]
		public void InitTo(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls the apply method and dispatches the change event of the property transition
		/// with the default value defined by the class developer. This function can
		/// only be called from the constructor of a class.</para>
		/// </summary>
		/// <param name="value">Initial value for property transition.</param>
		[JsMethod(Name = "initTransition")]
		public void InitTransition(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns whether the effect is active</para>
		/// </summary>
		/// <returns>Whether the effect is active.</returns>
		[JsMethod(Name = "isActive")]
		public bool IsActive() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether the (computed) value of the boolean property sync equals true.</para>
		/// </summary>
		[JsMethod(Name = "isSync")]
		public void IsSync() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Invokes update() if effect&#8217;s remaining duration is
		/// bigger than zero, or ends the effect otherwise.</para>
		/// </summary>
		/// <param name="timePos">Effect&#8217;s step on duration between 0 (just started) and 1 (finished). The longer the duration is, the lower is each step.</param>
		[JsMethod(Name = "loop")]
		public void Loop(double timePos) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Calls update(), or invokes the effect, if not running.</para>
		/// </summary>
		/// <param name="pos">Effect&#8217;s step on duration between 0 (just started) and 1 (finished). The longer the duration is, the lower is each step.  Fires &#8220;update&#8221; event.</param>
		[JsMethod(Name = "render")]
		public void Render(double pos) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property delay.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetDelay")]
		public void ResetDelay() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property duration.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetDuration")]
		public void ResetDuration() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property fps.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetFps")]
		public void ResetFps() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property from.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetFrom")]
		public void ResetFrom() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property queue.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetQueue")]
		public void ResetQueue() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the state to default.</para>
		/// </summary>
		[JsMethod(Name = "resetState")]
		public void ResetState() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property sync.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetSync")]
		public void ResetSync() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property to.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetTo")]
		public void ResetTo() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Resets the user value of the property transition.</para>
		/// <para>The computed value falls back to the next available value e.g. appearance, init or
		/// inheritance value depeneding on the property configuration and value availability.</para>
		/// </summary>
		[JsMethod(Name = "resetTransition")]
		public void ResetTransition() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property delay.</para>
		/// </summary>
		/// <param name="value">New value for property delay.</param>
		[JsMethod(Name = "setDelay")]
		public void SetDelay(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property duration.</para>
		/// </summary>
		/// <param name="value">New value for property duration.</param>
		[JsMethod(Name = "setDuration")]
		public void SetDuration(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property fps.</para>
		/// </summary>
		/// <param name="value">New value for property fps.</param>
		[JsMethod(Name = "setFps")]
		public void SetFps(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property from.</para>
		/// </summary>
		/// <param name="value">New value for property from.</param>
		[JsMethod(Name = "setFrom")]
		public void SetFrom(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property queue.</para>
		/// </summary>
		/// <param name="value">New value for property queue.</param>
		[JsMethod(Name = "setQueue")]
		public void SetQueue(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property sync.</para>
		/// </summary>
		/// <param name="value">New value for property sync.</param>
		[JsMethod(Name = "setSync")]
		public void SetSync(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property to.</para>
		/// </summary>
		/// <param name="value">New value for property to.</param>
		[JsMethod(Name = "setTo")]
		public void SetTo(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the user value of the property transition.</para>
		/// </summary>
		/// <param name="value">New value for property transition.</param>
		[JsMethod(Name = "setTransition")]
		public void SetTransition(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called
		/// before the effect starts to configure
		/// the element or prepare other effects.</para>
		/// <para>Fires &#8220;setup&#8221; event.</para>
		/// </summary>
		[JsMethod(Name = "setup")]
		public void Setup() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Starts the effect</para>
		/// </summary>
		/// <returns>true if the effect was successfully started</returns>
		[JsMethod(Name = "start")]
		public bool Start() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles the (computed) value of the boolean property sync.</para>
		/// </summary>
		[JsMethod(Name = "toggleSync")]
		public void ToggleSync() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This internal function is called
		/// each time the effect performs an
		/// step of the animation.</para>
		/// <para>Sub classes will overwrite this to
		/// perform the actual changes on element
		/// properties.</para>
		/// </summary>
		/// <param name="position">Animation setup as Number between 0 and 1.</param>
		[JsMethod(Name = "update")]
		public void Update(double position) { throw new NotImplementedException(); }

		#endregion Methods
    }
}