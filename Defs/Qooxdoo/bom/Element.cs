// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.bom
{
    /// <summary>
	/// <para>This class is mainly a convenience wrapper for DOM elements to
	/// qooxdoo&#8217;s event system.</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.bom.Element", OmitOptionalParameters = true, Export = false)]
    public partial class Element 
    {
		#region Methods

		public Element() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Activates the given element. The active element receives all key board events.</para>
		/// </summary>
		/// <param name="element">DOM element to focus</param>
		[JsMethod(Name = "activate")]
		public static void Activate(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add an event listener to a DOM element. The event listener is passed an
		/// instance of <see cref="Event"/> containing all relevant information
		/// about the event as parameter.</para>
		/// </summary>
		/// <param name="element">DOM element to attach the event on.</param>
		/// <param name="type">Name of the event e.g. &#8220;click&#8221;, &#8220;keydown&#8221;, ...</param>
		/// <param name="listener">Event listener function</param>
		/// <param name="self">Reference to the &#8216;this&#8217; variable inside the event listener. When not given, the corresponding dispatcher usually falls back to a default, which is the target by convention. Note this is not a strict requirement, i.e. custom dispatchers can follow a different strategy.</param>
		/// <param name="capture">Whether to attach the event to the capturing phase or the bubbling phase of the event. The default is to attach the event handler to the bubbling phase.</param>
		/// <returns>An opaque id, which can be used to remove the event listener using the #removeListenerById method.</returns>
		[JsMethod(Name = "addListener")]
		public static string AddListener(qx.html.Element element, string type, Action<qx.eventx.type.Data> listener, object self = null, bool? capture = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Blurs the given element</para>
		/// </summary>
		/// <param name="element">DOM element to blur</param>
		[JsMethod(Name = "blur")]
		public static void Blur(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Captures the given element</para>
		/// </summary>
		/// <param name="element">DOM element to capture</param>
		/// <param name="containerCapture">If true all events originating in the container are captured. If false events originating in the container are not captured.</param>
		[JsMethod(Name = "capture")]
		public static void Capture(qx.html.Element element, bool containerCapture = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Clone given DOM element. May optionally clone all attached
		/// events (recursively) as well.</para>
		/// </summary>
		/// <param name="element">Element to clone</param>
		/// <param name="events">Whether events should be copied as well</param>
		/// <returns>The copied element</returns>
		[JsMethod(Name = "clone")]
		public static qx.html.Element Clone(qx.html.Element element, bool events = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Deactivates the given element. The active element receives all key board events.</para>
		/// </summary>
		/// <param name="element">DOM element to focus</param>
		[JsMethod(Name = "deactivate")]
		public static void Deactivate(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Focuses the given element. The element needs to have a positive tabIndex value.</para>
		/// </summary>
		/// <param name="element">DOM element to focus</param>
		[JsMethod(Name = "focus")]
		public static void Focus(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether there are one or more listeners for an event type
		/// registered at the element.</para>
		/// </summary>
		/// <param name="element">DOM element</param>
		/// <param name="type">The event type</param>
		/// <param name="capture">Whether to check for listeners of the bubbling or of the capturing phase.</param>
		/// <returns>Whether the element has event listeners of the given type.</returns>
		[JsMethod(Name = "hasListener")]
		public static bool HasListener(qx.html.Element element, string type, bool capture = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Releases the given element (from a previous <see cref="Capture"/> call)</para>
		/// </summary>
		/// <param name="element">DOM element to release</param>
		[JsMethod(Name = "releaseCapture")]
		public static void ReleaseCapture(qx.html.Element element) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove an event listener from a from DOM node.</para>
		/// <para>Note: All registered event listeners will automatically be removed from
		/// the DOM at page unload so it is not necessary to detach events yourself.</para>
		/// </summary>
		/// <param name="element">DOM Element</param>
		/// <param name="type">Name of the event</param>
		/// <param name="listener">The pointer to the event listener</param>
		/// <param name="self">Reference to the &#8216;this&#8217; variable inside the event listener.</param>
		/// <param name="capture">Whether to remove the event listener of the bubbling or of the capturing phase.</param>
		/// <returns>true if the listener was removed</returns>
		[JsMethod(Name = "removeListener")]
		public static bool RemoveListener(qx.html.Element element, string type, Action<qx.eventx.type.Data> listener, object self = null, bool? capture = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes an event listener from an event target by an id returned by
		/// <see cref="AddListener"/></para>
		/// </summary>
		/// <param name="target">The event target</param>
		/// <param name="id">The id returned by #addListener</param>
		/// <returns>true if the listener was removed</returns>
		[JsMethod(Name = "removeListenerById")]
		public static bool RemoveListenerById(object target, string id) { throw new NotImplementedException(); }

		#endregion Methods
    }
}