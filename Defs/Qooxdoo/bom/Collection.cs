// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.bom
{
    /// <summary>
	/// <para>Wraps a set of elements and offers a whole set of features to query or modify them.</para>
	/// <para>Chaining</para>
	/// <para>The collection uses an interesting concept called a &#8220;Builder&#8221; to make
	/// its code short and simple. The Builder pattern is an object-oriented
	/// programming design pattern that has been gaining popularity.</para>
	/// <para>In a nutshell: Every method on the collection returns the collection object itself,
	/// allowing you to &#8216;chain&#8217; upon it, for example:</para>
	/// <code>
	/// qx.bom.Collection.query("a").addClass("test")
	/// .setStyle("visibility", "visible").setAttribute("html", "foo");
	/// </code>
	/// <para>Content Manipulation</para>
	/// <para>Most methods that accept &#8220;content&#8221; will accept one or more
	/// arguments of any of the following:</para>
	/// <list type="bullet">
	/// <item>A DOM node element</item>
	/// <item>An array of DOM node elements</item>
	/// <item>A collection</item>
	/// <item>A string representing HTML</item>
	/// </list
	/// <para>Example:</para>
	/// <code>
	/// qx.bom.Collection.query("#div1").append(
	/// document.createElement("br"),
	/// qx.bom.Collection.query("#div2"),
	/// "after div2"
	/// );
	/// </code>
	/// <para>Content inserting methods (<see cref="Append"/>, <see cref="Prepend"/>,
	/// <see cref="Before"/>, <see cref="After"/>, and
	/// <see cref="ReplaceWith"/>) behave differently depending on the number of DOM
	/// elements currently selected by the collection. If there is only one
	/// element in the collection, the content is inserted to that element;
	/// content that was in another location in the DOM tree will be moved by
	/// this operation. This is essentially the same as the W3C DOM
	/// appendChild method.</para>
	/// <para>When multiple elements are selected by a collection, these methods
	/// clone the content before inserting it to each element. Since the
	/// content can only exist in one location in the document tree, cloning
	/// is required in these cases so that the same content can be used in
	/// multiple locations.</para>
	/// <para>This rule also applies to the selector-insertion methods (<see cref="AppendTo"/>,
	/// <see cref="PrependTo"/>, <see cref="InsertBefore"/>, <see cref="InsertAfter"/>,
	/// and <see cref="ReplaceAll"/>), but the auto-cloning occurs if there is more
	/// than one element selected by the
	/// Selector provided as an argument to the method.</para>
	/// <para>When a specific behavior is needed regardless of the number of
	/// elements selected, use the <see cref="Clone"/> or <see cref="Remove"/> methods in
	/// conjunction with a selector-insertion method. This example will always
	/// clone #Thing, append it to each element with class OneOrMore, and
	/// leave the original #Thing unmolested in the document:</para>
	/// <code>
	/// qx.bom.Collection.query("#Thing").clone().appendTo(".OneOrMore");
	/// </code>
	/// <para>This example will always remove #Thing from the document and append it
	/// to .OneOrMore:</para>
	/// <code>
	/// qx.bom.Collection.query("#Thing").remove().appendTo(".OneOrMore");
	/// </code>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.bom.Collection", OmitOptionalParameters = true, Export = false)]
    public partial class Collection : qx.type.BaseArray
    {
		#region Methods

		public Collection() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Creates a new Collection with the given size or the listed elements.</para>
		/// <code>
		/// var col1 = new qx.bom.Collection(length);
		/// var col2 = new qx.bom.Collection(elem0, elem1, ..., elemN);
		/// </code>
		/// <list type="bullet">
		/// <item>length: The initial size of the collection of elements.</item>
		/// <item>elem1, elem2. .. elemN:  the elements that will compose the newly created collection</item>
		/// </list
		/// </summary>
		/// <param name="length_or_items">The initial size of the collection OR an argument list of elements.</param>
		public Collection(object length_or_items = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Processes the input and translates it to a collection instance.</para>
		/// <para>Please make sure you understand the security implications of this
		/// method when passing HTML strings from untrusted input. See
		/// <see cref="qx.bom.Html.Clean"/>.</para>
		/// </summary>
		/// <param name="input">Supports HTML elements, HTML strings and selector strings</param>
		/// <param name="context">Where to start looking for the expression or any element in the document which refers to a valid document to create new elements (useful when dealing with HTML->Element translation in multi document environments).</param>
		/// <returns>Newly created collection</returns>
		[JsMethod(Name = "create")]
		public static Collection Create(object input, object context = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Converts a HTML string into a collection</para>
		/// <para>Please make sure you understand the security implications of this
		/// method when passing HTML strings from untrusted input. See
		/// <see cref="qx.bom.Html.Clean"/>.</para>
		/// </summary>
		/// <param name="html">String containing one or multiple elements or pure text content</param>
		/// <param name="context">Context in which newly DOM elements are created from the markup</param>
		/// <returns>Collection containing the create DOM elements</returns>
		[JsMethod(Name = "html")]
		public static Collection Html(string html, object context = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Queries the DOM for an element matching the given ID. Must not contain
		/// the &#8221;#&#8221; like when using the query engine.</para>
		/// <para>This is mainly a wrapper for document.getElementById and
		/// returns a collection for easy querying and modification instead of the
		/// pure DOM node.</para>
		/// </summary>
		/// <param name="id">Identifier for DOM element to found</param>
		/// <returns>Found element wrapped into Collection</returns>
		[JsMethod(Name = "id")]
		public static Collection Id(string id) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Queries the selector engine and returns a new collection
		/// for convenient modification and querying.</para>
		/// </summary>
		/// <param name="selector">CSS Selector String</param>
		/// <param name="context">Context element to filter start search in</param>
		/// <returns>Collection instance to wrap found elements</returns>
		[JsMethod(Name = "query")]
		public static Collection Query(string selector, object context = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds more elements, matched by the given expression,
		/// to the set of matched elements.</para>
		/// </summary>
		/// <param name="selector">Valid selector (CSS3 + extensions)</param>
		/// <param name="context">Context element (result elements must be children of this element)</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "add")]
		public qx.bom.Collection Add(string selector, qx.html.Element context) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds a className to the given element
		/// If successfully added the given className will be returned</para>
		/// </summary>
		/// <param name="name">The class name to add</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "addClass")]
		public Collection AddClass(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add an event listener to the selected elements. The event listener is passed an
		/// instance of <see cref="Event"/> containing all relevant information
		/// about the event as parameter.</para>
		/// </summary>
		/// <param name="type">Name of the event e.g. &#8220;click&#8221;, &#8220;keydown&#8221;, ...</param>
		/// <param name="listener">Event listener function</param>
		/// <param name="self">Reference to the &#8216;this&#8217; variable inside the event listener. When not given, the corresponding dispatcher usually falls back to a default, which is the target by convention. Note this is not a strict requirement, i.e. custom dispatchers can follow a different strategy.</param>
		/// <param name="capture">Whether to attach the event to the capturing phase or the bubbling phase of the event. The default is to attach the event handler to the bubbling phase.</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "addListener")]
		public Collection AddListener(string type, Action<qx.eventx.type.Data> listener, object self = null, bool? capture = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert content after each of the matched elements.</para>
		/// <para>Supports lists of DOM elements or HTML strings through a variable
		/// argument list.</para>
		/// </summary>
		/// <param name="varargs">A reference to an DOM element or a HTML string</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "after")]
		public Collection After(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Add the previous selection to the current selection.</para>
		/// </summary>
		/// <returns>Newly build collection containing the current and and the previous collection.</returns>
		[JsMethod(Name = "andSelf")]
		public Collection AndSelf() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Append content to the inside of every matched element.</para>
		/// <para>Supports lists of DOM elements or HTML strings through a variable
		/// argument list.</para>
		/// <para>Please make sure you understand the security implications of this
		/// method when passing HTML strings from untrusted input. See
		/// <see cref="qx.bom.Html.Clean"/>.</para>
		/// </summary>
		/// <param name="varargs">A reference to an DOM element or a HTML string</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "append")]
		public Collection Append(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Append all of the matched elements to another, specified, set of elements.</para>
		/// <para>This operation is, essentially, the reverse of doing a regular
		/// qx.bom.Collection.query(A).append(B), in that instead
		/// of appending B to A, you&#8217;re appending A to B.</para>
		/// </summary>
		/// <param name="varargs">List of selector expressions</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "appendTo")]
		public Collection AppendTo(string varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert content before each of the matched elements.</para>
		/// <para>Supports lists of DOM elements or HTML strings through a variable
		/// argument list.</para>
		/// </summary>
		/// <param name="varargs">A reference to an DOM element or a HTML string</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "before")]
		public Collection Before(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get a set of elements containing all of the unique immediate children
		/// of each of the matched set of elements.</para>
		/// <para>This set can be filtered with an optional expression that will cause
		/// only elements matching the selector to be collected.</para>
		/// <para>Also note: while parents() will look at all ancestors,
		/// children() will only consider immediate child elements.</para>
		/// </summary>
		/// <param name="selector">Optional selector to match</param>
		/// <returns>The new collection</returns>
		[JsMethod(Name = "children")]
		public Collection Children(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Clone all DOM elements of the collection and return them in a newly
		/// created collection.</para>
		/// </summary>
		/// <param name="events">Whether events should be copied as well</param>
		/// <returns>The copied elements</returns>
		[JsMethod(Name = "clone")]
		public Collection Clone(bool events = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get a set of elements containing the closest parent element
		/// that matches the specified selector, the starting element included.</para>
		/// <para>Closest works by first looking at the current element to see if
		/// it matches the specified expression, if so it just returns the
		/// element itself. If it doesn&#8217;t match then it will continue to
		/// traverse up the document, parent by parent, until an element
		/// is found that matches the specified expression. If no matching
		/// element is found then none will be returned.</para>
		/// </summary>
		/// <param name="selector">Expression to filter the elements with</param>
		/// <returns>New collection which contains all interesting parents</returns>
		[JsMethod(Name = "closest")]
		public Collection Closest(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Find all the child nodes inside the matched elements (including text nodes).</para>
		/// </summary>
		/// <returns>A new collection containing all child nodes of the previous collection.</returns>
		[JsMethod(Name = "contents")]
		public Collection Contents() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all matched elements from their parent elements,
		/// cleans up any attached events or data and clears up the Collection
		/// to free up memory.</para>
		/// <para>The Collection content can be pre-filtered with an optional selector
		/// expression.</para>
		/// <para>Modifies the current collection (without pushing the stack) as it
		/// removes all elements from the collection which where removed from the DOM.
		/// This normally means all elements in the collection when no selector is given.</para>
		/// </summary>
		/// <param name="selector">Selector to filter current collection</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "destroy")]
		public Collection Destroy(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all content from the elements</para>
		/// </summary>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "empty")]
		public Collection Empty() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Undone of the last modification of the collection.</para>
		/// <para>These methods change the selection during a chained method call:
		/// add, children, eq, filter,
		/// find, gt, lt, next,
		/// not, parent, parents and siblings</para>
		/// </summary>
		/// <returns>The previous collection</returns>
		[JsMethod(Name = "end")]
		public Collection End() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reduce the set of matched elements to a single element.</para>
		/// <para>The position of the element in the collection of matched
		/// elements starts at 0 and goes to length &#8211; 1.</para>
		/// </summary>
		/// <param name="index">The position of the element</param>
		/// <returns>The filtered collection</returns>
		[JsMethod(Name = "eq")]
		public Collection Eq(double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all elements from the set of matched elements that
		/// do not match the specified expression(s) or be valid
		/// after being tested with the given function.</para>
		/// <para>A selector function is invoked with three arguments: the value of the element, the
		/// index of the element, and the Array object being traversed.</para>
		/// </summary>
		/// <param name="selector">An expression or function to filter</param>
		/// <param name="context">Optional context for the function to being executed in.</param>
		/// <returns>The filtered collection</returns>
		[JsMethod(Name = "filter")]
		public Collection Filter(object selector, object context = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Searches for all elements that match the specified expression.
		/// This method is a good way to find additional descendant
		/// elements with which to process.</para>
		/// </summary>
		/// <param name="selector">Selector for children to find</param>
		/// <returns>The found elements in a new collection</returns>
		[JsMethod(Name = "find")]
		public Collection Find(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Figures out the value of the given attribute of
		/// the first element stored in the collection.</para>
		/// </summary>
		/// <param name="name">Name of the attribute</param>
		/// <returns>The value of the attribute</returns>
		[JsMethod(Name = "getAttribute")]
		public object GetAttribute(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Gets the classname of the first selected element</para>
		/// </summary>
		/// <returns>The retrieved classname</returns>
		[JsMethod(Name = "getClass")]
		public string GetClass() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the content height of the first element in the collection.</para>
		/// <para>The content height is basically the maximum
		/// height used or the maximum height which can be used by the content. This
		/// excludes all kind of styles of the element like borders, paddings, margins,
		/// and even scrollbars.</para>
		/// <para>Please note that with visible scrollbars the content height returned
		/// may be larger than the box width returned via <see cref="GetWidth"/>.</para>
		/// <para>Only works for DOM elements and not for the window object or the document
		/// object!</para>
		/// </summary>
		/// <returns>Computed content height</returns>
		[JsMethod(Name = "getContentHeight")]
		public double GetContentHeight() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the content width of the first element in the collection.</para>
		/// <para>The content width is basically the maximum
		/// width used or the maximum width which can be used by the content. This
		/// excludes all kind of styles of the element like borders, paddings, margins,
		/// and even scrollbars.</para>
		/// <para>Please note that with visible scrollbars the content width returned
		/// may be larger than the box width returned via <see cref="GetWidth"/>.</para>
		/// <para>Only works for DOM elements and not for the window object or the document
		/// object!</para>
		/// </summary>
		/// <returns>Computed content width</returns>
		[JsMethod(Name = "getContentWidth")]
		public double GetContentWidth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the full content of the style attribute of the first element
		/// in the collection.</para>
		/// </summary>
		/// <returns>the full CSS string</returns>
		[JsMethod(Name = "getCss")]
		public string GetCss() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the height of the first element in the collection.</para>
		/// <para>This is the rendered height of the element which includes borders and
		/// paddings like the offsetHeight property in plain HTML.</para>
		/// </summary>
		/// <returns>The height of the first element</returns>
		[JsMethod(Name = "getHeight")]
		public double GetHeight() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Computes the location of the first element in context of
		/// the document dimensions.</para>
		/// <para>Supported modes:</para>
		/// <list type="bullet">
		/// <item>margin: Calculate from the margin box of the element (bigger than the visual appearance: including margins of given element)</item>
		/// <item>box: Calculates the offset box of the element (default, uses the same size as visible)</item>
		/// <item>border: Calculate the border box (useful to align to border edges of two elements).</item>
		/// <item>scroll: Calculate the scroll box (relevant for absolute positioned content).</item>
		/// <item>padding: Calculate the padding box (relevant for static/relative positioned content).</item>
		/// </list
		/// </summary>
		/// <param name="mode">A supported option. See comment above.</param>
		/// <returns>Returns a map with left, top, right and bottom which contains the distance of the element relative to the document.</returns>
		[JsMethod(Name = "getOffset")]
		public object GetOffset(string mode = "box") { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Detects the offset parent of the first element</para>
		/// </summary>
		/// <returns>Detected offset parent encapsulated into a new collection instance</returns>
		[JsMethod(Name = "getOffsetParent")]
		public Collection GetOffsetParent() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the left scroll position of the first element in the collection.</para>
		/// </summary>
		/// <returns>Current left scroll position</returns>
		[JsMethod(Name = "getScrollLeft")]
		public double GetScrollLeft() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the top scroll position of the first element in the collection.</para>
		/// </summary>
		/// <returns>Current top scroll position</returns>
		[JsMethod(Name = "getScrollTop")]
		public double GetScrollTop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Figures out the value of the given style property of
		/// the first element stored in the collection.</para>
		/// </summary>
		/// <param name="name">Name of the style attribute (JS variant e.g. marginTop, wordSpacing)</param>
		/// <param name="mode">Choose one of the modes supported by qx.bom.element.Style#get</param>
		/// <returns>The value of the style property</returns>
		[JsMethod(Name = "getStyle")]
		public object GetStyle(string name, double mode) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the currently configured value of the first
		/// element in the collection.</para>
		/// <para>Works with simple input fields as well as with
		/// select boxes or option elements.</para>
		/// <para>Returns an array in cases of multi-selection in
		/// select boxes but in all other cases a string.</para>
		/// </summary>
		/// <returns>The value of the first element.</returns>
		[JsMethod(Name = "getValue")]
		public object GetValue() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the width of the first element in the collection.</para>
		/// <para>This is the rendered width of the element which includes borders and
		/// paddings like the offsetWidth property in plain HTML.</para>
		/// </summary>
		/// <returns>The width of the first element</returns>
		[JsMethod(Name = "getWidth")]
		public double GetWidth() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the first selected element has the given className.</para>
		/// </summary>
		/// <param name="name">The class name to check for</param>
		/// <returns>true when the element has the given classname</returns>
		[JsMethod(Name = "hasClass")]
		public bool HasClass(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert all of the matched elements before another, specified, set of elements.</para>
		/// <para>This operation is, essentially, the reverse of doing a regular
		/// qx.bom.Collection.query(A).after(B),  in that instead
		/// of inserting B to A, you&#8217;re inserting A to B.</para>
		/// </summary>
		/// <param name="varargs">List of selector expressions</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "insertAfter")]
		public Collection InsertAfter(string varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert all of the matched elements after another, specified, set of elements.</para>
		/// <para>This operation is, essentially, the reverse of doing a regular
		/// qx.bom.Collection.query(A).before(B), in that instead
		/// of inserting B to A, you&#8217;re inserting A to B.</para>
		/// </summary>
		/// <param name="varargs">List of selector expressions</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "insertBefore")]
		public Collection InsertBefore(string varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Checks the current selection against an expression
		/// and returns true, if at least one element of the
		/// selection fits the given expression.</para>
		/// </summary>
		/// <param name="selector">Selector to check the content for</param>
		/// <returns>Whether at least one element matches the given selector</returns>
		[JsMethod(Name = "is")]
		public bool Is(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get a set of elements containing the unique next siblings of each of the given set of elements.</para>
		/// next only returns the very next sibling for each element, not all next siblings
		/// (see <see cref="NextAll"/>). Use an optional expression to filter the matched set.
		/// </summary>
		/// <param name="selector">Optional selector to filter the result</param>
		/// <returns>Collection of all very next siblings of the current collection.</returns>
		[JsMethod(Name = "next")]
		public Collection Next(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Find all sibling elements after the current element.</para>
		/// <para>Use an optional expression to filter the matched set.</para>
		/// </summary>
		/// <param name="selector">Optional selector to filter the result</param>
		/// <returns>Collection of all siblings following the elements of the current collection.</returns>
		[JsMethod(Name = "nextAll")]
		public Collection NextAll(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes elements matching the specified expression from the collection.</para>
		/// </summary>
		/// <param name="selector">CSS selector expression</param>
		/// <returns>A newly created collection where the matching elements have been removed.</returns>
		[JsMethod(Name = "not")]
		public Collection Not(string selector) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get a set of elements containing the unique parents of the matched set of elements.</para>
		/// </summary>
		/// <param name="selector">Optional selector to filter the result</param>
		/// <returns>Collection of all unique parent elements.</returns>
		[JsMethod(Name = "parent")]
		public Collection Parent(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get a set of elements containing the unique ancestors of the matched set of
		/// elements (except for the root element).</para>
		/// <para>The matched elements can be filtered with an optional expression.</para>
		/// </summary>
		/// <param name="selector">Optional selector to filter the result</param>
		/// <returns>Collection of all unique parent elements.</returns>
		[JsMethod(Name = "parents")]
		public Collection Parents(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Prepend content to the inside of every matched element.</para>
		/// <para>Supports lists of DOM elements or HTML strings through a variable
		/// argument list.</para>
		/// <para>Please make sure you understand the security implications of this
		/// method when passing HTML strings from untrusted input. See
		/// <see cref="qx.bom.Html.Clean"/>.</para>
		/// </summary>
		/// <param name="varargs">A reference to an DOM element or a HTML string</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "prepend")]
		public Collection Prepend(object varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Append all of the matched elements to another, specified, set of elements.</para>
		/// <para>This operation is, essentially, the reverse of doing a regular
		/// qx.bom.Collection.query(A).prepend(B),  in that instead
		/// of prepending B to A, you&#8217;re prepending A to B.</para>
		/// </summary>
		/// <param name="varargs">List of selector expressions</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "prependTo")]
		public Collection PrependTo(string varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get a set of elements containing the unique previous siblings of each of the given set of elements.</para>
		/// prev only returns the very previous sibling for each element, not all previous siblings
		/// (see <see cref="PrevAll"/>). Use an optional expression to filter the matched set.
		/// </summary>
		/// <param name="selector">Optional selector to filter the result</param>
		/// <returns>Collection of all very previous siblings of the current collection.</returns>
		[JsMethod(Name = "prev")]
		public Collection Prev(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Find all sibling elements preceding the current element.</para>
		/// <para>Use an optional expression to filter the matched set.</para>
		/// </summary>
		/// <param name="selector">Optional selector to filter the result</param>
		/// <returns>Collection of all siblings preceding the elements of the current collection.</returns>
		[JsMethod(Name = "prevAll")]
		public Collection PrevAll(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all matched elements from the DOM. This does NOT remove them
		/// from the collection object, allowing you to use the matched
		/// elements further. When a selector is given the list is filtered
		/// by the selector and the chaining stack is pushed by the new collection.</para>
		/// <para>The Collection content can be pre-filtered with an optional selector
		/// expression.</para>
		/// </summary>
		/// <param name="selector">Selector to filter current collection</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "remove")]
		public Collection Remove(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes a className from the given element</para>
		/// </summary>
		/// <param name="name">The class name to remove</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "removeClass")]
		public Collection RemoveClass(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes an event listener from the selected elements.</para>
		/// <para>Note: All registered event listeners will automatically be removed from
		/// the DOM at page unload so it is not necessary to detach events yourself.</para>
		/// </summary>
		/// <param name="type">Name of the event</param>
		/// <param name="listener">The pointer to the event listener</param>
		/// <param name="self">Reference to the &#8216;this&#8217; variable inside the event listener.</param>
		/// <param name="capture">Whether to remove the event listener of the bubbling or of the capturing phase.</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "removeListener")]
		public Collection RemoveListener(string type, Action<qx.eventx.type.Data> listener, object self = null, bool? capture = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replaces the elements matched by the specified selector
		/// with the matched elements.</para>
		/// <para>This function is the complement to <see cref="ReplaceWith"/> which does
		/// the same task with the parameters reversed.</para>
		/// </summary>
		/// <param name="varargs">List of selector expressions</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "replaceAll")]
		public Collection ReplaceAll(string varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replaces the first given class name with the second one</para>
		/// </summary>
		/// <param name="oldName">The class name to remove</param>
		/// <param name="newName">The class name to add</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "replaceClass")]
		public Collection ReplaceClass(string oldName, string newName) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Replaces all matched elements with the specified HTML or DOM elements.</para>
		/// <para>This returns the JQuery element that was just replaced, which has been
		/// removed from the DOM.</para>
		/// </summary>
		/// <param name="content">A reference to an DOM element or a HTML string</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "replaceWith")]
		public Collection ReplaceWith(object content) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reset the given attribute on all selected elements.</para>
		/// </summary>
		/// <param name="name">Name of the attribute</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "resetAttribute")]
		public Collection ResetAttribute(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Reset the given style property
		/// on all selected elements.</para>
		/// </summary>
		/// <param name="name">Name of the style attribute (JS variant e.g. marginTop, wordSpacing)</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "resetStyle")]
		public Collection ResetStyle(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Modify the given attribute on all selected elements.</para>
		/// </summary>
		/// <param name="name">Name of the attribute</param>
		/// <param name="value">New value of the attribute</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "setAttribute")]
		public Collection SetAttribute(string name, object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set the full CSS content of the style attribute for all elements in the
		/// collection.</para>
		/// </summary>
		/// <param name="value">The full CSS string</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "setCss")]
		public Collection SetCss(string value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scrolls the elements of the collection to the given coordinate.</para>
		/// </summary>
		/// <param name="value">Left scroll position</param>
		/// <returns>This collection for chaining</returns>
		[JsMethod(Name = "setScrollLeft")]
		public Collection SetScrollLeft(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scrolls the elements of the collection to the given coordinate.</para>
		/// </summary>
		/// <param name="value">Top scroll position</param>
		/// <returns>This collection for chaining</returns>
		[JsMethod(Name = "setScrollTop")]
		public Collection SetScrollTop(double value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Modify the given style property
		/// on all selected elements.</para>
		/// </summary>
		/// <param name="name">Name of the style attribute (JS variant e.g. marginTop, wordSpacing)</param>
		/// <param name="value">The value for the given style</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "setStyle")]
		public Collection SetStyle(string name, object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Convenience method to modify a set of styles at once.</para>
		/// </summary>
		/// <param name="styles">a map where the key is the name of the property and the value is the value to use.</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "setStyles")]
		public Collection SetStyles(object styles) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Applies the given value to the element.</para>
		/// <para>Normally the value is given as a string/number value and applied
		/// to the field content (textfield, textarea) or used to
		/// detect whether the field is checked (checkbox, radiobutton).</para>
		/// <para>Supports array values for selectboxes (multiple-selection)
		/// and checkboxes or radiobuttons (for convenience).</para>
		/// <para>Please note: To modify the value attribute of a checkbox or
		/// radiobutton use <see cref="qx.bom.element.Attribute.Set"/> instead.</para>
		/// </summary>
		/// <param name="value">Value to apply to each element</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "setValue")]
		public Collection SetValue(object value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get a set of elements containing all of the unique siblings
		/// of each of the matched set of elements.</para>
		/// <para>Can be filtered with an optional expressions.</para>
		/// </summary>
		/// <param name="selector">Optional selector to filter the result</param>
		/// <returns>Collection of all unique sibling elements.</returns>
		[JsMethod(Name = "siblings")]
		public Collection Siblings(string selector = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Toggles a className of the selected elements</para>
		/// </summary>
		/// <param name="name">The class name to toggle</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "toggleClass")]
		public Collection ToggleClass(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Wrap each matched element with the specified HTML content.</para>
		/// <para>This wrapping process is most useful for injecting additional structure
		/// into a document, without ruining the original semantic qualities of a
		/// document. This works by going through the first element provided (which
		/// is generated, on the fly, from the provided HTML) and finds the deepest
		/// descendant element within its structure&#8212;it is that element, which
		/// will wrap everything else.</para>
		/// </summary>
		/// <param name="content">Element or HTML markup used for wrapping</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "wrap")]
		public Collection Wrap(object content) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Wrap all the elements in the matched set into a single wrapper element.</para>
		/// <para>This is different from <see cref="Wrap"/> where each element in the matched set
		/// would get wrapped with an element.</para>
		/// <para>This wrapping process is most useful for injecting additional structure
		/// into a document, without ruining the original semantic qualities of
		/// a document.</para>
		/// <para>This works by going through the first element provided (which is
		/// generated, on the fly, from the provided HTML) and finds the deepest
		/// descendant element within its structure&#8212;it is that element, which
		/// will wrap everything else.</para>
		/// </summary>
		/// <param name="content">Element or HTML markup used for wrapping</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "wrapAll")]
		public Collection WrapAll(object content) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Wrap the inner child contents of each matched element (including
		/// text nodes) with an HTML structure.</para>
		/// <para>This wrapping process is most useful for injecting additional structure
		/// into a document, without ruining the original semantic qualities of a
		/// document. This works by going through the first element provided
		/// (which is generated, on the fly, from the provided HTML) and finds the
		/// deepest ancestor element within its structure&#8212;it is that element
		/// that will enwrap everything else.</para>
		/// </summary>
		/// <param name="content">Element or HTML markup used for wrapping</param>
		/// <returns>The collection is returned for chaining proposes</returns>
		[JsMethod(Name = "wrapInner")]
		public Collection WrapInner(object content) { throw new NotImplementedException(); }

		#endregion Methods
    }
}