// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.html
{
    /// <summary>
	/// <para>High-performance, high-level DOM element creation and management.</para>
	/// <para>Includes support for HTML and style attributes. Elements also have
	/// got a powerful children and visibility management.</para>
	/// <para>Processes DOM insertion and modification with advanced logic
	/// to reduce the real transactions.</para>
	/// <para>From the view of the parent you can use the following children management
	/// methods:
	/// <see cref="GetChildren"/>, <see cref="IndexOf"/>, <see cref="HasChild"/>, <see cref="Add"/>,
	/// <see cref="AddAt"/>, <see cref="Remove"/>, <see cref="RemoveAt"/>, <see cref="RemoveAll"/></para>
	/// <para>Each child itself also has got some powerful methods to control its
	/// position:
	/// <see cref="GetParent"/>, <see cref="Free"/>,
	/// <see cref="InsertInto"/>, <see cref="InsertBefore"/>, <see cref="InsertAfter"/>,
	/// <see cref="MoveTo"/>, <see cref="MoveBefore"/>, <see cref="MoveAfter"/>,</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.html.Element", OmitOptionalParameters = true, Export = false)]
    public partial class Element : qx.core.Object
    {
		#region Methods

		public Element() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Creates a new Element</para>
		/// </summary>
		/// <param name="tagName">Tag name of the element to create</param>
		/// <param name="styles">optional map of CSS styles, where the key is the name of the style and the value is the value to use.</param>
		/// <param name="attributes">optional map of element attributes, where the key is the name of the attribute and the value is the value to use.</param>
		public Element(string tagName = "div", object styles = null, object attributes = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Flush the global modified list</para>
		/// </summary>
		[JsMethod(Name = "flush")]
		public static void Flush() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Mark this element to get activated on the next flush of the queue</para>
		/// </summary>
		[JsMethod(Name = "activate")]
		public void Activate() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Append all given children at the end of this element.</para>
		/// </summary>
		/// <param name="varargs">elements to insert</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "add")]
		public qx.html.Element Add(qx.html.Element varargs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Inserts a new element into this element at the given position.</para>
		/// </summary>
		/// <param name="child">the element to insert</param>
		/// <param name="index">the index (starts at 0 for the first child) to insert (the index of the following children will be increased by one)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "addAt")]
		public qx.html.Element AddAt(qx.html.Element child, double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Adds an event listener to the element.</para>
		/// </summary>
		/// <param name="type">Name of the event</param>
		/// <param name="listener">Function to execute on event</param>
		/// <param name="self">Reference to the &#8216;this&#8217; variable inside the event listener. When not given, the corresponding dispatcher usually falls back to a default, which is the target by convention. Note this is not a strict requirement, i.e. custom dispatchers can follow a different strategy.</param>
		/// <param name="capture">Whether capturing should be enabled</param>
		/// <returns>An opaque id, which can be used to remove the event listener using the #removeListenerById method.</returns>
		[JsMethod(Name = "addListener")]
		public object AddListener(string type, Action<qx.eventx.type.Data> listener, object self = null, bool capture = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Mark this element to get blurred on the next flush of the queue</para>
		/// </summary>
		[JsMethod(Name = "blur")]
		public void Blur() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Captures all mouse events to this element</para>
		/// </summary>
		/// <param name="containerCapture">If true all events originating in the container are captured. If false events originating in the container are not captured.</param>
		[JsMethod(Name = "capture")]
		public void Capture(bool containerCapture = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Clears the selection of the element.</para>
		/// <para>This method only works if the underlying DOM element is already created.</para>
		/// </summary>
		[JsMethod(Name = "clearTextSelection")]
		public void ClearTextSelection() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Mark this element to get deactivated on the next flush of the queue</para>
		/// </summary>
		[JsMethod(Name = "deactivate")]
		public void Deactivate() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Disables browser-native scrolling</para>
		/// </summary>
		[JsMethod(Name = "disableScrolling")]
		public void DisableScrolling() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Re-enables browser-native scrolling</para>
		/// </summary>
		[JsMethod(Name = "enableScrolling")]
		public void EnableScrolling() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Marks the element as excluded which means it will be removed
		/// from the DOM and ignored for updates until it gets included again.</para>
		/// </summary>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "exclude")]
		public qx.html.Element Exclude() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fades in the element.</para>
		/// </summary>
		/// <param name="duration">Time in ms.</param>
		/// <returns>The animation handle to react for the fade animation.</returns>
		[JsMethod(Name = "fadeIn")]
		public qx.bom.element.AnimationHandle FadeIn(double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Fades out the element.</para>
		/// </summary>
		/// <param name="duration">Time in ms.</param>
		/// <returns>The animation handle to react for the fade animation.</returns>
		[JsMethod(Name = "fadeOut")]
		public qx.bom.element.AnimationHandle FadeOut(double duration) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Focus this element.</para>
		/// <para>If the underlaying DOM element is not yet created, the
		/// focus is queued for processing after the element creation.</para>
		/// </summary>
		[JsMethod(Name = "focus")]
		public void Focus() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove self from the current parent.</para>
		/// </summary>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "free")]
		public qx.html.Element Free() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a map of all styles. Do not modify the result map!</para>
		/// </summary>
		/// <returns>All styles or null when none are configured.</returns>
		[JsMethod(Name = "getAllStyles")]
		public object GetAllStyles() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the value of the given attribute.</para>
		/// </summary>
		/// <param name="key">name of the attribute</param>
		/// <returns>the value of the attribute</returns>
		[JsMethod(Name = "getAttribute")]
		public object GetAttribute(string key) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get a child element at the given index</para>
		/// </summary>
		/// <param name="index">child index</param>
		/// <returns>The child element or null if no child is found at that index.</returns>
		[JsMethod(Name = "getChild")]
		public qx.html.Element GetChild(double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns a copy of the internal children structure.</para>
		/// <para>Please do not modify the array in place. If you need
		/// to work with the data in such a way make yourself
		/// a copy of the data first.</para>
		/// </summary>
		/// <returns>the children list</returns>
		[JsMethod(Name = "getChildren")]
		public JsArray GetChildren() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the DOM element (if created). Please use this with caution.
		/// It is better to make all changes to the object itself using the public
		/// API rather than to the underlying DOM element.</para>
		/// </summary>
		/// <returns>The DOM element node, if available.</returns>
		[JsMethod(Name = "getDomElement")]
		public qx.html.Element GetDomElement() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the nodeName of the DOM element.</para>
		/// </summary>
		/// <returns>The node name</returns>
		[JsMethod(Name = "getNodeName")]
		public string GetNodeName() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the parent of this element.</para>
		/// </summary>
		/// <returns>The parent of this element</returns>
		[JsMethod(Name = "getParent")]
		public qx.html.Element GetParent() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the horizontal scroll position.</para>
		/// </summary>
		/// <returns>Horizontal scroll position</returns>
		[JsMethod(Name = "getScrollX")]
		public double GetScrollX() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the vertical scroll position.</para>
		/// </summary>
		/// <returns>Vertical scroll position</returns>
		[JsMethod(Name = "getScrollY")]
		public double GetScrollY() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the value of the given style attribute.</para>
		/// </summary>
		/// <param name="key">name of the style attribute</param>
		/// <returns>the value of the style attribute</returns>
		[JsMethod(Name = "getStyle")]
		public object GetStyle(string key) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the selection of the element.</para>
		/// <para>If the underlaying DOM element is not yet created, this methods returns
		/// a null value.</para>
		/// </summary>
		/// <returns></returns>
		[JsMethod(Name = "getTextSelection")]
		public string GetTextSelection() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the end of the selection of the element.</para>
		/// <para>If the underlaying DOM element is not yet created, this methods returns
		/// a null value.</para>
		/// </summary>
		/// <returns></returns>
		[JsMethod(Name = "getTextSelectionEnd")]
		public double GetTextSelectionEnd() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the length of selection of the element.</para>
		/// <para>If the underlaying DOM element is not yet created, this methods returns
		/// a null value.</para>
		/// </summary>
		/// <returns></returns>
		[JsMethod(Name = "getTextSelectionLength")]
		public double GetTextSelectionLength() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the start of the selection of the element.</para>
		/// <para>If the underlaying DOM element is not yet created, this methods returns
		/// a null value.</para>
		/// </summary>
		/// <returns></returns>
		[JsMethod(Name = "getTextSelectionStart")]
		public double GetTextSelectionStart() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the given element is a child of this element.</para>
		/// </summary>
		/// <param name="child">the child</param>
		/// <returns>Returns true when the given element is a child of this element.</returns>
		[JsMethod(Name = "hasChild")]
		public bool HasChild(qx.html.Element child) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns whether the element has any child nodes</para>
		/// </summary>
		/// <returns>Whether the element has any child nodes</returns>
		[JsMethod(Name = "hasChildren")]
		public bool HasChildren() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check if there are one or more listeners for an event type.</para>
		/// </summary>
		/// <param name="type">name of the event type</param>
		/// <param name="capture">Whether to check for listeners of the bubbling or of the capturing phase.</param>
		/// <returns>Whether the object has a listener of the given type.</returns>
		[JsMethod(Name = "hasListener")]
		public bool HasListener(string type, bool capture = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Marks the element as hidden which means it will kept in DOM (if it
		/// is already there, but configured hidden using a CSS style of display=none).</para>
		/// </summary>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "hide")]
		public qx.html.Element Hide() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Marks the element as included which means it will be moved into
		/// the DOM again and synced with the internal data representation.</para>
		/// </summary>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "include")]
		public qx.html.Element Include() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Find the position of the given child</para>
		/// </summary>
		/// <param name="child">the child</param>
		/// <returns>returns the position. If the element is not a child -1 will be returned.</returns>
		[JsMethod(Name = "indexOf")]
		public double IndexOf(qx.html.Element child) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert self after the given (related) element</para>
		/// </summary>
		/// <param name="rel">the related element</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "insertAfter")]
		public qx.html.Element InsertAfter(qx.html.Element rel) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert self before the given (related) element</para>
		/// </summary>
		/// <param name="rel">the related element</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "insertBefore")]
		public qx.html.Element InsertBefore(qx.html.Element rel) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Insert self into the given parent. Normally appends self to the end,
		/// but optionally a position can be defined. With index 0 it
		/// will be inserted at the begin.</para>
		/// </summary>
		/// <param name="parent">The new parent of this element</param>
		/// <param name="index">Optional position</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "insertInto")]
		public qx.html.Element InsertInto(qx.html.Element parent, double? index = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the element is focusable (or will be when created)</para>
		/// </summary>
		/// <returns>true when the element is focusable.</returns>
		[JsMethod(Name = "isFocusable")]
		public bool IsFocusable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the element is part of the DOM</para>
		/// </summary>
		/// <returns>Whether the element is part of the DOM.</returns>
		[JsMethod(Name = "isIncluded")]
		public bool IsIncluded() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the element is natively focusable (or will be when created)</para>
		/// <para>This ignores the configured tabIndex.</para>
		/// </summary>
		/// <returns>true when the element is focusable.</returns>
		[JsMethod(Name = "isNativelyFocusable")]
		public bool IsNativelyFocusable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Whether the element is visible.</para>
		/// <para>Please note: This does not control the visibility or parent inclusion recursively.</para>
		/// </summary>
		/// <returns>Returns true when the element is configured to be visible.</returns>
		[JsMethod(Name = "isVisible")]
		public bool IsVisible() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Move self after the given (related) child.</para>
		/// </summary>
		/// <param name="rel">the related child</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "moveAfter")]
		public qx.html.Element MoveAfter(qx.html.Element rel) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Move self before the given (related) child.</para>
		/// </summary>
		/// <param name="rel">the related child</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "moveBefore")]
		public qx.html.Element MoveBefore(qx.html.Element rel) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Move self to the given index in the current parent.</para>
		/// </summary>
		/// <param name="index">the index (starts at 0 for the first child)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "moveTo")]
		public qx.html.Element MoveTo(double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Releases this element from a previous <see cref="Capture"/> call</para>
		/// </summary>
		[JsMethod(Name = "releaseCapture")]
		public void ReleaseCapture() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes all given children</para>
		/// </summary>
		/// <param name="childs">children to remove</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "remove")]
		public qx.html.Element Remove(qx.html.Element childs) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Remove all children from this element.</para>
		/// </summary>
		/// <returns>A reference to this.</returns>
		[JsMethod(Name = "removeAll")]
		public qx.html.Element RemoveAll() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the child at the given index</para>
		/// </summary>
		/// <param name="index">the position of the child (starts at 0 for the first child)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "removeAt")]
		public qx.html.Element RemoveAt(double index) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the given attribute</para>
		/// </summary>
		/// <param name="key">the name of the attribute</param>
		/// <param name="direct">Whether the value should be removed directly (without queuing)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "removeAttribute")]
		public qx.html.Element RemoveAttribute(string key, bool direct = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes an event listener from the element.</para>
		/// </summary>
		/// <param name="type">Name of the event</param>
		/// <param name="listener">Function to execute on event</param>
		/// <param name="self">Execution context of given function</param>
		/// <param name="capture">Whether capturing should be enabled</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "removeListener")]
		public qx.html.Element RemoveListener(string type, Action<qx.eventx.type.Data> listener, object self, bool capture = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes an event listener from an event target by an id returned by
		/// <see cref="AddListener"/></para>
		/// </summary>
		/// <param name="id">The id returned by #addListener</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "removeListenerById")]
		public qx.html.Element RemoveListenerById(object id) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Removes the given style attribute</para>
		/// </summary>
		/// <param name="key">the name of the style attribute</param>
		/// <param name="direct">Whether the value should be removed directly (without queuing)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "removeStyle")]
		public qx.html.Element RemoveStyle(string key, bool direct = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scrolls the given child element into view. Only scrolls children.
		/// Do not influence elements on top of this element.</para>
		/// <para>If the element is currently invisible it gets scrolled automatically
		/// at the next time it is visible again (queued).</para>
		/// </summary>
		/// <param name="elem">The element to scroll into the viewport.</param>
		/// <param name="align">Alignment of the element. Allowed values: left or right. Could also be null. Without a given alignment the method tries to scroll the widget with the minimum effort needed.</param>
		/// <param name="direct">Whether the execution should be made directly when possible</param>
		[JsMethod(Name = "scrollChildIntoViewX")]
		public void ScrollChildIntoViewX(qx.html.Element elem, string align = null, bool direct = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scrolls the given child element into view. Only scrolls children.
		/// Do not influence elements on top of this element.</para>
		/// <para>If the element is currently invisible it gets scrolled automatically
		/// at the next time it is visible again (queued).</para>
		/// </summary>
		/// <param name="elem">The element to scroll into the viewport.</param>
		/// <param name="align">Alignment of the element. Allowed values: top or bottom. Could also be null. Without a given alignment the method tries to scroll the widget with the minimum effort needed.</param>
		/// <param name="direct">Whether the execution should be made directly when possible</param>
		[JsMethod(Name = "scrollChildIntoViewY")]
		public void ScrollChildIntoViewY(qx.html.Element elem, string align = null, bool direct = true) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scrolls the element to the given left position.</para>
		/// </summary>
		/// <param name="x">Horizontal scroll position</param>
		/// <param name="lazy">Whether the scrolling should be performed during element flush.</param>
		[JsMethod(Name = "scrollToX")]
		public void ScrollToX(double x, bool lazy = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Scrolls the element to the given top position.</para>
		/// </summary>
		/// <param name="y">Vertical scroll position</param>
		/// <param name="lazy">Whether the scrolling should be performed during element flush.</param>
		[JsMethod(Name = "scrollToY")]
		public void ScrollToY(double y, bool lazy = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set up the given attribute</para>
		/// </summary>
		/// <param name="key">the name of the attribute</param>
		/// <param name="value">the value</param>
		/// <param name="direct">Whether the value should be applied directly (without queuing)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "setAttribute")]
		public qx.html.Element SetAttribute(string key, object value, bool direct = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Convenience method to modify a set of attributes at once.</para>
		/// </summary>
		/// <param name="map">a map where the key is the name of the property and the value is the value to use.</param>
		/// <param name="direct">Whether the values should be applied directly (without queuing)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "setAttributes")]
		public qx.html.Element SetAttributes(object map, bool direct = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the nodeName of the DOM element.</para>
		/// </summary>
		/// <param name="name">The node name</param>
		[JsMethod(Name = "setNodeName")]
		public void SetNodeName(string name) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Sets the element&#8217;s root flag, which indicates
		/// whether the element should be a root element or not.</para>
		/// </summary>
		/// <param name="root">The root flag.</param>
		[JsMethod(Name = "setRoot")]
		public void SetRoot(bool root) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set whether the element is selectable. It uses the qooxdoo attribute
		/// qxSelectable with the values &#8216;on&#8217; or &#8216;off&#8217;.
		/// In webkit, a special css property will be used (-webkit-user-select).</para>
		/// </summary>
		/// <param name="value">True, if the element should be selectable.</param>
		[JsMethod(Name = "setSelectable")]
		public void SetSelectable(bool value) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set up the given style attribute</para>
		/// </summary>
		/// <param name="key">the name of the style attribute</param>
		/// <param name="value">the value</param>
		/// <param name="direct">Whether the value should be applied directly (without queuing)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "setStyle")]
		public qx.html.Element SetStyle(string key, object value, bool direct = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Convenience method to modify a set of styles at once.</para>
		/// </summary>
		/// <param name="map">a map where the key is the name of the property and the value is the value to use.</param>
		/// <param name="direct">Whether the values should be applied directly (without queuing)</param>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "setStyles")]
		public qx.html.Element SetStyles(object map, bool direct = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set the selection of the element with the given start and end value.
		/// If no end value is passed the selection will extend to the end.</para>
		/// <para>This method only works if the underlying DOM element is already created.</para>
		/// </summary>
		/// <param name="start">start of the selection (zero based)</param>
		/// <param name="end">end of the selection</param>
		[JsMethod(Name = "setTextSelection")]
		public void SetTextSelection(double start, double end) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Marks the element as visible which means that a previously applied
		/// CSS style of display=none gets removed and the element will inserted
		/// into the DOM, when this had not already happened before.</para>
		/// </summary>
		/// <returns>this object (for chaining support)</returns>
		[JsMethod(Name = "show")]
		public qx.html.Element Show() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Uses an existing element instead of creating one. This may be interesting
		/// when the DOM element is directly needed to add content etc.</para>
		/// </summary>
		/// <param name="elem">Element to reuse</param>
		[JsMethod(Name = "useElement")]
		public void UseElement(qx.html.Element elem) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Uses existing markup for this element. This is mainly used
		/// to insert pre-built markup blocks into the element hierarchy.</para>
		/// </summary>
		/// <param name="html">HTML markup with one root element which is used as the main element for this instance.</param>
		/// <returns>The created DOM element</returns>
		[JsMethod(Name = "useMarkup")]
		public qx.html.Element UseMarkup(string html) { throw new NotImplementedException(); }

		#endregion Methods
    }
}