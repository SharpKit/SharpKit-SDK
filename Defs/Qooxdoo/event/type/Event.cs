// Generated by SharpKit.QooxDoo.Generator
using System;
using System.Collections.Generic;
using SharpKit.Html;
using SharpKit.JavaScript;

namespace qx.eventx.type
{
    /// <summary>
	/// <para>Basic event object.</para>
	/// <para>Please note:
	/// Event objects are only valid during the event dispatch. After the dispatch
	/// event objects are pooled or disposed. If you want to safe a reference to an
	/// event instance use the <see cref="Clone"/> method.</para>
	/// <para>The interface is modeled after the DOM level 2 event interface:
	/// http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface</para>
	/// </summary>
	[JsType(JsMode.Prototype, Name = "qx.event.type.Event", OmitOptionalParameters = true, Export = false)]
    public partial class Event : qx.core.Object
    {
		#region Methods

		public Event() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Create a clone of the event object, which is not automatically disposed
		/// or pooled after an event dispatch.</para>
		/// </summary>
		/// <param name="embryo">Optional event class, which will be configured using the data of this event instance. The event must be an instance of this event class. If the value is null, a new pooled instance is created.</param>
		/// <returns>a clone of this class.</returns>
		[JsMethod(Name = "clone")]
		public qx.eventx.type.Event Clone(qx.eventx.type.Event embryo = null) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Check whether or not the event is a bubbling event. If the event can
		/// bubble the value is true, else the value is false.</para>
		/// </summary>
		/// <returns>Whether the event bubbles</returns>
		[JsMethod(Name = "getBubbles")]
		public bool GetBubbles() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the event target node whose event listeners are currently being
		/// processed. This is particularly useful during event capturing and
		/// bubbling.</para>
		/// </summary>
		/// <returns>The target the event listener is currently dispatched on.</returns>
		[JsMethod(Name = "getCurrentTarget")]
		public qx.html.Element GetCurrentTarget() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get whether the default action has been prevented</para>
		/// </summary>
		/// <returns>Whether the default action has been prevented</returns>
		[JsMethod(Name = "getDefaultPrevented")]
		public bool GetDefaultPrevented() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Used to indicate which phase of event flow is currently being evaluated.</para>
		/// </summary>
		/// <returns>The current event phase. Possible values are #CAPTURING_PHASE, #AT_TARGET and #BUBBLING_PHASE.</returns>
		[JsMethod(Name = "getEventPhase")]
		public double GetEventPhase() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the original event target. This is only configured
		/// for events which are fired by another event (often when
		/// the target should be reconfigured for another view) e.g.
		/// low-level DOM event to widget event.</para>
		/// </summary>
		/// <returns>The original target</returns>
		[JsMethod(Name = "getOriginalTarget")]
		public qx.html.Element GetOriginalTarget() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get whether further event propagation has been stopped.</para>
		/// </summary>
		/// <returns>Whether further propagation has been stopped.</returns>
		[JsMethod(Name = "getPropagationStopped")]
		public bool GetPropagationStopped() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get the related event target. This is only configured for
		/// events which also had an influences on another element e.g.
		/// mouseover/mouseout, focus/blur, ...</para>
		/// </summary>
		/// <returns>The related target</returns>
		[JsMethod(Name = "getRelatedTarget")]
		public qx.html.Element GetRelatedTarget() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Returns the event target to which the event was originally
		/// dispatched.</para>
		/// </summary>
		/// <returns>target to which the event was originally dispatched.</returns>
		[JsMethod(Name = "getTarget")]
		public qx.html.Element GetTarget() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>The time (in milliseconds relative to the epoch) at which the event was created.</para>
		/// </summary>
		/// <returns>the timestamp the event was created.</returns>
		[JsMethod(Name = "getTimeStamp")]
		public double GetTimeStamp() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>The name of the event</para>
		/// </summary>
		/// <returns>name of the event</returns>
		[JsMethod(Name = "getType")]
		public string GetType() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Initialize the fields of the event. The event must be initialized before
		/// it can be dispatched.</para>
		/// </summary>
		/// <param name="canBubble">Whether or not the event is a bubbling event. If the event is bubbling, the bubbling can be stopped using #stopPropagation</param>
		/// <param name="cancelable">Whether or not an event can have its default action prevented. The default action can either be the browser&#8217;s default action of a native event (e.g. open the context menu on a right click) or the default action of a qooxdoo class (e.g. close the window widget). The default action can be prevented by calling #preventDefault</param>
		/// <returns>The initialized event instance</returns>
		[JsMethod(Name = "init")]
		public qx.eventx.type.Event Init(bool canBubble = false, bool cancelable = false) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Get whether the event is cancelable</para>
		/// </summary>
		/// <returns>Whether the event is cancelable</returns>
		[JsMethod(Name = "isCancelable")]
		public bool IsCancelable() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Prevent the default action of cancelable events, e.g. opening the context
		/// menu, ...</para>
		/// </summary>
		[JsMethod(Name = "preventDefault")]
		public void PreventDefault() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set whether the event bubbles.</para>
		/// </summary>
		/// <param name="bubbles">Whether the event bubbles</param>
		[JsMethod(Name = "setBubbles")]
		public void SetBubbles(bool bubbles) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Set whether the event is cancelable</para>
		/// </summary>
		/// <param name="cancelable">Whether the event is cancelable</param>
		[JsMethod(Name = "setCancelable")]
		public void SetCancelable(bool cancelable) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Override current target.</para>
		/// </summary>
		/// <param name="currentTarget">new current target</param>
		[JsMethod(Name = "setCurrentTarget")]
		public void SetCurrentTarget(qx.html.Element currentTarget) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Override the event phase</para>
		/// </summary>
		/// <param name="eventPhase">new event phase</param>
		[JsMethod(Name = "setEventPhase")]
		public void SetEventPhase(double eventPhase) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Override original target.</para>
		/// </summary>
		/// <param name="originalTarget">new original target</param>
		[JsMethod(Name = "setOriginalTarget")]
		public void SetOriginalTarget(qx.html.Element originalTarget) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Override related target.</para>
		/// </summary>
		/// <param name="relatedTarget">new related target</param>
		[JsMethod(Name = "setRelatedTarget")]
		public void SetRelatedTarget(qx.html.Element relatedTarget) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Override event target.</para>
		/// </summary>
		/// <param name="target">new event target</param>
		[JsMethod(Name = "setTarget")]
		public void SetTarget(qx.html.Element target) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Override the event type</para>
		/// </summary>
		/// <param name="type">new event type</param>
		[JsMethod(Name = "setType")]
		public void SetType(string type) { throw new NotImplementedException(); }

		/// <summary>
		/// <para>Stops event from all further processing. Execute this when the
		/// current handler should have &#8220;exclusive rights&#8221; to the event
		/// and no further reaction by anyone else should happen.</para>
		/// </summary>
		[JsMethod(Name = "stop")]
		public void Stop() { throw new NotImplementedException(); }

		/// <summary>
		/// <para>This method is used to prevent further propagation of an event during event
		/// flow. If this method is called by any event listener the event will cease
		/// propagating through the tree. The event will complete dispatch to all listeners
		/// on the current event target before event flow stops.</para>
		/// </summary>
		[JsMethod(Name = "stopPropagation")]
		public void StopPropagation() { throw new NotImplementedException(); }

		#endregion Methods
    }
}