//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:41 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.layout
{
    #region Context
    /// <inheritdocs />
    /// <summary>
    /// <p>Manages context information during a layout.</p>
    /// <h1>Algorithm</h1>
    /// <p>This class performs the following jobs:</p>
    /// <ul>
    /// <li>Cache DOM reads to avoid reading the same values repeatedly.</li>
    /// <li>Buffer DOM writes and flush them as a block to avoid read/write interleaving.</li>
    /// <li>Track layout dependencies so each layout does not have to figure out the source of
    /// its dependent values.</li>
    /// <li>Intelligently run layouts when the values on which they depend change (a trigger).</li>
    /// <li>Allow layouts to avoid processing when required values are unavailable (a block).</li>
    /// </ul>
    /// <p>Work done during layout falls into either a "read phase" or a "write phase" and it is
    /// essential to always be aware of the current phase. Most methods in
    /// <see cref="Ext.layout.Layout">Layout</see> are called during a read phase:
    /// <see cref="Ext.layout.Layout.calculate">calculate</see>,
    /// <see cref="Ext.layout.Layout.completeLayout">completeLayout</see> and
    /// <see cref="Ext.layout.Layout.finalizeLayout">finalizeLayout</see>. The exceptions to this are
    /// <see cref="Ext.layout.Layout.beginLayout">beginLayout</see>,
    /// <see cref="Ext.layout.Layout.beginLayoutCycle">beginLayoutCycle</see> and
    /// <see cref="Ext.layout.Layout.finishedLayout">finishedLayout</see> which are called during
    /// a write phase. While <see cref="Ext.layout.Layout.finishedLayout">finishedLayout</see> is called
    /// a write phase, it is really intended to be a catch-all for post-processing after a
    /// layout run.</p>
    /// <p>In a read phase, it is OK to read the DOM but this should be done using the appropriate
    /// <see cref="Ext.layout.ContextItem">ContextItem</see> where possible since that provides a cache
    /// to avoid redundant reads. No writes should be made to the DOM in a read phase! Instead,
    /// the values should be written to the proper ContextItem for later write-back.</p>
    /// <p>The rules flip-flop in a write phase. The only difference is that ContextItem methods
    /// like <see cref="Ext.layout.ContextItem.getStyle">getStyle</see> will still read the DOM unless the
    /// value was previously read. This detail is unknowable from the outside of ContextItem, so
    /// read calls to ContextItem should also be avoided in a write phase.</p>
    /// <p>Calculating interdependent layouts requires a certain amount of iteration. In a given
    /// cycle, some layouts will contribute results that allow other layouts to proceed. The
    /// general flow then is to gather all of the layouts (both component and container) in a
    /// component tree and queue them all for processing. The initial queue order is bottom-up
    /// and component layout first, then container layout (if applicable) for each component.</p>
    /// <p>This initial step also calls the beginLayout method on all layouts to clear any values
    /// from the DOM that might interfere with calculations and measurements. In other words,
    /// this is a "write phase" and reads from the DOM should be strictly avoided.</p>
    /// <p>Next the layout enters into its iterations or "cycles". Each cycle consists of calling
    /// the <see cref="Ext.layout.Layout.calculate">calculate</see> method on all layouts in the
    /// <see cref="Ext.layout.Context.layoutQueue">layoutQueue</see>. These calls are part of a "read phase" and writes to the DOM should
    /// be strictly avoided.</p>
    /// <h1>Considerations</h1>
    /// <p><strong>RULE 1</strong>: Respect the read/write cycles. Always use the <see cref="Ext.layout.ContextItem.getProp">getProp</see>
    /// or <see cref="Ext.layout.ContextItem.getDomProp">getDomProp</see> methods to get calculated values;
    /// only use the <see cref="Ext.layout.ContextItem.getStyle">getStyle</see> method to read styles; use
    /// <see cref="Ext.layout.ContextItem.setProp">setProp</see> to set DOM values. Some reads will, of
    /// course, still go directly to the DOM, but if there is a method in
    /// <see cref="Ext.layout.ContextItem">ContextItem</see> to do a certain job, it should be used instead
    /// of a lower-level equivalent.</p>
    /// <p>The basic logic flow in <see cref="Ext.layout.Layout.calculate">calculate</see> consists of gathering
    /// values by calling <see cref="Ext.layout.ContextItem.getProp">getProp</see> or
    /// <see cref="Ext.layout.ContextItem.getDomProp">getDomProp</see>, calculating results and publishing
    /// them by calling <see cref="Ext.layout.ContextItem.setProp">setProp</see>. It is important to realize
    /// that <see cref="Ext.layout.ContextItem.getProp">getProp</see> will return <c>undefined</c> if the value
    /// is not yet known. But the act of calling the method is enough to track the fact that the
    /// calling layout depends (in some way) on this value. In other words, the calling layout is
    /// "triggered" by the properties it requests.</p>
    /// <p><strong>RULE 2</strong>: Avoid calling <see cref="Ext.layout.ContextItem.getProp">getProp</see> unless the value
    /// is needed. Gratuitous calls cause inefficiency because the layout will appear to depend on
    /// values that it never actually uses. This applies equally to
    /// <see cref="Ext.layout.ContextItem.getDomProp">getDomProp</see> and the test-only methods
    /// <see cref="Ext.layout.ContextItem.hasProp">hasProp</see> and <see cref="Ext.layout.ContextItem.hasDomProp">hasDomProp</see>.</p>
    /// <p>Because <see cref="Ext.layout.ContextItem.getProp">getProp</see> can return <c>undefined</c>, it is often
    /// the case that subsequent math will produce NaN's. This is usually not a problem as the
    /// NaN's simply propagate along and result in final results that are NaN. Both <c>undefined</c>
    /// and NaN are ignored by <see cref="Ext.layout.ContextItem.setProp">Ext.layout.ContextItem.setProp</see>, so it is often not necessary
    /// to even know that this is happening. It does become important for determining if a layout
    /// is not done or if it might lead to publishing an incorrect (but not NaN or <c>undefined</c>)
    /// value.</p>
    /// <p><strong>RULE 3</strong>: If a layout has not calculated all the values it is required to calculate, it
    /// must set <see cref="Ext.layout.Layout.done">done</see> to <c>false</c> before returning from
    /// <see cref="Ext.layout.Layout.calculate">calculate</see>. This value is always <c>true</c> on entry because
    /// it is simpler to detect the incomplete state rather than the complete state (especially up
    /// and down a class hierarchy).</p>
    /// <p><strong>RULE 4</strong>: A layout must never publish an incomplete (wrong) result. Doing so would cause
    /// dependent layouts to run their calculations on those wrong values, producing more wrong
    /// values and some layouts may even incorrectly flag themselves as <see cref="Ext.layout.Layout.done">done</see>
    /// before the correct values are determined and republished. Doing this will poison the
    /// calculations.</p>
    /// <p><strong>RULE 5</strong>: Each value should only be published by one layout. If multiple layouts attempt
    /// to publish the same values, it would be nearly impossible to avoid breaking <strong>RULE 4</strong>. To
    /// help detect this problem, the layout diagnostics will trap on an attempt to set a value
    /// from different layouts.</p>
    /// <p>Complex layouts can produce many results as part of their calculations. These values are
    /// important for other layouts to proceed and need to be published by the earliest possible
    /// call to <see cref="Ext.layout.Layout.calculate">Ext.layout.Layout.calculate</see> to avoid unnecessary cycles and poor performance. It is
    /// also possible, however, for some results to be related in a way such that publishing them
    /// may be an all-or-none proposition (typically to avoid breaking <em>RULE 4</em>).</p>
    /// <p><strong>RULE 6</strong>: Publish results as soon as they are known to be correct rather than wait for
    /// all values to be calculated. Waiting for everything to be complete can lead to deadlock.
    /// The key here is not to forget <strong>RULE 4</strong> in the process.</p>
    /// <p>Some layouts depend on certain critical values as part of their calculations. For example,
    /// HBox depends on width and cannot do anything until the width is known. In these cases, it
    /// is best to use <see cref="Ext.layout.ContextItem.block">block</see> or
    /// <see cref="Ext.layout.ContextItem.domBlock">domBlock</see> and thereby avoid processing the layout
    /// until the needed value is available.</p>
    /// <p><strong>RULE 7</strong>: Use <see cref="Ext.layout.ContextItem.block">block</see> or
    /// <see cref="Ext.layout.ContextItem.domBlock">domBlock</see> when values are required to make progress.
    /// This will mimize wasted recalculations.</p>
    /// <p><strong>RULE 8</strong>: Blocks should only be used when no forward progress can be made. If even one
    /// value could still be calculated, a block could result in a deadlock.</p>
    /// <p>Historically, layouts have been invoked directly by component code, sometimes in places
    /// like an <c>afterLayout</c> method for a child component. With the flexibility now available
    /// to solve complex, iterative issues, such things should be done in a responsible layout
    /// (be it component or container).</p>
    /// <p><strong>RULE 9</strong>: Use layouts to solve layout issues and don't wait for the layout to finish to
    /// perform further layouts. This is especially important now that layouts process entire
    /// component trees and not each layout in isolation.</p>
    /// <h1>Sequence Diagram</h1>
    /// <p>The simplest sequence diagram for a layout run looks roughly like this:</p>
    /// <pre><code>  Context         Layout 1     Item 1     Layout 2     Item 2
    /// |               |           |           |           |
    /// ----&gt;X--------------&gt;X           |           |           |
    /// run  X---------------|-----------|----------&gt;X           |
    /// X beginLayout   |           |           |           |
    /// X               |           |           |           |
    /// A X--------------&gt;X           |           |           |
    /// X  calculate    X----------&gt;X           |           |
    /// X             C X  getProp  |           |           |
    /// B X               X----------&gt;X           |           |
    /// X               |  setProp  |           |           |
    /// X               |           |           |           |
    /// D X---------------|-----------|----------&gt;X           |
    /// X  calculate    |           |           X----------&gt;X
    /// X               |           |           |  setProp  |
    /// E X               |           |           |           |
    /// X---------------|-----------|----------&gt;X           |
    /// X completeLayout|           |         F |           |
    /// X               |           |           |           |
    /// G X               |           |           |           |
    /// H X--------------&gt;X           |           |           |
    /// X  calculate    X----------&gt;X           |           |
    /// X             I X  getProp  |           |           |
    /// X               X----------&gt;X           |           |
    /// X               |  setProp  |           |           |
    /// J X--------------&gt;X           |           |           |
    /// X completeLayout|           |           |           |
    /// X               |           |           |           |
    /// K X--------------&gt;X           |           |           |
    /// X---------------|-----------|----------&gt;X           |
    /// X finalizeLayout|           |           |           |
    /// X               |           |           |           |
    /// L X--------------&gt;X           |           |           |
    /// X---------------|-----------|----------&gt;X           |
    /// X finishedLayout|           |           |           |
    /// X               |           |           |           |
    /// M X--------------&gt;X           |           |           |
    /// X---------------|-----------|----------&gt;X           |
    /// X notifyOwner   |           |           |           |
    /// N |               |           |           |           |
    /// -               -           -           -           -
    /// </code></pre>
    /// <p>Notes:</p>
    /// <p><strong>A.</strong> This is a call from the <see cref="Ext.layout.Context.run">run</see> method to the <see cref="Ext.layout.Context.runCycle">runCycle</see> method.
    /// Each layout in the queue will have its <see cref="Ext.layout.Layout.calculate">calculate</see>
    /// method called.</p>
    /// <p><strong>B.</strong> After each <see cref="Ext.layout.Layout.calculate">calculate</see> method is called the
    /// <see cref="Ext.layout.Layout.done">done</see> flag is checked to see if the Layout has completed.
    /// If it has completed and that layout object implements a
    /// <see cref="Ext.layout.Layout.completeLayout">completeLayout</see> method, this layout is queued to
    /// receive its call. Otherwise, the layout will be queued again unless there are blocks or
    /// triggers that govern its requeueing.</p>
    /// <p><strong>C.</strong> The call to <see cref="Ext.layout.ContextItem.getProp">getProp</see> is made to the Item
    /// and that will be tracked as a trigger (keyed by the name of the property being requested).
    /// Changes to this property will cause this layout to be requeued. The call to
    /// <see cref="Ext.layout.ContextItem.setProp">setProp</see> will place a value in the item and not
    /// directly into the DOM.</p>
    /// <p><strong>D.</strong> Call the other layouts now in the first cycle (repeat <strong>B</strong> and <strong>C</strong> for each
    /// layout).</p>
    /// <p><strong>E.</strong> After completing a cycle, if progress was made (new properties were written to
    /// the context) and if the <see cref="Ext.layout.Context.layoutQueue">layoutQueue</see> is not empty, the next cycle is run. If no
    /// progress was made or no layouts are ready to run, all buffered values are written to
    /// the DOM (a flush).</p>
    /// <p><strong>F.</strong> After flushing, any layouts that were marked as <see cref="Ext.layout.Layout.done">done</see>
    /// that also have a <see cref="Ext.layout.Layout.completeLayout">completeLayout</see> method are called.
    /// This can cause them to become no longer done (see <see cref="Ext.layout.Context.invalidate">invalidate</see>). As with
    /// <see cref="Ext.layout.Layout.calculate">calculate</see>, this is considered a "read phase" and
    /// direct DOM writes should be avoided.</p>
    /// <p><strong>G.</strong> Flushing and calling any pending <see cref="Ext.layout.Layout.completeLayout">completeLayout</see>
    /// methods will likely trigger layouts that called <see cref="Ext.layout.ContextItem.getDomProp">getDomProp</see>
    /// and unblock layouts that have called <see cref="Ext.layout.ContextItem.domBlock">domBlock</see>.
    /// These variants are used when a layout needs the value to be correct in the DOM and not
    /// simply known. If this does not cause at least one layout to enter the queue, we have a
    /// layout FAILURE. Otherwise, we continue with the next cycle.</p>
    /// <p><strong>H.</strong> Call <see cref="Ext.layout.Layout.calculate">calculate</see> on any layouts in the queue
    /// at the start of this cycle. Just a repeat of <strong>B</strong> through <strong>G</strong>.</p>
    /// <p><strong>I.</strong> Once the layout has calculated all that it is resposible for, it can leave itself
    /// in the <see cref="Ext.layout.Layout.done">done</see> state. This is the value on entry to
    /// <see cref="Ext.layout.Layout.calculate">calculate</see> and must be cleared in that call if the
    /// layout has more work to do.</p>
    /// <p><strong>J.</strong> Now that all layouts are done, flush any DOM values and
    /// <see cref="Ext.layout.Layout.completeLayout">completeLayout</see> calls. This can again cause
    /// layouts to become not done, and so we will be back on another cycle if that happens.</p>
    /// <p><strong>K.</strong> After all layouts are done, call the <see cref="Ext.layout.Layout.finalizeLayout">finalizeLayout</see>
    /// method on any layouts that have one. As with <see cref="Ext.layout.Layout.completeLayout">completeLayout</see>,
    /// this can cause layouts to become no longer done. This is less desirable than using
    /// <see cref="Ext.layout.Layout.completeLayout">completeLayout</see> because it will cause all
    /// <see cref="Ext.layout.Layout.finalizeLayout">finalizeLayout</see> methods to be called again
    /// when we think things are all wrapped up.</p>
    /// <p><strong>L.</strong> After finishing the last iteration, layouts that have a
    /// <see cref="Ext.layout.Layout.finishedLayout">finishedLayout</see> method will be called. This
    /// call will only happen once per run and cannot cause layouts to be run further.</p>
    /// <p><strong>M.</strong> After calling finahedLayout, layouts that have a
    /// <see cref="Ext.layout.Layout.notifyOwner">notifyOwner</see> method will be called. This
    /// call will only happen once per run and cannot cause layouts to be run further.</p>
    /// <p><strong>N.</strong> One last flush to make sure everything has been written to the DOM.</p>
    /// <h1>Inter-Layout Collaboration</h1>
    /// <p>Many layout problems require collaboration between multiple layouts. In some cases, this
    /// is as simple as a component's container layout providing results used by its component
    /// layout or vise-versa. A slightly more distant collaboration occurs in a box layout when
    /// stretchmax is used: the child item's component layout provides results that are consumed
    /// by the ownerCt's box layout to determine the size of the children.</p>
    /// <p>The various forms of interdependence between a container and its children are described by
    /// each components' <see cref="Ext.AbstractComponent.getSizeModel">size model</see>.</p>
    /// <p>To facilitate this collaboration, the following pairs of properties are published to the
    /// component's <see cref="Ext.layout.ContextItem">ContextItem</see>:</p>
    /// <ul>
    /// <li>width/height: These hold the final size of the component. The layout indicated by the
    /// <see cref="Ext.AbstractComponent.getSizeModel">size model</see> is responsible for setting these.</li>
    /// <li>contentWidth/contentHeight: These hold size information published by the container
    /// layout or from DOM measurement. These describe the content only. These values are
    /// used by the component layout to determine the outer width/height when that component
    /// is <see cref="Ext.AbstractComponentConfig.shrinkWrap">shrink-wrapped</see>. They are also used to
    /// determine overflow. All container layouts must publish these values for dimensions
    /// that are shrink-wrapped. If a component has raw content (not container items), the
    /// componentLayout must publish these values instead.</li>
    /// </ul>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Context : Ext.Base
    {
        /// <summary>
        /// List of layouts to perform.
        /// </summary>
        public Ext.util.Queue layoutQueue{get;set;}
        /// <summary>
        /// One of these values:
        /// <li>0 - Before run</li>
        /// <li>1 - Running</li>
        /// <li>2 - Run complete</li>
        /// Defaults to: <c>0</c>
        /// </summary>
        public JsNumber state{get;set;}
        /// <summary>
        /// Flushes any pending writes to the DOM by calling each ContextItem in the flushQueue.
        /// </summary>
        public void flush(){}
        /// <summary>
        /// Returns the ContextItem for a component.
        /// </summary>
        /// <param name="cmp">
        /// </param>
        public void getCmp(Ext.Component cmp){}
        /// <summary>
        /// Returns the ContextItem for an element.
        /// </summary>
        /// <param name="parent">
        /// </param>
        /// <param name="el">
        /// </param>
        public void getEl(ContextItem parent, Ext.dom.Element el){}
        /// <summary>
        /// Invalidates one or more components' layouts (component and container). This can be
        /// called before run to identify the components that need layout or during the run to
        /// restart the layout of a component. This is called internally to flush any queued
        /// invalidations at the start of a cycle. If called during a run, it is not expected
        /// that new components will be introduced to the layout.
        /// </summary>
        /// <param name="components"><p>An array of Components or a single Component.</p>
        /// </param>
        /// <param name="ownerCtContext"><p>The ownerCt's ContextItem.</p>
        /// </param>
        /// <param name="full"><p>True if all properties should be invalidated, otherwise only
        /// those calculated by the component should be invalidated.</p>
        /// </param>
        public void invalidate(object components, ContextItem ownerCtContext, bool full){}
        /// <summary>
        /// Queues a ContextItem to have its Ext.layout.ContextItem.flushAnimations method called.
        /// </summary>
        /// <param name="item">
        /// </param>
        private void queueAnimation(ContextItem item){}
        /// <summary>
        /// Queues a layout to have its Ext.layout.Layout.completeLayout method called.
        /// </summary>
        /// <param name="layout">
        /// </param>
        private void queueCompletion(Layout layout){}
        /// <summary>
        /// Queues a layout to have its Ext.layout.Layout.finalizeLayout method called.
        /// </summary>
        /// <param name="layout">
        /// </param>
        private void queueFinalize(Layout layout){}
        /// <summary>
        /// Queues a ContextItem for the next flush to the DOM. This should only be called by
        /// the Ext.layout.ContextItem class.
        /// </summary>
        /// <param name="item">
        /// </param>
        private void queueFlush(ContextItem item){}
        /// <summary>
        /// Queue a component (and its tree) to be invalidated on the next cycle.
        /// </summary>
        /// <param name="item"><p>The component or ContextItem to invalidate.</p>
        /// </param>
        /// <param name="options"><p>An object describing how to handle the invalidation (see
        /// <see cref="Ext.layout.ContextItem.invalidate">Ext.layout.ContextItem.invalidate</see> for details).</p>
        /// </param>
        private void queueInvalidate(object item, object options){}
        /// <summary>
        /// Queues a layout for the next calculation cycle. This should not be called if the
        /// layout is done, blocked or already in the queue. The only classes that should call
        /// this method are this class and Ext.layout.ContextItem.
        /// </summary>
        /// <param name="layout"><p>The layout to add to the queue.</p>
        /// </param>
        private void queueLayout(Layout layout){}
        /// <summary>
        /// Resets the given layout object. This is called at the start of the run and can also
        /// be called during the run by calling invalidate.
        /// </summary>
        /// <param name="layout">
        /// </param>
        /// <param name="ownerContext">
        /// </param>
        /// <param name="firstTime">
        /// </param>
        public void resetLayout(object layout, object ownerContext, object firstTime){}
        /// <summary>
        /// Runs the layout calculations. This can be called only once on this object.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if all layouts were completed, false if not.</p>
        /// </div>
        /// </returns>
        public bool run(){return false;}
        /// <summary>
        /// Performs one layout cycle by calling each layout in the layout queue.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if some progress was made, false if not.</p>
        /// </div>
        /// </returns>
        protected bool runCycle(){return false;}
        /// <summary>
        /// Runs one layout as part of a cycle.
        /// </summary>
        /// <param name="layout">
        /// </param>
        private void runLayout(object layout){}
        /// <summary>
        /// Set the size of a component, element or composite or an array of components or elements.
        /// </summary>
        /// <param name="item"><p>The item(s) to size.</p>
        /// </param>
        /// <param name="width"><p>The new width to set (ignored if undefined or NaN).</p>
        /// </param>
        /// <param name="height"><p>The new height to set (ignored if undefined or NaN).</p>
        /// </param>
        public void setItemSize(object item, JsNumber width, JsNumber height){}
        public Context(ContextConfig config){}
        public Context(){}
        public Context(params object[] args){}
    }
    #endregion
    #region ContextConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ContextConfig : Ext.BaseConfig
    {
        public ContextConfig(params object[] args){}
    }
    #endregion
    #region ContextEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ContextEvents : Ext.BaseEvents
    {
        public ContextEvents(params object[] args){}
    }
    #endregion
}
