//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.data.proxy
{
    #region JsonP
    /// <inheritdocs />
    /// <summary>
    /// <p>The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
    /// your application is running on http://domainA.com it cannot use <see cref="Ext.data.proxy.Ajax">Ajax</see> to load its data
    /// from http://domainB.com because cross-domain ajax requests are prohibited by the browser.</p>
    /// <p>We can get around this using a JsonP proxy. JsonP proxy injects a <c>&lt;script&gt;</c> tag into the DOM whenever an AJAX request
    /// would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
    /// injected might look like this:</p>
    /// <pre><code>&lt;script src="http://domainB.com/users?callback=someCallback"&gt;&lt;/script&gt;
    /// </code></pre>
    /// <p>When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
    /// other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
    /// to be notified when the result comes in and that it should call our callback function with the data it sends back. So
    /// long as the server formats the response to look like this, everything will work:</p>
    /// <pre><code>someCallback({
    /// users: [
    /// {
    /// id: 1,
    /// name: "Ed Spencer",
    /// email: "ed@sencha.com"
    /// }
    /// ]
    /// });
    /// </code></pre>
    /// <p>As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
    /// object that the server returned.</p>
    /// <p>JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
    /// automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
    /// the Proxy making it look just like you loaded it through a normal <see cref="Ext.data.proxy.Ajax">AjaxProxy</see>. Here's how
    /// we might set that up:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id', 'name', 'email']
    /// });
    /// var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// proxy: {
    /// type: 'jsonp',
    /// url : 'http://domainB.com/users'
    /// }
    /// });
    /// store.load();
    /// </code></pre>
    /// <p>That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
    /// like this:</p>
    /// <pre><code>&lt;script src="http://domainB.com/users?callback=callback1"&gt;&lt;/script&gt;
    /// </code></pre>
    /// <h1>Customization</h1>
    /// <p>This script tag can be customized using the <see cref="Ext.data.proxy.JsonPConfig.callbackKey">callbackKey</see> configuration. For example:</p>
    /// <pre><code>var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// proxy: {
    /// type: 'jsonp',
    /// url : 'http://domainB.com/users',
    /// callbackKey: 'theCallbackFunction'
    /// }
    /// });
    /// store.load();
    /// </code></pre>
    /// <p>Would inject a script tag like this:</p>
    /// <pre><code>&lt;script src="http://domainB.com/users?theCallbackFunction=callback1"&gt;&lt;/script&gt;
    /// </code></pre>
    /// <h1>Implementing on the server side</h1>
    /// <p>The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
    /// achieve this using Java, PHP and ASP.net:</p>
    /// <p>Java:</p>
    /// <pre><code>boolean jsonP = false;
    /// String cb = request.getParameter("callback");
    /// if (cb != null) {
    /// jsonP = true;
    /// response.setContentType("text/javascript");
    /// } else {
    /// response.setContentType("application/x-json");
    /// }
    /// Writer out = response.getWriter();
    /// if (jsonP) {
    /// out.write(cb + "(");
    /// }
    /// out.print(dataBlock.toJsonString());
    /// if (jsonP) {
    /// out.write(");");
    /// }
    /// </code></pre>
    /// <p>PHP:</p>
    /// <pre><code>$callback = $_REQUEST['callback'];
    /// // Create the output object.
    /// $output = array('a' =&gt; 'Apple', 'b' =&gt; 'Banana');
    /// //start output
    /// if ($callback) {
    /// header('Content-Type: text/javascript');
    /// echo $callback . '(' . json_encode($output) . ');';
    /// } else {
    /// header('Content-Type: application/x-json');
    /// echo json_encode($output);
    /// }
    /// </code></pre>
    /// <p>ASP.net:</p>
    /// <pre><code>String jsonString = "{success: true}";
    /// String cb = Request.Params.Get("callback");
    /// String responseString = "";
    /// if (!String.IsNullOrEmpty(cb)) {
    /// responseString = cb + "(" + jsonString + ")";
    /// } else {
    /// responseString = jsonString;
    /// }
    /// Response.Write(responseString);
    /// </code></pre>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class JsonP : Server
    {
        /// <summary>
        /// True to automatically append the request's params to the generated url. Defaults to true
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool autoAppendParams;
        /// <summary>
        /// See Ext.data.JsonP.callbackKey.
        /// Defaults to: <c>&quot;callback&quot;</c>
        /// </summary>
        public JsString callbackKey;
        /// <summary>
        /// The param name to use when passing records to the server (e.g. 'records=someEncodedRecordString'). Defaults to
        /// 'records'
        /// Defaults to: <c>&quot;records&quot;</c>
        /// </summary>
        public JsString recordParam;
        /// <summary>
        /// Aborts the current server request if one is currently running
        /// </summary>
        public void abort(){}
        /// <summary>
        /// Creates and returns the function that is called when the request has completed. The returned function
        /// should accept a Response object, which contains the response to be read by the configured Reader.
        /// The third argument is the callback that should be called after the request has been completed and the Reader has decoded
        /// the response. This callback will typically be the callback passed by a store, e.g. in proxy.read(operation, theCallback, scope)
        /// theCallback refers to the callback argument received by this function.
        /// See doRequest for details.
        /// </summary>
        /// <param name="request"><p>The Request object</p>
        /// </param>
        /// <param name="operation"><p>The Operation being executed</p>
        /// </param>
        /// <param name="callback"><p>The callback function to be called when the request completes. This is usually the callback
        /// passed to doRequest</p>
        /// </param>
        /// <param name="scope"><p>The scope in which to execute the callback function</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Function">Function</see></span><div><p>The callback function</p>
        /// </div>
        /// </returns>
        private System.Delegate createRequestCallback(Request request, Operation operation, System.Delegate callback, object scope){return null;}
        /// <summary>
        /// Encodes an array of records into a string suitable to be appended to the script src url. This is broken out into
        /// its own function so that it can be easily overridden.
        /// </summary>
        /// <param name="records"><p>The records array</p>
        /// </param>
        /// <returns>
        /// <span><see cref="String">String</see></span><div><p>The encoded records string</p>
        /// </div>
        /// </returns>
        public JsString encodeRecords(JsArray<Ext.data.Model> records){return null;}
        public JsonP(Ext.data.proxy.JsonPConfig config){}
        public JsonP(){}
        public JsonP(params object[] args){}
    }
    #endregion
    #region JsonPConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class JsonPConfig : ServerConfig
    {
        /// <summary>
        /// True to automatically append the request's params to the generated url. Defaults to true
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool autoAppendParams;
        /// <summary>
        /// See Ext.data.JsonP.callbackKey.
        /// Defaults to: <c>&quot;callback&quot;</c>
        /// </summary>
        public JsString callbackKey;
        /// <summary>
        /// The param name to use when passing records to the server (e.g. 'records=someEncodedRecordString'). Defaults to
        /// 'records'
        /// Defaults to: <c>&quot;records&quot;</c>
        /// </summary>
        public JsString recordParam;
        public JsonPConfig(params object[] args){}
    }
    #endregion
    #region JsonPEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class JsonPEvents : ServerEvents
    {
        public JsonPEvents(params object[] args){}
    }
    #endregion
}
