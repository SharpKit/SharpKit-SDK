//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:41 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.tip
{
    #region QuickTipManager
    /// <inheritdocs />
    /// <summary>
    /// <p>Provides attractive and customizable tooltips for any element. The QuickTips
    /// singleton is used to configure and manage tooltips globally for multiple elements
    /// in a generic manner.  To create individual tooltips with maximum customizability,
    /// you should consider either <see cref="Ext.tip.Tip">Ext.tip.Tip</see> or <see cref="Ext.tip.ToolTip">Ext.tip.ToolTip</see>.</p>
    /// <p>Quicktips can be configured via tag attributes directly in markup, or by
    /// registering quick tips programmatically via the <see cref="Ext.tip.QuickTipManager.register">register</see> method.</p>
    /// <p>The singleton's instance of <see cref="Ext.tip.QuickTip">Ext.tip.QuickTip</see> is available via
    /// <see cref="Ext.tip.QuickTipManager.getQuickTip">getQuickTip</see>, and supports all the methods, and all the all the
    /// configuration properties of <see cref="Ext.tip.QuickTip">Ext.tip.QuickTip</see>. These settings will apply to all
    /// tooltips shown by the singleton.</p>
    /// <p>Below is the summary of the configuration properties which can be used.
    /// For detailed descriptions see the config options for the
    /// <see cref="Ext.tip.QuickTip">QuickTip</see> class</p>
    /// <h2>QuickTips singleton configs (all are optional)</h2>
    /// <ul>
    /// <li><c>dismissDelay</c></li>
    /// <li><c>hideDelay</c></li>
    /// <li><c>maxWidth</c></li>
    /// <li><c>minWidth</c></li>
    /// <li><c>showDelay</c></li>
    /// <li><c>trackMouse</c></li>
    /// </ul>
    /// <h2>Target element configs (optional unless otherwise noted)</h2>
    /// <ul>
    /// <li><c>autoHide</c></li>
    /// <li><c>cls</c></li>
    /// <li><c>dismissDelay</c> (overrides singleton value)</li>
    /// <li><c>target</c> (required)</li>
    /// <li><c>text</c> (required)</li>
    /// <li><c>title</c></li>
    /// <li><c>width</c></li>
    /// </ul>
    /// <p>Here is an example showing how some of these config options could be used:</p>
    /// <pre><code>// Init the singleton.  Any tag-based quick tips will start working.
    /// <see cref="Ext.tip.QuickTipManager.init">Ext.tip.QuickTipManager.init</see>();
    /// // Apply a set of config properties to the singleton
    /// <see cref="Ext.ExtContext.apply">Ext.apply</see>(<see cref="Ext.tip.QuickTipManager.getQuickTip">Ext.tip.QuickTipManager.getQuickTip</see>(), {
    /// maxWidth: 200,
    /// minWidth: 100,
    /// showDelay: 50      // Show 50ms after entering target
    /// });
    /// // Create a small panel to add a quick tip to
    /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.container.Container">Ext.container.Container</see>', {
    /// id: 'quickTipContainer',
    /// width: 200,
    /// height: 150,
    /// style: {
    /// backgroundColor:'#000000'
    /// },
    /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>()
    /// });
    /// // Manually register a quick tip for a specific element
    /// <see cref="Ext.tip.QuickTipManager.register">Ext.tip.QuickTipManager.register</see>({
    /// target: 'quickTipContainer',
    /// title: 'My Tooltip',
    /// text: 'This tooltip was added in code',
    /// width: 100,
    /// dismissDelay: 10000 // Hide after 10 seconds hover
    /// });
    /// </code></pre>
    /// <p>To register a quick tip in markup, you simply add one or more of the valid QuickTip
    /// attributes prefixed with the <strong>data-</strong> namespace.  The HTML element itself is
    /// automatically set as the quick tip target. Here is the summary of supported attributes
    /// (optional unless otherwise noted):</p>
    /// <ul>
    /// <li><c>hide</c>: Specifying "user" is equivalent to setting autoHide = false.
    /// Any other value will be the same as autoHide = true.</li>
    /// <li><c>qclass</c>: A CSS class to be applied to the quick tip
    /// (equivalent to the 'cls' target element config).</li>
    /// <li><c>qtip (required)</c>: The quick tip text (equivalent to the 'text' target element config).</li>
    /// <li><c>qtitle</c>: The quick tip title (equivalent to the 'title' target element config).</li>
    /// <li><c>qwidth</c>: The quick tip width (equivalent to the 'width' target element config).</li>
    /// </ul>
    /// <p>Here is an example of configuring an HTML element to display a tooltip from markup:</p>
    /// <pre><code>// Add a quick tip to an HTML button
    /// &lt;input type="button" value="OK" data-qtitle="OK Button" data-qwidth="100"
    /// data-qtip="This is a quick tip from markup!"&gt;&lt;/input&gt;
    /// </code></pre>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class QuickTipManager : Ext.Base
    {
        /// <summary>
        /// Defaults to: <c>&quot;Ext.Base&quot;</c>
        /// </summary>
        [JsProperty(Name="$className")]
        private static JsString @className{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        private static JsObject configMap{get;set;}
        /// <summary>
        /// Defaults to: <c>[]</c>
        /// </summary>
        private static JsArray initConfigList{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        private static JsObject initConfigMap{get;set;}
        /// <summary>
        /// Defaults to: <c>true</c>
        /// </summary>
        private static bool isInstance{get;set;}
        /// <summary>
        /// Get the reference to the current class from which this object was instantiated. Unlike statics,
        /// this.self is scope-dependent and it's meant to be used for dynamic inheritance. See statics
        /// for a detailed comparison
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// statics: {
        /// speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        /// },
        /// constructor: function() {
        /// alert(this.self.speciesName); // dependent on 'this'
        /// },
        /// clone: function() {
        /// return new this.self();
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.SnowLeopard', {
        /// extend: 'My.Cat',
        /// statics: {
        /// speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
        /// }
        /// });
        /// var cat = new My.Cat();                     // alerts 'Cat'
        /// var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
        /// var clone = snowLeopard.clone();
        /// alert(<see cref="Ext.ExtContext.getClassName">Ext.getClassName</see>(clone));             // alerts 'My.SnowLeopard'
        /// </code>
        /// </summary>
        protected static Class self{get;set;}
        /// <summary>
        /// Call the original method that was previously overridden with override
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// constructor: function() {
        /// alert("I'm a cat!");
        /// }
        /// });
        /// My.Cat.override({
        /// constructor: function() {
        /// alert("I'm going to be a cat!");
        /// this.callOverridden();
        /// alert("Meeeeoooowwww");
        /// }
        /// });
        /// var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
        /// // alerts "I'm a cat!"
        /// // alerts "Meeeeoooowwww"
        /// </code>
        /// <p>This method has been <strong>deprecated</strong> </p>
        /// <p>as of 4.1. Use <see cref="Ext.Base.callParent">callParent</see> instead.</p>
        /// </summary>
        /// <param name="args"><p>The arguments, either an array or the <c>arguments</c> object
        /// from the current method, for example: <c>this.callOverridden(arguments)</c></p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>Returns the result of calling the overridden method</p>
        /// </div>
        /// </returns>
        protected static object callOverridden(object args=null){return null;}
        /// <summary>
        /// Call the "parent" method of the current method. That is the method previously
        /// overridden by derivation or by an override (see Ext.define).
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Base', {
        /// constructor: function (x) {
        /// this.x = x;
        /// },
        /// statics: {
        /// method: function (x) {
        /// return x;
        /// }
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived', {
        /// extend: 'My.Base',
        /// constructor: function () {
        /// this.callParent([21]);
        /// }
        /// });
        /// var obj = new My.Derived();
        /// alert(obj.x);  // alerts 21
        /// </code>
        /// This can be used with an override as follows:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.DerivedOverride', {
        /// override: 'My.Derived',
        /// constructor: function (x) {
        /// this.callParent([x*2]); // calls original My.Derived constructor
        /// }
        /// });
        /// var obj = new My.Derived();
        /// alert(obj.x);  // now alerts 42
        /// </code>
        /// This also works with static methods.
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived2', {
        /// extend: 'My.Base',
        /// statics: {
        /// method: function (x) {
        /// return this.callParent([x*2]); // calls My.Base.method
        /// }
        /// }
        /// });
        /// alert(My.Base.method(10);     // alerts 10
        /// alert(My.Derived2.method(10); // alerts 20
        /// </code>
        /// Lastly, it also works with overridden static methods.
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived2Override', {
        /// override: 'My.Derived2',
        /// statics: {
        /// method: function (x) {
        /// return this.callParent([x*2]); // calls My.Derived2.method
        /// }
        /// }
        /// });
        /// alert(My.Derived2.method(10); // now alerts 40
        /// </code>
        /// </summary>
        /// <param name="args"><p>The arguments, either an array or the <c>arguments</c> object
        /// from the current method, for example: <c>this.callParent(arguments)</c></p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>Returns the result of calling the parent method</p>
        /// </div>
        /// </returns>
        protected static object callParent(object args=null){return null;}
        /// <summary>
        /// </summary>
        private static void configClass(){}
        /// <summary>
        /// Destroys the QuickTips instance.
        /// Overrides: <see cref="Ext.Base.destroy">Ext.Base.destroy</see>
        /// </summary>
        public static void destroy(){}
        /// <summary>
        /// Disables quick tips globally.
        /// </summary>
        public static void disable(){}
        /// <summary>
        /// Enables quick tips globally.
        /// </summary>
        public static void enable(){}
        /// <summary>
        /// Parameters<li><span>name</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="name">
        /// </param>
        private static void getConfig(object name){}
        /// <summary>
        /// Returns the initial configuration passed to constructor when instantiating
        /// this class.
        /// </summary>
        /// <param name="name"><p>Name of the config option to return.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see>/Mixed</span><div><p>The full config object or a single config value
        /// when <c>name</c> parameter specified.</p>
        /// </div>
        /// </returns>
        public static object getInitialConfig(object name=null){return null;}
        /// <summary>
        /// Gets the single QuickTip instance used to show tips
        /// from all registered elements.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.tip.QuickTip">Ext.tip.QuickTip</see></span><div>
        /// </div>
        /// </returns>
        public static QuickTip getQuickTip(){return null;}
        /// <summary>
        /// Parameters<li><span>config</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="config">
        /// </param>
        private static void hasConfig(object config){}
        /// <summary>
        /// Initializes the global QuickTips instance and prepare any quick tips.
        /// </summary>
        /// <param name="autoRender"><p>True to render the QuickTips container
        /// immediately to preload images.</p>
        /// <p>Defaults to: <c>true</c></p></param>
        /// <param name="config"><p>config object for the created QuickTip. By
        /// default, the <see cref="Ext.tip.QuickTip">QuickTip</see> class is instantiated, but this can
        /// be changed by supplying an xtype property or a className property in this object.
        /// All other properties on this object are configuration for the created component.</p>
        /// </param>
        public static void init(object autoRender=null, object config=null){}
        /// <summary>
        /// Initialize configuration for this class. a typical example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.awesome.Class', {
        /// // The default config
        /// config: {
        /// name: 'Awesome',
        /// isAwesome: true
        /// },
        /// constructor: function(config) {
        /// this.initConfig(config);
        /// }
        /// });
        /// var awesome = new My.awesome.Class({
        /// name: 'Super Awesome'
        /// });
        /// alert(awesome.getName()); // 'Super Awesome'
        /// </code>
        /// </summary>
        /// <param name="config">
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Base">Ext.Base</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        protected static Ext.Base initConfig(object config){return null;}
        /// <summary>
        /// Returns true if quick tips are enabled, else false.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div>
        /// </div>
        /// </returns>
        public static bool isEnabled(){return false;}
        /// <summary>
        /// Parameters<li><span>names</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>callback</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>scope</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="names">
        /// </param>
        /// <param name="callback">
        /// </param>
        /// <param name="scope">
        /// </param>
        private static void onConfigUpdate(object names, object callback, object scope){}
        /// <summary>
        /// Configures a new quick tip instance and assigns it to a target element.  See
        /// Ext.tip.QuickTip.register for details.
        /// </summary>
        /// <param name="config"><p>The config object</p>
        /// </param>
        public static void register(object config){}
        /// <summary>
        /// Parameters<li><span>config</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>applyIfNotSet</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="config">
        /// </param>
        /// <param name="applyIfNotSet">
        /// </param>
        private static void setConfig(object config, object applyIfNotSet){}
        /// <summary>
        /// Get the reference to the class from which this object was instantiated. Note that unlike self,
        /// this.statics() is scope-independent and it always returns the class from which it was called, regardless of what
        /// this points to during run-time
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// statics: {
        /// totalCreated: 0,
        /// speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        /// },
        /// constructor: function() {
        /// var statics = this.statics();
        /// alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
        /// // equivalent to: My.Cat.speciesName
        /// alert(this.self.speciesName);   // dependent on 'this'
        /// statics.totalCreated++;
        /// },
        /// clone: function() {
        /// var cloned = new this.self;                      // dependent on 'this'
        /// cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
        /// return cloned;
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.SnowLeopard', {
        /// extend: 'My.Cat',
        /// statics: {
        /// speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
        /// },
        /// constructor: function() {
        /// this.callParent();
        /// }
        /// });
        /// var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
        /// var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
        /// var clone = snowLeopard.clone();
        /// alert(<see cref="Ext.ExtContext.getClassName">Ext.getClassName</see>(clone));         // alerts 'My.SnowLeopard'
        /// alert(clone.groupName);                 // alerts 'Cat'
        /// alert(My.Cat.totalCreated);             // alerts 3
        /// </code>
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.Class">Ext.Class</see></span><div>
        /// </div>
        /// </returns>
        protected static Class statics(){return null;}
        /// <summary>
        /// Alias of register.
        /// Configures a new quick tip instance and assigns it to a target element.  See
        /// <see cref="Ext.tip.QuickTip.register">Ext.tip.QuickTip.register</see> for details.
        /// </summary>
        /// <param name="config"><p>The config object</p>
        /// </param>
        public static void tips(object config){}
        /// <summary>
        /// Removes any registered quick tip from the target element and destroys it.
        /// </summary>
        /// <param name="el"><p>The element from which the quick tip
        /// is to be removed or ID of the element.</p>
        /// </param>
        public static void unregister(object el){}
        public QuickTipManager(QuickTipManagerConfig config){}
        public QuickTipManager(){}
        public QuickTipManager(params object[] args){}
    }
    #endregion
    #region QuickTipManagerConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class QuickTipManagerConfig : Ext.BaseConfig
    {
        public QuickTipManagerConfig(params object[] args){}
    }
    #endregion
    #region QuickTipManagerEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class QuickTipManagerEvents : Ext.BaseEvents
    {
        public QuickTipManagerEvents(params object[] args){}
    }
    #endregion
}
