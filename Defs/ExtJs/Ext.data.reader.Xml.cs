//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.data.reader
{
    #region Xml
    /// <inheritdocs />
    /// <summary>
    /// <p>The XML Reader is used by a Proxy to read a server response that is sent back in XML format. This usually happens as
    /// a result of loading a Store - for example we might create something like this:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id', 'name', 'email']
    /// });
    /// var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// proxy: {
    /// type: 'ajax',
    /// url : 'users.xml',
    /// reader: {
    /// type: 'xml',
    /// record: 'user',
    /// root: 'users'
    /// }
    /// }
    /// });
    /// </code></pre>
    /// <p>The example above creates a 'User' model. Models are explained in the <see cref="Ext.data.Model">Model</see> docs if you're not
    /// already familiar with them.</p>
    /// <p>We created the simplest type of XML Reader possible by simply telling our <see cref="Ext.data.Store">Store</see>'s <see cref="Ext.data.proxy.Proxy">Proxy</see> that we want a XML Reader. The Store automatically passes the configured model to the
    /// Store, so it is as if we passed this instead:</p>
    /// <pre><code>reader: {
    /// type : 'xml',
    /// model: 'User',
    /// record: 'user',
    /// root: 'users'
    /// }
    /// </code></pre>
    /// <p>The reader we set up is ready to read data from our server - at the moment it will accept a response like this:</p>
    /// <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    /// &lt;users&gt;
    /// &lt;user&gt;
    /// &lt;id&gt;1&lt;/id&gt;
    /// &lt;name&gt;Ed Spencer&lt;/name&gt;
    /// &lt;email&gt;ed@sencha.com&lt;/email&gt;
    /// &lt;/user&gt;
    /// &lt;user&gt;
    /// &lt;id&gt;2&lt;/id&gt;
    /// &lt;name&gt;Abe Elias&lt;/name&gt;
    /// &lt;email&gt;abe@sencha.com&lt;/email&gt;
    /// &lt;/user&gt;
    /// &lt;/users&gt;
    /// </code></pre>
    /// <p>First off there's <see cref="Ext.data.reader.XmlConfig.root">root</see> option to define the root node <c>&lt;users&gt;</c> (there should be only one in a well-formed
    /// XML document). Then the XML Reader uses the configured <see cref="Ext.data.reader.XmlConfig.record">record</see> option to pull out the data for each record -
    /// in this case we set record to 'user', so each <c>&lt;user&gt;</c> above will be converted into a User model.</p>
    /// <p>Note that XmlReader doesn't care whether your <see cref="Ext.data.reader.XmlConfig.root">root</see> and <see cref="Ext.data.reader.XmlConfig.record">record</see> elements are nested deep inside a
    /// larger structure, so a response like this will still work:</p>
    /// <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    /// &lt;deeply&gt;
    /// &lt;nested&gt;
    /// &lt;xml&gt;
    /// &lt;users&gt;
    /// &lt;user&gt;
    /// &lt;id&gt;1&lt;/id&gt;
    /// &lt;name&gt;Ed Spencer&lt;/name&gt;
    /// &lt;email&gt;ed@sencha.com&lt;/email&gt;
    /// &lt;/user&gt;
    /// &lt;user&gt;
    /// &lt;id&gt;2&lt;/id&gt;
    /// &lt;name&gt;Abe Elias&lt;/name&gt;
    /// &lt;email&gt;abe@sencha.com&lt;/email&gt;
    /// &lt;/user&gt;
    /// &lt;/users&gt;
    /// &lt;/xml&gt;
    /// &lt;/nested&gt;
    /// &lt;/deeply&gt;
    /// </code></pre>
    /// <h1>Response metadata</h1>
    /// <p>The server can return additional data in its response, such as the <see cref="Ext.data.reader.XmlConfig.totalProperty">total number of records</see> and
    /// the <see cref="Ext.data.reader.XmlConfig.successProperty">success status of the response</see>. These are typically included in the XML response like
    /// this:</p>
    /// <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    /// &lt;users&gt;
    /// &lt;total&gt;100&lt;/total&gt;
    /// &lt;success&gt;true&lt;/success&gt;
    /// &lt;user&gt;
    /// &lt;id&gt;1&lt;/id&gt;
    /// &lt;name&gt;Ed Spencer&lt;/name&gt;
    /// &lt;email&gt;ed@sencha.com&lt;/email&gt;
    /// &lt;/user&gt;
    /// &lt;user&gt;
    /// &lt;id&gt;2&lt;/id&gt;
    /// &lt;name&gt;Abe Elias&lt;/name&gt;
    /// &lt;email&gt;abe@sencha.com&lt;/email&gt;
    /// &lt;/user&gt;
    /// &lt;/users&gt;
    /// </code></pre>
    /// <p>If these properties are present in the XML response they can be parsed out by the XmlReader and used by the Store
    /// that loaded it. We can set up the names of these properties by specifying a final pair of configuration options:</p>
    /// <pre><code>reader: {
    /// type: 'xml',
    /// root: 'users',
    /// totalProperty  : 'total',
    /// successProperty: 'success'
    /// }
    /// </code></pre>
    /// <p>These final options are not necessary to make the Reader work, but can be useful when the server needs to report an
    /// error or if it needs to indicate that there is a lot of data available of which only a subset is currently being
    /// returned.</p>
    /// <h1>Response format</h1>
    /// <p><strong>Note:</strong> in order for the browser to parse a returned XML document, the Content-Type header in the HTTP response
    /// must be set to "text/xml" or "application/xml". This is very important - the XmlReader will not work correctly
    /// otherwise.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Xml : Reader
    {
        /// <summary>
        /// The DomQuery path to the repeated element which contains record information.
        /// </summary>
        public JsString record;
        /// <summary>
        /// Copy of rawData.
        /// <p>This property has been <strong>deprecated</strong> </p>
        /// <p>Will be removed in Ext JS 5.0. Use <see cref="Ext.data.reader.Xml.rawData">rawData</see> instead.</p>
        /// </summary>
        public JsObject xmlData{get;set;}
        /// <summary>
        /// Creates a function to return some particular key of data from a response. The totalProperty and
        /// successProperty are treated as special cases for type casting, everything else is just a simple selector.
        /// </summary>
        /// <param name="key">
        /// </param>
        /// <returns>
        /// <span><see cref="Function">Function</see></span><div>
        /// </div>
        /// </returns>
        private System.Delegate createAccessor(JsString key){return null;}
        /// <summary>
        /// Returns an accessor expression for the passed Field from an XML element using either the Field's mapping, or
        /// its ordinal position in the fields collsction as the index.
        /// This is used by buildExtractors to create optimized on extractor function which converts raw data into model instances.
        /// </summary>
        /// <param name="field">
        /// </param>
        /// <param name="fieldVarName">
        /// </param>
        /// <param name="dataName">
        /// </param>
        private void createFieldAccessExpression(object field, object fieldVarName, object dataName){}
        public Xml(Ext.data.reader.XmlConfig config){}
        public Xml(){}
        public Xml(params object[] args){}
    }
    #endregion
    #region XmlConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class XmlConfig : ReaderConfig
    {
        /// <summary>
        /// The DomQuery path to the repeated element which contains record information.
        /// </summary>
        public JsString record;
        public XmlConfig(params object[] args){}
    }
    #endregion
    #region XmlEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class XmlEvents : ReaderEvents
    {
        public XmlEvents(params object[] args){}
    }
    #endregion
}
