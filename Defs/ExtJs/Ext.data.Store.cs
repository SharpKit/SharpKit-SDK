//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.data
{
    #region Store
    /// <inheritdocs />
    /// <summary>
    /// <p>The Store class encapsulates a client side cache of <see cref="Ext.data.Model">Model</see> objects. Stores load data via a
    /// <see cref="Ext.data.proxy.Proxy">Proxy</see>, and also provide functions for <see cref="Ext.data.Store.sort">sorting</see>, <see cref="Ext.data.Store.filter">filtering</see>
    /// and querying the <see cref="Ext.data.Model">model</see> instances contained within it.</p>
    /// <p>Creating a Store is easy - we just tell it the Model and the Proxy to use to load and save its data:</p>
    /// <pre><code> // Set up a <see cref="Ext.data.Model">model</see> to use in our Store
    /// <see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: [
    /// {name: 'firstName', type: 'string'},
    /// {name: 'lastName',  type: 'string'},
    /// {name: 'age',       type: 'int'},
    /// {name: 'eyeColor',  type: 'string'}
    /// ]
    /// });
    /// var myStore = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// proxy: {
    /// type: 'ajax',
    /// url: '/users.json',
    /// reader: {
    /// type: 'json',
    /// root: 'users'
    /// }
    /// },
    /// autoLoad: true
    /// });
    /// </code></pre>
    /// <p>In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
    /// <see cref="Ext.data.reader.Json">JsonReader</see> to parse the response from the server into Model object - <see cref="Ext.data.reader.Json">see the docs on JsonReader</see> for details.</p>
    /// <h2>Inline data</h2>
    /// <p>Stores can also load data inline. Internally, Store converts each of the objects we pass in as <see cref="Ext.data.StoreConfig.data">data</see> into
    /// Model instances:</p>
    /// <pre><code> <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// data : [
    /// {firstName: 'Ed',    lastName: 'Spencer'},
    /// {firstName: 'Tommy', lastName: 'Maintz'},
    /// {firstName: 'Aaron', lastName: 'Conran'},
    /// {firstName: 'Jamie', lastName: 'Avins'}
    /// ]
    /// });
    /// </code></pre>
    /// <p>Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
    /// need to be processed by a <see cref="Ext.data.reader.Reader">reader</see>). If your inline data requires processing to decode
    /// the data structure, use a <see cref="Ext.data.proxy.Memory">MemoryProxy</see> instead (see the <see cref="Ext.data.proxy.Memory">MemoryProxy</see> docs for an example).</p>
    /// <p>Additional data can also be loaded locally using <see cref="Ext.data.Store.add">add</see>.</p>
    /// <h2>Dynamic Loading</h2>
    /// <p>Stores can be dynamically updated by calling the <see cref="Ext.data.Store.load">load</see> method:</p>
    /// <pre><code>store.load({
    /// params: {
    /// group: 3,
    /// type: 'user'
    /// },
    /// callback: function(records, operation, success) {
    /// // do something after the load finishes
    /// },
    /// scope: this
    /// });
    /// </code></pre>
    /// <p>Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
    /// up to do something after the loading is over.</p>
    /// <h2>Loading Nested Data</h2>
    /// <p>Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
    /// Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
    /// a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
    /// the <see cref="Ext.data.reader.Reader">Ext.data.reader.Reader</see> intro docs for a full explanation:</p>
    /// <pre><code> var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// autoLoad: true,
    /// model: "User",
    /// proxy: {
    /// type: 'ajax',
    /// url: 'users.json',
    /// reader: {
    /// type: 'json',
    /// root: 'users'
    /// }
    /// }
    /// });
    /// </code></pre>
    /// <p>Which would consume a response like this:</p>
    /// <pre><code> {
    /// "users": [{
    /// "id": 1,
    /// "name": "Ed",
    /// "orders": [{
    /// "id": 10,
    /// "total": 10.76,
    /// "status": "invoiced"
    /// },{
    /// "id": 11,
    /// "total": 13.45,
    /// "status": "shipped"
    /// }]
    /// }]
    /// }
    /// </code></pre>
    /// <p>See the <see cref="Ext.data.reader.Reader">Ext.data.reader.Reader</see> intro docs for a full explanation.</p>
    /// <h2>Filtering and Sorting</h2>
    /// <p>Stores can be sorted and filtered - in both cases either remotely or locally. The <see cref="Ext.data.Store.sorters">sorters</see> and
    /// <see cref="Ext.data.StoreConfig.filters">filters</see> are held inside <see cref="Ext.util.MixedCollection">MixedCollection</see> instances to make them easy to manage.
    /// Usually it is sufficient to either just specify sorters and filters in the Store configuration or call <see cref="Ext.data.Store.sort">sort</see>
    /// or <see cref="Ext.data.Store.filter">filter</see>:</p>
    /// <pre><code> var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// sorters: [{
    /// property: 'age',
    /// direction: 'DESC'
    /// }, {
    /// property: 'firstName',
    /// direction: 'ASC'
    /// }],
    /// filters: [{
    /// property: 'firstName',
    /// value: /Ed/
    /// }]
    /// });
    /// </code></pre>
    /// <p>The new Store will keep the configured sorters and filters in the MixedCollection instances mentioned above. By
    /// default, sorting and filtering are both performed locally by the Store - see <see cref="Ext.data.StoreConfig.remoteSort">remoteSort</see> and
    /// <see cref="Ext.data.StoreConfig.remoteFilter">remoteFilter</see> to allow the server to perform these operations instead.</p>
    /// <p>Filtering and sorting after the Store has been instantiated is also easy. Calling <see cref="Ext.data.Store.filter">filter</see> adds another filter
    /// to the Store and automatically filters the dataset (calling <see cref="Ext.data.Store.filter">filter</see> with no arguments simply re-applies all
    /// existing filters). Note that by default <see cref="Ext.data.StoreConfig.sortOnFilter">sortOnFilter</see> is set to true, which means that your sorters are
    /// automatically reapplied if using local sorting.</p>
    /// <pre><code> store.filter('eyeColor', 'Brown');
    /// </code></pre>
    /// <p>Change the sorting at any time by calling <see cref="Ext.data.Store.sort">sort</see>:</p>
    /// <pre><code> store.sort('height', 'ASC');
    /// </code></pre>
    /// <p>Note that all existing sorters will be removed in favor of the new sorter data (if <see cref="Ext.data.Store.sort">sort</see> is called with no
    /// arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
    /// ones, just add them to the MixedCollection:</p>
    /// <pre><code> store.sorters.add(new <see cref="Ext.util.Sorter">Ext.util.Sorter</see>({
    /// property : 'shoeSize',
    /// direction: 'ASC'
    /// }));
    /// store.sort();
    /// </code></pre>
    /// <h2>Registering with StoreManager</h2>
    /// <p>Any Store that is instantiated with a <see cref="Ext.data.StoreConfig.storeId">storeId</see> will automatically be registed with the <see cref="Ext.data.StoreManager">StoreManager</see>. This makes it easy to reuse the same store in multiple views:</p>
    /// <pre><code> //this store can be used several times
    /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// storeId: 'usersStore'
    /// });
    /// new Ext.List({
    /// store: 'usersStore',
    /// //other config goes here
    /// });
    /// new <see cref="Ext.view.View">Ext.view.View</see>({
    /// store: 'usersStore',
    /// //other config goes here
    /// });
    /// </code></pre>
    /// <h2>Further Reading</h2>
    /// <p>Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
    /// pieces and how they fit together, see:</p>
    /// <ul>
    /// <li><see cref="Ext.data.proxy.Proxy">Proxy</see> - overview of what Proxies are and how they are used</li>
    /// <li><see cref="Ext.data.Model">Model</see> - the core class in the data package</li>
    /// <li><see cref="Ext.data.reader.Reader">Reader</see> - used by any subclass of <see cref="Ext.data.proxy.Server">ServerProxy</see> to read a response</li>
    /// </ul>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Store : AbstractStore
    {
        /// <summary>
        /// Allows the Store to prefetch and cache in a page cache, pages of Records, and to then satisfy
        /// loading requirements from this page cache.
        /// To use buffered Stores, initiate the process by loading the first page. The number of rows rendered are
        /// determined automatically, and the range of pages needed to keep the cache primed for scrolling is
        /// requested and cached.
        /// Example:
        /// // Load page 1
        /// myStore.loadPage(1);
        /// A <see cref="Ext.grid.PagingScroller">PagingScroller</see> is instantiated which will monitor the scrolling in the grid, and
        /// refresh the view's rows from the page cache as needed. It will also pull new data into the page
        /// cache when scrolling of the view draws upon data near either end of the prefetched data.
        /// The margins which trigger view refreshing from the prefetched data are <see cref="Ext.grid.PagingScrollerConfig.numFromEdge">Ext.grid.PagingScroller.numFromEdge</see>,
        /// <see cref="Ext.grid.PagingScrollerConfig.leadingBufferZone">Ext.grid.PagingScroller.leadingBufferZone</see> and <see cref="Ext.grid.PagingScrollerConfig.trailingBufferZone">Ext.grid.PagingScroller.trailingBufferZone</see>.
        /// The margins which trigger loading more data into the page cache are, <see cref="Ext.data.StoreConfig.leadingBufferZone">leadingBufferZone</see> and
        /// <see cref="Ext.data.StoreConfig.trailingBufferZone">trailingBufferZone</see>.
        /// By defult, only 5 pages of data are cached in the page cache, with pages "scrolling" out of the buffer
        /// as the view moves down through the dataset.
        /// Setting this value to zero means that no pages are <em>ever</em> scrolled out of the page cache, and
        /// that eventually the whole dataset may become present in the page cache. This is sometimes desirable
        /// as long as datasets do not reach astronomical proportions.
        /// Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
        /// records from its collection when those Records cycle out of the Store's primary collection. This is done
        /// by configuring the SelectionModel like this:
        /// selModel: {
        /// <code>   pruneRemoved: false
        /// </code>
        /// }
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool buffered;
        /// <summary>
        /// True to empty the store when loading another page via loadPage,
        /// nextPage or previousPage. Setting to false keeps existing records, allowing
        /// large data sets to be loaded one page at a time but rendered all together.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool clearOnPageLoad;
        /// <summary>
        /// True to clear anything in the removed record collection when the store loads.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool clearRemovedOnLoad;
        /// <summary>
        /// The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
        /// Defaults to: <c>&quot;ASC&quot;</c>
        /// </summary>
        public JsString groupDir;
        /// <summary>
        /// The field by which to group data in the store. Internally, grouping is very similar to sorting - the
        /// groupField and groupDir are injected as the first sorter (see sort). Stores support a single
        /// level of grouping, and groups can be fetched via the getGroups method.
        /// </summary>
        public JsString groupField;
        /// <summary>
        /// When buffered, the number of extra rows to keep cached on the leading side of scrolling buffer
        /// as scrolling proceeds. A larger number means fewer replenishments from the server.
        /// Defaults to: <c>200</c>
        /// </summary>
        public JsNumber leadingBufferZone;
        /// <summary>
        /// The number of records considered to form a 'page'. This is used to power the built-in
        /// paging using the nextPage and previousPage functions when the grid is paged using a
        /// PagingScroller Defaults to 25.
        /// If this Store is <see cref="Ext.data.StoreConfig.buffered">buffered</see>, pages are loaded into a page cache before the Store's
        /// data is updated from the cache. The pageSize is the number of rows loaded into the cache in one request.
        /// This will not affect the rendering of a buffered grid, but a larger page size will mean fewer loads.
        /// In a buffered grid, scrolling is monitored, and the page cache is kept primed with data ahead of the
        /// direction of scroll to provide rapid access to data when scrolling causes it to be required. Several pages
        /// in advance may be requested depending on various parameters.
        /// It is recommended to tune the <see cref="Ext.data.StoreConfig.pageSize">pageSize</see>, <see cref="Ext.data.StoreConfig.trailingBufferZone">trailingBufferZone</see> and
        /// <see cref="Ext.data.StoreConfig.leadingBufferZone">leadingBufferZone</see> configurations based upon the conditions pertaining in your deployed application.
        /// The provided SDK example <c>examples/grid/infinite-scroll-grid-tuner.html</c> can be used to experiment with
        /// different settings including simulating Ajax latency.
        /// </summary>
        public JsNumber pageSize;
        /// <summary>
        /// Valid only when used with a buffered Store.
        /// The number of pages <em>additional to the required buffered range</em> to keep in the prefetch cache before purging least recently used records.
        /// For example, if the height of the view area and the configured <see cref="Ext.data.StoreConfig.trailingBufferZone">trailingBufferZone</see> and <see cref="Ext.data.StoreConfig.leadingBufferZone">leadingBufferZone</see> require that there
        /// are three pages in the cache, then a <c>purgePageCount</c> of 5 ensures that up to 8 pages can be in the page cache any any one time.
        /// A value of 0 indicates to never purge the prefetched data.
        /// Defaults to: <c>5</c>
        /// </summary>
        public JsNumber purgePageCount;
        /// <summary>
        /// True if the grouping should apply on the server side, false if it is local only.  If the
        /// grouping is local, it can be applied immediately to the data.  If it is remote, then it will simply act as a
        /// helper, automatically sending the grouping information to the server.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool remoteGroup;
        /// <summary>
        /// For local filtering only, causes sort to be called whenever filter is called,
        /// causing the sorters to be reapplied after filtering. Defaults to true
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool sortOnFilter;
        /// <summary>
        /// When buffered, the number of extra records to keep cached on the trailing side of scrolling buffer
        /// as scrolling proceeds. A larger number means fewer replenishments from the server.
        /// Defaults to: <c>25</c>
        /// </summary>
        public JsNumber trailingBufferZone;
        /// <summary>
        /// The page that the Store has most recently loaded (see loadPage)
        /// Defaults to: <c>1</c>
        /// </summary>
        public JsNumber currentPage{get;set;}
        /// <summary>
        /// The MixedCollection that holds this store's local cache of records.
        /// </summary>
        public Ext.util.MixedCollection data{get;set;}
        /// <summary>
        /// The collection of Groupers currently applied to this Store.
        /// </summary>
        public Ext.util.MixedCollection groupers{get;set;}
        /// <summary>
        /// True if the Store is currently loading via its Proxy
        /// Defaults to: <c>false</c>
        /// </summary>
        private bool loading{get;set;}
        /// <summary>
        /// Internal PageMap instance.
        /// </summary>
        private Ext.data.Store.PageMap pageMap{get;set;}
        /// <summary>
        /// A pristine (unfiltered) collection of the records in this store. This is used to reinstate
        /// records when a filter is removed or changed
        /// </summary>
        public Ext.util.MixedCollection snapshot{get;set;}
        /// <summary>
        /// Creates the store.
        /// </summary>
        /// <param name="config"><p>Config object</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public Store(object config=null){}
        /// <summary>
        /// Adds Model instance to the Store. This method accepts either:
        /// <li>An array of Model instances or Model configuration objects.</li>
        /// <li>Any number of Model instance or Model configuration object arguments.</li>
        /// The new Model instances will be added at the end of the existing collection.
        /// Sample usage:
        /// <code>myStore.add({some: 'data'}, {some: 'other data'});
        /// </code>
        /// Note that if this Store is sorted, the new Model instances will be inserted
        /// at the correct point in the Store to maintain the sort order.
        /// </summary>
        /// <param name="model"><p>An array of Model instances
        /// or Model configuration objects, or variable number of Model instance or config arguments.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see>[]</span><div><p>The model instances that were added</p>
        /// </div>
        /// </returns>
        public Ext.data.Model[] add(params object[] model){return null;}
        /// <summary>
        /// (Local sort only) Inserts the passed Record into the Store at the index where it
        /// should go based on the current sort information.
        /// </summary>
        /// <param name="record">
        /// </param>
        public void addSorted(object record){}
        /// <summary>
        /// Runs the aggregate function for all the records in the store.
        /// When store is filtered, only items within the filter are aggregated.
        /// </summary>
        /// <param name="fn"><p>The function to execute. The function is called with a single parameter,
        /// an array of records for that group.</p>
        /// </param>
        /// <param name="scope"><p>The scope to execute the function in. Defaults to the store.</p>
        /// </param>
        /// <param name="grouped"><p>True to perform the operation for each group
        /// in the store. The value returned will be an object literal with the key being the group
        /// name and the group average being the value. The grouped parameter is only honored if
        /// the store has a groupField.</p>
        /// </param>
        /// <param name="args"><p>Any arguments to append to the function call</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>An object literal with the group names and their appropriate values.</p>
        /// </div>
        /// </returns>
        public object aggregate(System.Delegate fn, object scope=null, object grouped=null, object args=null){return null;}
        /// <summary>
        /// Gets the average value in the store.
        /// When store is filtered, only items within the filter are aggregated.
        /// </summary>
        /// <param name="field"><p>The field in each record</p>
        /// </param>
        /// <param name="grouped"><p>True to perform the operation for each group
        /// in the store. The value returned will be an object literal with the key being the group
        /// name and the group average being the value. The grouped parameter is only honored if
        /// the store has a groupField.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The average value, if no items exist, 0.</p>
        /// </div>
        /// </returns>
        public object average(JsString field, object grouped=null){return null;}
        /// <summary>
        /// Caches the records in the prefetch and stripes them with their server-side
        /// index.
        /// </summary>
        /// <param name="records"><p>The records to cache</p>
        /// </param>
        /// <param name="The"><p>associated operation</p>
        /// </param>
        private void cachePage(JsArray<Ext.data.Model> records, Operation The){}
        /// <summary>
        /// Cancels all pending prefetch requests.
        /// This is called when the page map is cleared.
        /// Any requests which still make it through will be for the previous page map generation
        /// (generation is incremented upon clear), and so will be rejected upon arrival.
        /// </summary>
        private void cancelAllPrefetches(){}
        /// <summary>
        /// Reverts to a view of the Record cache with no filtering applied.
        /// </summary>
        /// <param name="suppressEvent"><p>If <c>true</c> the filter is cleared silently.</p>
        /// <p>For a locally filtered Store, this means that the filter collection is cleared without firing the
        /// <see cref="Ext.data.StoreEvents.datachanged">datachanged</see> event.</p>
        /// <p>For a remotely filtered Store, this means that the filter collection is cleared, but the store
        /// is not reloaded from the server.</p>
        /// </param>
        public void clearFilter(object suppressEvent=null){}
        /// <summary>
        /// Clear any groupers in the store
        /// </summary>
        public void clearGrouping(){}
        /// <summary>
        /// Collects unique values for a particular dataIndex from this store.
        /// </summary>
        /// <param name="dataIndex"><p>The property to collect</p>
        /// </param>
        /// <param name="allowNull"><p>Pass true to allow null, undefined or empty string values</p>
        /// </param>
        /// <param name="bypassFilter"><p>Pass true to collect from all records, even ones which are filtered.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see>[]</span><div><p>An array of the unique values</p>
        /// </div>
        /// </returns>
        public object[] collect(JsString dataIndex, object allowNull=null, object bypassFilter=null){return null;}
        /// <summary>
        /// Commits all Records with outstanding changes. To handle updates for changes,
        /// subscribe to the Store's update event, and perform updating when the third parameter is
        /// Ext.data.Record.COMMIT.
        /// </summary>
        public void commitChanges(){}
        /// <summary>
        /// Gets the count of items in the store.
        /// When store is filtered, only items within the filter are counted.
        /// </summary>
        /// <param name="grouped"><p>True to perform the operation for each group
        /// in the store. The value returned will be an object literal with the key being the group
        /// name and the count for each group being the value. The grouped parameter is only honored if
        /// the store has a groupField.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>the count</p>
        /// </div>
        /// </returns>
        public JsNumber count(object grouped=null){return null;}
        /// <summary>
        /// Returns a filter function used to test a the given property's value. Defers most of the work to
        /// Ext.util.MixedCollection's createValueMatcher function.
        /// </summary>
        /// <param name="property"><p>The property to create the filter function for</p>
        /// </param>
        /// <param name="value"><p>The string/regex to compare the property value to</p>
        /// </param>
        /// <param name="anyMatch"><p>True if we don't care if the filter value is not the full value.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="caseSensitive"><p>True to create a case-sensitive regex.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="exactMatch"><p>True to force exact match (^ and $ characters added to the regex).
        /// Ignored if anyMatch is true.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        private void createFilterFn(JsString property, object value, object anyMatch=null, object caseSensitive=null, object exactMatch=null){}
        /// <summary>
        /// Converts a literal to a model, if it's not a model already
        /// </summary>
        /// <param name="record"><p>The record to create</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see></span><div>
        /// </div>
        /// </returns>
        private Ext.data.Model createModel(object record){return null;}
        /// <summary>
        /// Normalizes an array of grouper objects, ensuring that they are all Ext.util.Grouper instances
        /// </summary>
        /// <param name="groupers"><p>The groupers array</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.util.Grouper">Ext.util.Grouper</see>[]</span><div><p>Array of <see cref="Ext.util.Grouper">Ext.util.Grouper</see> objects</p>
        /// </div>
        /// </returns>
        private Ext.util.Grouper[] decodeGroupers(JsArray<Object> groupers){return null;}
        /// <summary>
        /// Calls the specified function for each record in the store.
        /// When store is filtered, only loops over the filtered records.
        /// </summary>
        /// <param name="fn"><p>The function to call. The <see cref="Ext.data.Model">Record</see> is passed as the first parameter.
        /// Returning <c>false</c> aborts and exits the iteration.</p>
        /// </param>
        /// <param name="scope"><p>The scope (this reference) in which the function is executed.
        /// Defaults to the current <see cref="Ext.data.Model">record</see> in the iteration.</p>
        /// </param>
        public void each(System.Delegate fn, object scope=null){}
        /// <summary>
        /// Filters the loaded set of records by a given set of filters.
        /// By default, the passed filter(s) are <em>added</em> to the collection of filters being used to filter this Store.
        /// To remove existing filters before applying a new set of filters use
        /// <code>// Clear the filter collection without updating the UI
        /// store.clearFilter(true);
        /// </code>
        /// see <see cref="Ext.data.Store.clearFilter">clearFilter</see>.
        /// Alternatively, if filters are configured with an <c>id</c>, then existing filters store may be <em>replaced</em> by new
        /// filters having the same <c>id</c>.
        /// Filtering by single field:
        /// <code>store.filter("email", /\.com$/);
        /// </code>
        /// Using multiple filters:
        /// <code>store.filter([
        /// {property: "email", value: /\.com$/},
        /// {filterFn: function(item) { return item.get("age") &gt; 10; }}
        /// ]);
        /// </code>
        /// Using <see cref="Ext.util.Filter">Ext.util.Filter</see> instances instead of config objects
        /// (note that we need to specify the <see cref="Ext.util.FilterConfig.root">root</see> config option in this case):
        /// <code>store.filter([
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.util.Filter">Ext.util.Filter</see>', {property: "email", value: /\.com$/, root: 'data'}),
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.util.Filter">Ext.util.Filter</see>', {filterFn: function(item) { return item.get("age") &gt; 10; }, root: 'data'})
        /// ]);
        /// </code>
        /// When store is filtered, most of the methods for accessing store data will be working only
        /// within the set of filtered records. Two notable exceptions are <see cref="Ext.data.Store.queryBy">queryBy</see> and
        /// <see cref="Ext.data.Store.getById">getById</see>.
        /// </summary>
        /// <param name="filters"><p>The set of filters to apply to the data.
        /// These are stored internally on the store, but the filtering itself is done on the Store's
        /// <see cref="Ext.util.MixedCollection">MixedCollection</see>. See MixedCollection's
        /// <see cref="Ext.util.MixedCollection.filter">filter</see> method for filter syntax.
        /// Alternatively, pass in a property string</p>
        /// </param>
        /// <param name="value"><p>value to filter by (only if using a property string as the first argument)</p>
        /// </param>
        public void filter(object filters, object value=null){}
        /// <summary>
        /// Filters by a function. The specified function will be called for each
        /// Record in this Store. If the function returns true the Record is included,
        /// otherwise it is filtered out.
        /// When store is filtered, most of the methods for accessing store data will be working only
        /// within the set of filtered records. Two notable exceptions are <see cref="Ext.data.Store.queryBy">queryBy</see> and
        /// <see cref="Ext.data.Store.getById">getById</see>.
        /// </summary>
        /// <param name="fn"><p>The function to be called. It will be passed the following parameters:</p>
        /// <h3>Parameters</h3><ul><li><span>record</span> : <see cref="Ext.data.Model">Ext.data.Model</see><div><p>The record to test for filtering. Access field values
        /// using <see cref="Ext.data.Model.get">Ext.data.Model.get</see>.</p>
        /// </div></li><li><span>id</span> : <see cref="Object">Object</see><div><p>The ID of the Record passed.</p>
        /// </div></li></ul></param>
        /// <param name="scope"><p>The scope (this reference) in which the function is executed.
        /// Defaults to this Store.</p>
        /// </param>
        public void filterBy(System.Delegate fn, object scope=null){}
        /// <summary>
        /// Finds the index of the first matching Record in this store by a specific field value.
        /// When store is filtered, finds records only within filter.
        /// </summary>
        /// <param name="fieldName"><p>The name of the Record field to test.</p>
        /// </param>
        /// <param name="value"><p>Either a string that the field value
        /// should begin with, or a RegExp to test against the field.</p>
        /// </param>
        /// <param name="startIndex"><p>The index to start searching at</p>
        /// <p>Defaults to: <c>0</c></p></param>
        /// <param name="anyMatch"><p>True to match any part of the string, not just the beginning</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="caseSensitive"><p>True for case sensitive comparison</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="exactMatch"><p>True to force exact match (^ and $ characters added to the regex).</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The matched index or -1</p>
        /// </div>
        /// </returns>
        public JsNumber find(JsString fieldName, object value, object startIndex=null, object anyMatch=null, object caseSensitive=null, object exactMatch=null){return null;}
        /// <summary>
        /// Find the index of the first matching Record in this Store by a function.
        /// If the function returns true it is considered a match.
        /// When store is filtered, finds records only within filter.
        /// </summary>
        /// <param name="fn"><p>The function to be called. It will be passed the following parameters:</p>
        /// <h3>Parameters</h3><ul><li><span>record</span> : <see cref="Ext.data.Model">Ext.data.Model</see><div><p>The record to test for filtering. Access field values
        /// using <see cref="Ext.data.Model.get">Ext.data.Model.get</see>.</p>
        /// </div></li><li><span>id</span> : <see cref="Object">Object</see><div><p>The ID of the Record passed.</p>
        /// </div></li></ul></param>
        /// <param name="scope"><p>The scope (this reference) in which the function is executed.
        /// Defaults to this Store.</p>
        /// </param>
        /// <param name="startIndex"><p>The index to start searching at</p>
        /// <p>Defaults to: <c>0</c></p></param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The matched index or -1</p>
        /// </div>
        /// </returns>
        public JsNumber findBy(System.Delegate fn, object scope=null, object startIndex=null){return null;}
        /// <summary>
        /// Finds the index of the first matching Record in this store by a specific field value.
        /// When store is filtered, finds records only within filter.
        /// </summary>
        /// <param name="fieldName"><p>The name of the Record field to test.</p>
        /// </param>
        /// <param name="value"><p>The value to match the field against.</p>
        /// </param>
        /// <param name="startIndex"><p>The index to start searching at</p>
        /// <p>Defaults to: <c>0</c></p></param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The matched index or -1</p>
        /// </div>
        /// </returns>
        public JsNumber findExact(JsString fieldName, object value, object startIndex=null){return null;}
        /// <summary>
        /// Finds the first matching Record in this store by a specific field value.
        /// When store is filtered, finds records only within filter.
        /// </summary>
        /// <param name="fieldName"><p>The name of the Record field to test.</p>
        /// </param>
        /// <param name="value"><p>Either a string that the field value
        /// should begin with, or a RegExp to test against the field.</p>
        /// </param>
        /// <param name="startIndex"><p>The index to start searching at</p>
        /// <p>Defaults to: <c>0</c></p></param>
        /// <param name="anyMatch"><p>True to match any part of the string, not just the beginning</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="caseSensitive"><p>True for case sensitive comparison</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="exactMatch"><p>True to force exact match (^ and $ characters added to the regex).</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see></span><div><p>The matched record or null</p>
        /// </div>
        /// </returns>
        public Ext.data.Model findRecord(JsString fieldName, object value, object startIndex=null, object anyMatch=null, object caseSensitive=null, object exactMatch=null){return null;}
        /// <summary>
        /// Fires the groupchange event. Abstracted out so we can use it
        /// as a callback
        /// </summary>
        private void fireGroupChange(){}
        /// <summary>
        /// Convenience function for getting the first model instance in the store.
        /// When store is filtered, will return first item within the filter.
        /// </summary>
        /// <param name="grouped"><p>True to perform the operation for each group
        /// in the store. The value returned will be an object literal with the key being the group
        /// name and the first record being the value. The grouped parameter is only honored if
        /// the store has a groupField.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see>/undefined</span><div><p>The first model instance in the store, or undefined</p>
        /// </div>
        /// </returns>
        public object first(object grouped=null){return null;}
        /// <summary>
        /// Get the Record at the specified index.
        /// The index is effected by filtering.
        /// </summary>
        /// <param name="index"><p>The index of the Record to find.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see></span><div><p>The Record at the passed index. Returns undefined if not found.</p>
        /// </div>
        /// </returns>
        public Ext.data.Model getAt(JsNumber index){return null;}
        /// <summary>
        /// Get the Record with the specified id.
        /// This method is not effected by filtering, lookup will be performed from all records
        /// inside the store, filtered or not.
        /// </summary>
        /// <param name="id"><p>The id of the Record to find.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see></span><div><p>The Record with the passed id. Returns null if not found.</p>
        /// </div>
        /// </returns>
        public Ext.data.Model getById(object id){return null;}
        /// <summary>
        /// Gets the number of records in store.
        /// If using paging, this may not be the total size of the dataset. If the data object
        /// used by the Reader contains the dataset size, then the <see cref="Ext.data.Store.getTotalCount">getTotalCount</see> function returns
        /// the dataset size.  <strong>Note</strong>: see the Important note in <see cref="Ext.data.Store.load">load</see>.
        /// When store is filtered, it's the number of records matching the filter.
        /// </summary>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The number of Records in the Store.</p>
        /// </div>
        /// </returns>
        public JsNumber getCount(){return null;}
        /// <summary>
        /// Returns records grouped by the configured grouper configuration. Sample return value (in
        /// this case grouping by genre and then author in a fictional books dataset):
        /// <code>[
        /// {
        /// name: 'Fantasy',
        /// depth: 0,
        /// records: [
        /// //book1, book2, book3, book4
        /// ],
        /// children: [
        /// {
        /// name: 'Rowling',
        /// depth: 1,
        /// records: [
        /// //book1, book2
        /// ]
        /// },
        /// {
        /// name: 'Tolkein',
        /// depth: 1,
        /// records: [
        /// //book3, book4
        /// ]
        /// }
        /// ]
        /// }
        /// ]
        /// </code>
        /// </summary>
        /// <param name="sort"><p>True to call <see cref="Ext.data.Store.sort">sort</see> before finding groups. Sorting is required to make grouping
        /// function correctly so this should only be set to false if the Store is known to already be sorted correctly.</p>
        /// <p>Defaults to: <c>true</c></p></param>
        /// <returns>
        /// <span><see cref="Object">Object</see>[]</span><div><p>The group data</p>
        /// </div>
        /// </returns>
        private object[] getGroupData(object sort=null){return null;}
        /// <summary>
        /// Returns the string to group on for a given model instance. The default implementation of this method returns
        /// the model's groupField, but this can be overridden to group by an arbitrary string. For example, to
        /// group by the first letter of a model's 'name' field, use the following code:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
        /// groupDir: 'ASC',
        /// getGroupString: function(instance) {
        /// return instance.get('name')[0];
        /// }
        /// });
        /// </code>
        /// </summary>
        /// <param name="instance"><p>The model instance</p>
        /// </param>
        /// <returns>
        /// <span><see cref="String">String</see></span><div><p>The string to compare when forming groups</p>
        /// </div>
        /// </returns>
        public JsString getGroupString(Ext.data.Model instance){return null;}
        /// <summary>
        /// Returns an array containing the result of applying grouping to the records in this store.
        /// See groupField, groupDir and getGroupString. Example for a store
        /// containing records with a color field:
        /// <code>var myStore = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
        /// groupField: 'color',
        /// groupDir  : 'DESC'
        /// });
        /// myStore.getGroups(); // returns:
        /// [
        /// {
        /// name: 'yellow',
        /// children: [
        /// // all records where the color field is 'yellow'
        /// ]
        /// },
        /// {
        /// name: 'red',
        /// children: [
        /// // all records where the color field is 'red'
        /// ]
        /// }
        /// ]
        /// </code>
        /// Group contents are effected by filtering.
        /// </summary>
        /// <param name="groupName"><p>Pass in an optional groupName argument to access a specific
        /// group as defined by <see cref="Ext.data.Store.getGroupString">getGroupString</see>.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see>/<see cref="Object">Object</see>[]</span><div><p>The grouped data</p>
        /// </div>
        /// </returns>
        public object[] getGroups(object groupName=null){return null;}
        /// <summary>
        /// For a given set of records and a Grouper, returns an array of arrays - each of which is the set of records
        /// matching a certain group.
        /// </summary>
        /// <param name="records">
        /// </param>
        /// <param name="grouper">
        /// </param>
        private void getGroupsForGrouper(object records, object grouper){}
        /// <summary>
        /// This is used recursively to gather the records into the configured Groupers. The data MUST have been sorted for
        /// this to work properly (see getGroupData and getGroupsForGrouper) Most of the work is done by
        /// getGroupsForGrouper - this function largely just handles the recursion.
        /// </summary>
        /// <param name="records"><p>The set or subset of records to group</p>
        /// </param>
        /// <param name="grouperIndex"><p>The grouper index to retrieve</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see>[]</span><div><p>The grouped records</p>
        /// </div>
        /// </returns>
        private object[] getGroupsForGrouperIndex(JsArray<Ext.data.Model> records, JsNumber grouperIndex){return null;}
        /// <summary>
        /// Determines the page from a record index
        /// </summary>
        /// <param name="index"><p>The record index</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The page the record belongs to</p>
        /// </div>
        /// </returns>
        public JsNumber getPageFromRecordIndex(JsNumber index){return null;}
        /// <summary>
        /// Returns a range of Records between specified indices.
        /// This method is effected by filtering.
        /// </summary>
        /// <param name="startIndex"><p>The starting index</p>
        /// <p>Defaults to: <c>0</c></p></param>
        /// <param name="endIndex"><p>The ending index. Defaults to the last Record in the Store.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see>[]</span><div><p>An array of Records</p>
        /// </div>
        /// </returns>
        public Ext.data.Model[] getRange(object startIndex=null, object endIndex=null){return null;}
        /// <summary>
        /// Returns the total number of Model instances that the Proxy
        /// indicates exist. This will usually differ from getCount when using paging - getCount returns the
        /// number of records loaded into the Store at the moment, getTotalCount returns the number of records that
        /// could be loaded into the Store if the Store contained all data
        /// </summary>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The total number of Model instances available via the Proxy. 0 returned if
        /// no value has been set via the reader.</p>
        /// </div>
        /// </returns>
        public JsNumber getTotalCount(){return null;}
        /// <summary>
        /// Groups data inside the store.
        /// </summary>
        /// <param name="groupers"><p>Either a string name of one of the fields in this Store's
        /// configured <see cref="Ext.data.Model">Model</see>, or an Array of grouper configurations.</p>
        /// </param>
        /// <param name="direction"><p>The overall direction to group the data by.</p>
        /// <p>Defaults to: <c>&quot;ASC&quot;</c></p></param>
        public void group(object groupers, object direction=null){}
        /// <summary>
        /// Guarantee a specific range, this will load the store with a range (that
        /// must be the pageSize or smaller) and take care of any loading that may
        /// be necessary.
        /// </summary>
        /// <param name="start">
        /// </param>
        /// <param name="end">
        /// </param>
        /// <param name="cb">
        /// </param>
        /// <param name="scope">
        /// </param>
        public void guaranteeRange(object start, object end, object cb=null, object scope=null){}
        /// <summary>
        /// Get the index of the record within the store.
        /// When store is filtered, records outside of filter will not be found.
        /// </summary>
        /// <param name="record"><p>The <see cref="Ext.data.Model">Ext.data.Model</see> object to find.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The index of the passed Record. Returns -1 if not found.</p>
        /// </div>
        /// </returns>
        public JsNumber indexOf(Ext.data.Model record){return null;}
        /// <summary>
        /// Get the index within the store of the Record with the passed id.
        /// Like <see cref="Ext.data.Store.indexOf">indexOf</see>, this method is effected by filtering.
        /// </summary>
        /// <param name="id"><p>The id of the Record to find.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The index of the Record. Returns -1 if not found.</p>
        /// </div>
        /// </returns>
        public JsNumber indexOfId(JsString id){return null;}
        /// <summary>
        /// Get the index within the entire dataset. From 0 to the totalCount.
        /// Like <see cref="Ext.data.Store.indexOf">indexOf</see>, this method is effected by filtering.
        /// </summary>
        /// <param name="record"><p>The <see cref="Ext.data.Model">Ext.data.Model</see> object to find.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The index of the passed Record. Returns -1 if not found.</p>
        /// </div>
        /// </returns>
        public JsNumber indexOfTotal(Ext.data.Model record){return null;}
        /// <summary>
        /// Inserts Model instances into the Store at the given index and fires the add event.
        /// See also add.
        /// </summary>
        /// <param name="index"><p>The start index at which to insert the passed Records.</p>
        /// </param>
        /// <param name="records"><p>An Array of <see cref="Ext.data.Model">Ext.data.Model</see> objects to add to the store.</p>
        /// </param>
        public void insert(JsNumber index, JsArray<Ext.data.Model> records){}
        /// <summary>
        /// Returns true if this store is currently filtered
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div>
        /// </div>
        /// </returns>
        public bool isFiltered(){return false;}
        /// <summary>
        /// Checks if the store is currently grouped
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if the store is grouped.</p>
        /// </div>
        /// </returns>
        public bool isGrouped(){return false;}
        /// <summary>
        /// Convenience function for getting the last model instance in the store.
        /// When store is filtered, will return last item within the filter.
        /// </summary>
        /// <param name="grouped"><p>True to perform the operation for each group
        /// in the store. The value returned will be an object literal with the key being the group
        /// name and the last record being the value. The grouped parameter is only honored if
        /// the store has a groupField.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see>/undefined</span><div><p>The last model instance in the store, or undefined</p>
        /// </div>
        /// </returns>
        public object last(object grouped=null){return null;}
        /// <summary>
        /// Loads an array of data straight into the Store.
        /// Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
        /// processed by a reader). If your data requires processing to decode the data structure, use a
        /// <see cref="Ext.data.proxy.Memory">MemoryProxy</see> instead.
        /// </summary>
        /// <param name="data"><p>Array of data to load. Any non-model instances will be cast
        /// into model instances first.</p>
        /// </param>
        /// <param name="append"><p>True to add the records to the existing records in the store, false
        /// to remove the old ones first.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        public void loadData(object data, object append=null){}
        /// <summary>
        /// Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
        /// load operation, passing in calculated 'start' and 'limit' params
        /// </summary>
        /// <param name="page"><p>The number of the page to load</p>
        /// </param>
        /// <param name="options"><p>See options for <see cref="Ext.data.Store.load">load</see></p>
        /// </param>
        public void loadPage(JsNumber page, object options=null){}
        /// <summary>
        /// Loads data via the bound Proxy's reader
        /// Use this method if you are attempting to load data and want to utilize the configured data reader.
        /// </summary>
        /// <param name="data"><p>The full JSON object you'd like to load into the Data store.</p>
        /// </param>
        /// <param name="append"><p>True to add the records to the existing records in the store, false
        /// to remove the old ones first.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        public void loadRawData(JsArray<Object> data, object append=null){}
        /// <summary>
        /// Loads an array of model instances into the store, fires the datachanged event. This should only usually
        /// be called internally when loading from the Proxy, when adding records manually use add instead
        /// </summary>
        /// <param name="records"><p>The array of records to load</p>
        /// </param>
        /// <param name="options">
        /// <ul><li><span>addRecords</span> : <see cref="bool">Boolean</see> (optional)<div><p>Pass <c>true</c> to add these records to the existing records, <c>false</c> to remove the Store's existing records first.</p>
        /// <p>Defaults to: <c>false</c></p></div></li><li><span>start</span> : <see cref="Number">Number</see> (optional)<div><p>Only used by buffered Stores. The index <em>within the overall dataset</em> of the first record in the array.</p>
        /// </div></li></ul></param>
        public void loadRecords(JsArray<Ext.data.Model> records, object options=null){}
        /// <summary>
        /// Gets the maximum value in the store.
        /// When store is filtered, only items within the filter are aggregated.
        /// </summary>
        /// <param name="field"><p>The field in each record</p>
        /// </param>
        /// <param name="grouped"><p>True to perform the operation for each group
        /// in the store. The value returned will be an object literal with the key being the group
        /// name and the maximum in the group being the value. The grouped parameter is only honored if
        /// the store has a groupField.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The maximum value, if no items exist, undefined.</p>
        /// </div>
        /// </returns>
        public object max(JsString field, object grouped=null){return null;}
        /// <summary>
        /// Gets the minimum value in the store.
        /// When store is filtered, only items within the filter are aggregated.
        /// </summary>
        /// <param name="field"><p>The field in each record</p>
        /// </param>
        /// <param name="grouped"><p>True to perform the operation for each group
        /// in the store. The value returned will be an object literal with the key being the group
        /// name and the minimum in the group being the value. The grouped parameter is only honored if
        /// the store has a groupField.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The minimum value, if no items exist, undefined.</p>
        /// </div>
        /// </returns>
        public object min(JsString field, object grouped=null){return null;}
        /// <summary>
        /// Loads the next 'page' in the current data set
        /// </summary>
        /// <param name="options"><p>See options for <see cref="Ext.data.Store.load">load</see></p>
        /// </param>
        public void nextPage(object options){}
        /// <summary>
        /// Handles a guaranteed range being loaded
        /// </summary>
        /// <param name="options">
        /// </param>
        private void onGuaranteedRange(object options){}
        /// <summary>
        /// Called internally when a Proxy has completed a load request
        /// </summary>
        /// <param name="operation">
        /// </param>
        private void onProxyLoad(object operation){}
        /// <summary>
        /// Called after the configured proxy completes a prefetch operation.
        /// </summary>
        /// <param name="operation"><p>The operation that completed</p>
        /// </param>
        private void onProxyPrefetch(Operation operation){}
        /// <summary>
        /// Determines if the passed page is available in the page cache.
        /// </summary>
        /// <param name="page"><p>The page to find in the page cache.</p>
        /// </param>
        private void pageCached(JsNumber page){}
        /// <summary>
        /// Prefetches data into the store using its configured proxy.
        /// </summary>
        /// <param name="options"><p>config object, passed into the <see cref="Ext.data.Operation">Ext.data.Operation</see> object before loading.
        /// See <see cref="Ext.data.Store.load">load</see></p>
        /// </param>
        public void prefetch(object options=null){}
        /// <summary>
        /// Prefetches a page of data.
        /// </summary>
        /// <param name="page"><p>The page to prefetch</p>
        /// </param>
        /// <param name="options"><p>config object, passed into the <see cref="Ext.data.Operation">Ext.data.Operation</see> object before loading.
        /// See <see cref="Ext.data.Store.load">load</see></p>
        /// </param>
        public void prefetchPage(JsNumber page, object options=null){}
        /// <summary>
        /// Ensures that the specified range of rows is present in the cache.
        /// Converts the row range to a page range and then only load pages which are not already
        /// present in the page cache.
        /// </summary>
        /// <param name="start">
        /// </param>
        /// <param name="end">
        /// </param>
        public void prefetchRange(object start, object end){}
        /// <summary>
        /// Loads the previous 'page' in the current data set
        /// </summary>
        /// <param name="options"><p>See options for <see cref="Ext.data.Store.load">load</see></p>
        /// </param>
        public void previousPage(object options){}
        /// <summary>
        /// Query all the cached records in this Store by name/value pair.
        /// The parameters will be used to generated a filter function that is given
        /// to the queryBy method.
        /// This method compliments queryBy by generating the query function automatically.
        /// </summary>
        /// <param name="property"><p>The property to create the filter function for</p>
        /// </param>
        /// <param name="value"><p>The string/regex to compare the property value to</p>
        /// </param>
        /// <param name="anyMatch"><p>True if we don't care if the filter value is not the full value.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="caseSensitive"><p>True to create a case-sensitive regex.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="exactMatch"><p>True to force exact match (^ and $ characters added to the regex).
        /// Ignored if anyMatch is true.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see></span><div><p>Returns an <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see> of the matched records</p>
        /// </div>
        /// </returns>
        public Ext.util.MixedCollection query(JsString property, object value, object anyMatch=null, object caseSensitive=null, object exactMatch=null){return null;}
        /// <summary>
        /// Query all the cached records in this Store using a filtering function. The specified function
        /// will be called with each record in this Store. If the function returns true the record is
        /// included in the results.
        /// This method is not effected by filtering, it will always look from all records inside the store
        /// no matter if filter is applied or not.
        /// </summary>
        /// <param name="fn"><p>The function to be called. It will be passed the following parameters:</p>
        /// <h3>Parameters</h3><ul><li><span>record</span> : <see cref="Ext.data.Model">Ext.data.Model</see><div><p>The record to test for filtering. Access field values
        /// using <see cref="Ext.data.Model.get">Ext.data.Model.get</see>.</p>
        /// </div></li><li><span>id</span> : <see cref="Object">Object</see><div><p>The ID of the Record passed.</p>
        /// </div></li></ul></param>
        /// <param name="scope"><p>The scope (this reference) in which the function is executed
        /// Defaults to this Store.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see></span><div><p>Returns an <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see> of the matched records</p>
        /// </div>
        /// </returns>
        public Ext.util.MixedCollection queryBy(System.Delegate fn, object scope=null){return null;}
        /// <summary>
        /// Determines if the passed range is available in the page cache.
        /// </summary>
        /// <param name="start"><p>The start index</p>
        /// </param>
        /// <param name="end"><p>The end index in the range</p>
        /// </param>
        private void rangeCached(JsNumber start, JsNumber end){}
        /// <summary>
        /// Determines if the passed range is available in the page cache.
        /// <p>This method has been <strong>deprecated</strong> since 4.1.0</p>
        /// <p>use <see cref="Ext.data.Store">rangeCached</see> instead</p>
        /// </summary>
        /// <param name="start"><p>The start index</p>
        /// </param>
        /// <param name="end"><p>The end index in the range</p>
        /// </param>
        private void rangeSatisfied(JsNumber start, JsNumber end){}
        /// <summary>
        /// Rejects outstanding changes on all modified records
        /// and re-insert any records that were removed locally. Any phantom records will be removed.
        /// </summary>
        public void rejectChanges(){}
        /// <summary>
        /// Removes the given record from the Store, firing the 'remove' event for each instance that is removed,
        /// plus a single 'datachanged' event after removal.
        /// </summary>
        /// <param name="records"><p>Model instance or array of instances to remove.</p>
        /// </param>
        public void remove(object records){}
        /// <summary>
        /// Removes all items from the store.
        /// </summary>
        /// <param name="silent"><p>Prevent the <c>clear</c> event from being fired.</p>
        /// </param>
        public void removeAll(bool silent){}
        /// <summary>
        /// Removes the model instance at the given index
        /// </summary>
        /// <param name="index"><p>The record index</p>
        /// </param>
        public void removeAt(JsNumber index){}
        /// <summary>
        /// Sums the value of property for each record between start
        /// and end and returns the result.
        /// When store is filtered, only sums items within the filter.
        /// </summary>
        /// <param name="field"><p>A field in each record</p>
        /// </param>
        /// <param name="grouped"><p>True to perform the operation for each group
        /// in the store. The value returned will be an object literal with the key being the group
        /// name and the sum for that group being the value. The grouped parameter is only honored if
        /// the store has a groupField.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The sum</p>
        /// </div>
        /// </returns>
        public JsNumber sum(JsString field, object grouped=null){return null;}
        public Store(Ext.data.StoreConfig config){}
        public Store(params object[] args){}
        /// <inheritdocs />
        /// <summary>
        /// <p><strong>NOTE</strong> This is a private utility class for internal use by the framework. Don't rely on its existence.</p><p>Private class for use by only Store when configured <c>buffered: true</c>.</p>
        /// </summary>
        [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
        public partial class PageMap : Ext.util.LruCache
        {
            public PageMap(PageMapConfig config){}
            public PageMap(){}
            public PageMap(params object[] args){}
        }
        /// <inheritdocs />
        [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
        public partial class PageMapConfig : Ext.util.LruCacheConfig
        {
            public PageMapConfig(params object[] args){}
        }
        /// <inheritdocs />
        [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
        public partial class PageMapEvents : Ext.util.LruCacheEvents
        {
            public PageMapEvents(params object[] args){}
        }
    }
    #endregion
    #region StoreConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class StoreConfig : AbstractStoreConfig
    {
        /// <summary>
        /// Allows the Store to prefetch and cache in a page cache, pages of Records, and to then satisfy
        /// loading requirements from this page cache.
        /// To use buffered Stores, initiate the process by loading the first page. The number of rows rendered are
        /// determined automatically, and the range of pages needed to keep the cache primed for scrolling is
        /// requested and cached.
        /// Example:
        /// // Load page 1
        /// myStore.loadPage(1);
        /// A <see cref="Ext.grid.PagingScroller">PagingScroller</see> is instantiated which will monitor the scrolling in the grid, and
        /// refresh the view's rows from the page cache as needed. It will also pull new data into the page
        /// cache when scrolling of the view draws upon data near either end of the prefetched data.
        /// The margins which trigger view refreshing from the prefetched data are <see cref="Ext.grid.PagingScrollerConfig.numFromEdge">Ext.grid.PagingScroller.numFromEdge</see>,
        /// <see cref="Ext.grid.PagingScrollerConfig.leadingBufferZone">Ext.grid.PagingScroller.leadingBufferZone</see> and <see cref="Ext.grid.PagingScrollerConfig.trailingBufferZone">Ext.grid.PagingScroller.trailingBufferZone</see>.
        /// The margins which trigger loading more data into the page cache are, <see cref="Ext.data.StoreConfig.leadingBufferZone">leadingBufferZone</see> and
        /// <see cref="Ext.data.StoreConfig.trailingBufferZone">trailingBufferZone</see>.
        /// By defult, only 5 pages of data are cached in the page cache, with pages "scrolling" out of the buffer
        /// as the view moves down through the dataset.
        /// Setting this value to zero means that no pages are <em>ever</em> scrolled out of the page cache, and
        /// that eventually the whole dataset may become present in the page cache. This is sometimes desirable
        /// as long as datasets do not reach astronomical proportions.
        /// Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
        /// records from its collection when those Records cycle out of the Store's primary collection. This is done
        /// by configuring the SelectionModel like this:
        /// selModel: {
        /// <code>   pruneRemoved: false
        /// </code>
        /// }
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool buffered;
        /// <summary>
        /// True to empty the store when loading another page via loadPage,
        /// nextPage or previousPage. Setting to false keeps existing records, allowing
        /// large data sets to be loaded one page at a time but rendered all together.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool clearOnPageLoad;
        /// <summary>
        /// True to clear anything in the removed record collection when the store loads.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool clearRemovedOnLoad;
        /// <summary>
        /// Array of Model instances or data objects to load locally. See "Inline data" above for details.
        /// </summary>
        public object data;
        /// <summary>
        /// The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
        /// Defaults to: <c>&quot;ASC&quot;</c>
        /// </summary>
        public JsString groupDir;
        /// <summary>
        /// The field by which to group data in the store. Internally, grouping is very similar to sorting - the
        /// groupField and groupDir are injected as the first sorter (see sort). Stores support a single
        /// level of grouping, and groups can be fetched via the getGroups method.
        /// </summary>
        public JsString groupField;
        /// <summary>
        /// When buffered, the number of extra rows to keep cached on the leading side of scrolling buffer
        /// as scrolling proceeds. A larger number means fewer replenishments from the server.
        /// Defaults to: <c>200</c>
        /// </summary>
        public JsNumber leadingBufferZone;
        /// <summary>
        /// The number of records considered to form a 'page'. This is used to power the built-in
        /// paging using the nextPage and previousPage functions when the grid is paged using a
        /// PagingScroller Defaults to 25.
        /// If this Store is <see cref="Ext.data.StoreConfig.buffered">buffered</see>, pages are loaded into a page cache before the Store's
        /// data is updated from the cache. The pageSize is the number of rows loaded into the cache in one request.
        /// This will not affect the rendering of a buffered grid, but a larger page size will mean fewer loads.
        /// In a buffered grid, scrolling is monitored, and the page cache is kept primed with data ahead of the
        /// direction of scroll to provide rapid access to data when scrolling causes it to be required. Several pages
        /// in advance may be requested depending on various parameters.
        /// It is recommended to tune the <see cref="Ext.data.StoreConfig.pageSize">pageSize</see>, <see cref="Ext.data.StoreConfig.trailingBufferZone">trailingBufferZone</see> and
        /// <see cref="Ext.data.StoreConfig.leadingBufferZone">leadingBufferZone</see> configurations based upon the conditions pertaining in your deployed application.
        /// The provided SDK example <c>examples/grid/infinite-scroll-grid-tuner.html</c> can be used to experiment with
        /// different settings including simulating Ajax latency.
        /// </summary>
        public JsNumber pageSize;
        /// <summary>
        /// Valid only when used with a buffered Store.
        /// The number of pages <em>additional to the required buffered range</em> to keep in the prefetch cache before purging least recently used records.
        /// For example, if the height of the view area and the configured <see cref="Ext.data.StoreConfig.trailingBufferZone">trailingBufferZone</see> and <see cref="Ext.data.StoreConfig.leadingBufferZone">leadingBufferZone</see> require that there
        /// are three pages in the cache, then a <c>purgePageCount</c> of 5 ensures that up to 8 pages can be in the page cache any any one time.
        /// A value of 0 indicates to never purge the prefetched data.
        /// Defaults to: <c>5</c>
        /// </summary>
        public JsNumber purgePageCount;
        /// <summary>
        /// True if the grouping should apply on the server side, false if it is local only.  If the
        /// grouping is local, it can be applied immediately to the data.  If it is remote, then it will simply act as a
        /// helper, automatically sending the grouping information to the server.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool remoteGroup;
        /// <summary>
        /// For local filtering only, causes sort to be called whenever filter is called,
        /// causing the sorters to be reapplied after filtering. Defaults to true
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool sortOnFilter;
        /// <summary>
        /// When buffered, the number of extra records to keep cached on the trailing side of scrolling buffer
        /// as scrolling proceeds. A larger number means fewer replenishments from the server.
        /// Defaults to: <c>25</c>
        /// </summary>
        public JsNumber trailingBufferZone;
        public StoreConfig(params object[] args){}
    }
    #endregion
    #region StoreEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class StoreEvents : AbstractStoreEvents
    {
        /// <summary>
        /// Fires before a prefetch occurs. Return false to cancel.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="operation"><p>The associated operation</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforeprefetch(Ext.data.Store @this, Operation operation, object eOpts){}
        /// <summary>
        /// Fired whenever the grouping in the grid changes
        /// </summary>
        /// <param name="store"><p>The store</p>
        /// </param>
        /// <param name="groupers"><p>The array of grouper objects</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void groupchange(Ext.data.Store store, JsArray<Ext.util.Grouper> groupers, object eOpts){}
        /// <summary>
        /// Fires whenever records have been prefetched
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="records"><p>An array of records.</p>
        /// </param>
        /// <param name="successful"><p>True if the operation was successful.</p>
        /// </param>
        /// <param name="operation"><p>The associated operation</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void prefetch(Ext.data.Store @this, JsArray<Ext.data.Model> records, bool successful, Operation operation, object eOpts){}
        public StoreEvents(params object[] args){}
    }
    #endregion
}
