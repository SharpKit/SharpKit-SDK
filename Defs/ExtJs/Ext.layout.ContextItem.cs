//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:41 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.layout
{
    #region ContextItem
    /// <inheritdocs />
    /// <summary>
    /// <p><strong>NOTE</strong> This is a private utility class for internal use by the framework. Don't rely on its existence.</p><p>This class manages state information for a component or element during a layout.</p>
    /// <h1>Blocks</h1>
    /// <p>A "block" is a required value that is preventing further calculation. When a layout has
    /// encountered a situation where it cannot possibly calculate results, it can associate
    /// itself with the context item and missing property so that it will not be rescheduled
    /// until that property is set.</p>
    /// <p>Blocks are a one-shot registration. Once the property changes, the block is removed.</p>
    /// <p>Be careful with blocks. If <em>any</em> further calculations can be made, a block is not the
    /// right choice.</p>
    /// <h1>Triggers</h1>
    /// <p>Whenever any call to <see cref="Ext.layout.ContextItem.getProp">getProp</see>, <see cref="Ext.layout.ContextItem.getDomProp">getDomProp</see>, <see cref="Ext.layout.ContextItem.hasProp">hasProp</see> or
    /// <see cref="Ext.layout.ContextItem.hasDomProp">hasDomProp</see> is made, the current layout is automatically registered as being
    /// dependent on that property in the appropriate state. Any changes to the property will
    /// trigger the layout and it will be queued in the <see cref="Ext.layout.Context">Ext.layout.Context</see>.</p>
    /// <p>Triggers, once added, remain for the entire layout. Any changes to the property will
    /// reschedule all unfinished layouts in their trigger set.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class ContextItem : Ext.Base
    {
        /// <summary>
        /// State variables that are cleared when invalidated. Only applies to component items.
        /// Defaults to: <c>null</c>
        /// </summary>
        public JsObject state{get;set;}
        /// <summary>
        /// True if this item wraps a Component (rather than an Element).
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool wrapsComponent{get;set;}
        /// <summary>
        /// Adds a block.
        /// </summary>
        /// <param name="name"><p>The name of the block list ('blocks' or 'domBlocks').</p>
        /// </param>
        /// <param name="layout"><p>The layout that is blocked.</p>
        /// </param>
        /// <param name="propName"><p>The property name that blocked the layout (e.g., 'width').</p>
        /// </param>
        private void addBlock(JsString name, Layout layout, JsString propName){}
        /// <summary>
        /// Queue the addition of a class name (or array of class names) to this ContextItem's target when next flushed.
        /// </summary>
        /// <param name="newCls">
        /// </param>
        public void addCls(object newCls){}
        /// <summary>
        /// Adds a trigger.
        /// </summary>
        /// <param name="propName"><p>The property name that triggers the layout (e.g., 'width').</p>
        /// </param>
        /// <param name="inDom"><p>True if the trigger list is <c>domTriggers</c>, false if <c>triggers</c>.</p>
        /// </param>
        private void addTrigger(JsString propName, bool inDom){}
        /// <summary>
        /// Registers a layout in the block list for the given property. Once the property is
        /// set in the Ext.layout.Context, the layout is unblocked.
        /// </summary>
        /// <param name="layout">
        /// </param>
        /// <param name="propName"><p>The property name that blocked the layout (e.g., 'width').</p>
        /// </param>
        public void block(Layout layout, JsString propName){}
        /// <summary>
        /// Removes any blocks on a property in the specified set. Any layouts that were blocked
        /// by this property and are not still blocked (by other properties) will be rescheduled.
        /// </summary>
        /// <param name="name"><p>The name of the block list ('blocks' or 'domBlocks').</p>
        /// </param>
        /// <param name="propName"><p>The property name that blocked the layout (e.g., 'width').</p>
        /// </param>
        private void clearBlocks(JsString name, JsString propName){}
        /// <summary>
        /// clears the margin cache so that marginInfo get re-read from the dom on the next call to getMarginInfo()
        /// This is needed in some special cases where the margins have changed since the last layout, making the cached
        /// values invalid.  For example collapsed window headers have different margin than expanded ones.
        /// </summary>
        public void clearMarginCache(){}
        /// <summary>
        /// Registers a layout in the DOM block list for the given property. Once the property
        /// flushed to the DOM by the Ext.layout.Context, the layout is unblocked.
        /// </summary>
        /// <param name="layout">
        /// </param>
        /// <param name="propName"><p>The property name that blocked the layout (e.g., 'width').</p>
        /// </param>
        public void domBlock(Layout layout, JsString propName){}
        /// <summary>
        /// Reschedules any layouts associated with a given trigger.
        /// </summary>
        /// <param name="name"><p>The name of the trigger list ('triggers' or 'domTriggers').</p>
        /// </param>
        /// <param name="propName"><p>The property name that triggers the layout (e.g., 'width').</p>
        /// </param>
        private void fireTriggers(JsString name, JsString propName){}
        /// <summary>
        /// Flushes any updates in the dirty collection to the DOM. This is only called if there
        /// are dirty entries because this object is only added to the flushQueue of the
        /// Ext.layout.Context when entries become dirty.
        /// </summary>
        public void flush(){}
        /// <summary>
        /// </summary>
        private void flushAnimations(){}
        /// <summary>
        /// Gets the border information for the element as an object with left, top, right and
        /// bottom properties holding border size in pixels. This object is only read from the
        /// DOM on first request and is cached.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public object getBorderInfo(){return null;}
        /// <summary>
        /// Returns a ClassList-like object to buffer access to this item's element's classes.
        /// </summary>
        public void getClassList(){}
        /// <summary>
        /// Gets a property of this object if it is correct in the DOM. Also tracks the current
        /// layout as dependent on this property so that DOM writes of it will trigger the
        /// layout to be recalculated.
        /// </summary>
        /// <param name="propName"><p>The property name (e.g., 'width').</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The property value or undefined if not yet set or is dirty.</p>
        /// </div>
        /// </returns>
        public object getDomProp(JsString propName){return null;}
        /// <summary>
        /// Returns the context item for an owned element. This should only be called on a
        /// component's item. The list of child items is used to manage invalidating calculated
        /// results.
        /// </summary>
        /// <param name="nameOrEl">
        /// </param>
        /// <param name="owner">
        /// </param>
        public void getEl(object nameOrEl, object owner){}
        /// <summary>
        /// Gets the "frame" information for the element as an object with left, top, right and
        /// bottom properties holding border+framing size in pixels. This object is calculated
        /// on first request and is cached.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public object getFrameInfo(){return null;}
        /// <summary>
        /// Gets the margin information for the element as an object with left, top, right and
        /// bottom properties holding margin size in pixels. This object is only read from the
        /// DOM on first request and is cached.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public object getMarginInfo(){return null;}
        /// <summary>
        /// Gets the padding information for the element as an object with left, top, right and
        /// bottom properties holding padding size in pixels. This object is only read from the
        /// DOM on first request and is cached.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public object getPaddingInfo(){return null;}
        /// <summary>
        /// Gets a property of this object. Also tracks the current layout as dependent on this
        /// property so that changes to it will trigger the layout to be recalculated.
        /// </summary>
        /// <param name="propName"><p>The property name that blocked the layout (e.g., 'width').</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The property value or undefined if not yet set.</p>
        /// </div>
        /// </returns>
        public object getProp(JsString propName){return null;}
        /// <summary>
        /// Returns a style for this item. Each style is read from the DOM only once on first
        /// request and is then cached. If the value is an integer, it is parsed automatically
        /// (so '5px' is not returned, but rather 5).
        /// </summary>
        /// <param name="styleName"><p>The CSS style name.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The value of the DOM style (parsed as necessary).</p>
        /// </div>
        /// </returns>
        public object getStyle(JsString styleName){return null;}
        /// <summary>
        /// Returns styles for this item. Each style is read from the DOM only once on first
        /// request and is then cached. If the value is an integer, it is parsed automatically
        /// (so '5px' is not returned, but rather 5).
        /// </summary>
        /// <param name="styleNames"><p>The CSS style names.</p>
        /// </param>
        /// <param name="altNames"><p>The alternate names for the returned styles. If given,
        /// these names must correspond one-for-one to the <c>styleNames</c>.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The values of the DOM styles (parsed as necessary).</p>
        /// </div>
        /// </returns>
        public object getStyles(JsArray<String> styleNames, object altNames=null){return null;}
        /// <summary>
        /// Returns true if the given property is correct in the DOM. This is equivalent to
        /// calling getDomProp and not getting an undefined result. In particular,
        /// this call registers the current layout to be triggered by flushes of this property.
        /// </summary>
        /// <param name="propName"><p>The property name (e.g., 'width').</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div>
        /// </div>
        /// </returns>
        public bool hasDomProp(JsString propName){return false;}
        /// <summary>
        /// Returns true if the given property has been set. This is equivalent to calling
        /// getProp and not getting an undefined result. In particular, this call
        /// registers the current layout to be triggered by changes to this property.
        /// </summary>
        /// <param name="propName"><p>The property name (e.g., 'width').</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div>
        /// </div>
        /// </returns>
        public bool hasProp(JsString propName){return false;}
        /// <summary>
        /// Clears all properties on this object except (perhaps) those not calculated by this
        /// component. This is more complex than it would seem because a layout can decide to
        /// invalidate its results and run the component's layouts again, but since some of the
        /// values may be calculated by the container, care must be taken to preserve those
        /// values.
        /// </summary>
        /// <param name="full"><p>True if all properties are to be invalidated, false to keep
        /// those calculated by the ownerCt.</p>
        /// </param>
        /// <returns>
        /// <span>Mixed</span><div><p>A value to pass as the first argument to <see cref="Ext.layout.ContextItem">initContinue</see>.</p>
        /// </div>
        /// </returns>
        private JsObject init(bool full){return null;}
        /// <summary>
        /// </summary>
        private void initAnimation(){}
        /// <summary>
        /// Parameters<li><span>full</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="full">
        /// </param>
        private void initContinue(object full){}
        /// <summary>
        /// Parameters<li><span>full</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>componentChildrenDone</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>containerChildrenDone</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>containerLayoutDone</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="full">
        /// </param>
        /// <param name="componentChildrenDone">
        /// </param>
        /// <param name="containerChildrenDone">
        /// </param>
        /// <param name="containerLayoutDone">
        /// </param>
        private void initDone(object full, object componentChildrenDone, object containerChildrenDone, object containerLayoutDone){}
        /// <summary>
        /// Invalidates the component associated with this item. The layouts for this component
        /// and all of its contained items will be re-run after first clearing any computed
        /// values.
        /// If state needs to be carried forward beyond the invalidation, the <c>options</c> parameter
        /// can be used.
        /// </summary>
        /// <param name="options"><p>An object describing how to handle the invalidation.</p>
        /// <ul><li><span>state</span> : <see cref="Object">Object</see><div><p>An object to <see cref="Ext.ExtContext.apply">Ext.apply</see> to the <see cref="Ext.layout.ContextItem.state">state</see>
        /// of this item after invalidation clears all other properties.</p>
        /// </div></li><li><span>before</span> : <see cref="Function">Function</see><div><p>A function to call after the context data is cleared
        /// and before the <see cref="Ext.layout.Layout.beginLayoutCycle">Ext.layout.Layout.beginLayoutCycle</see> methods are called.</p>
        /// <h3>Parameters</h3><ul><li><span>item</span> : <see cref="Ext.layout.ContextItem">Ext.layout.ContextItem</see><div><p>This ContextItem.</p>
        /// </div></li><li><span>options</span> : <see cref="Object">Object</see><div><p>The options object passed to <see cref="Ext.layout.ContextItem.invalidate">invalidate</see>.</p>
        /// </div></li></ul></div></li><li><span>after</span> : <see cref="Function">Function</see><div><p>A function to call after the context data is cleared
        /// and after the <see cref="Ext.layout.Layout.beginLayoutCycle">Ext.layout.Layout.beginLayoutCycle</see> methods are called.</p>
        /// <h3>Parameters</h3><ul><li><span>item</span> : <see cref="Ext.layout.ContextItem">Ext.layout.ContextItem</see><div><p>This ContextItem.</p>
        /// </div></li><li><span>options</span> : <see cref="Object">Object</see><div><p>The options object passed to <see cref="Ext.layout.ContextItem.invalidate">invalidate</see>.</p>
        /// </div></li></ul></div></li><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope to use when calling the callback functions.</p>
        /// </div></li></ul></param>
        public void invalidate(object options){}
        /// <summary>
        /// Recovers a property value from the last computation and restores its value and
        /// dirty state.
        /// </summary>
        /// <param name="propName"><p>The name of the property to recover.</p>
        /// </param>
        /// <param name="oldProps"><p>The old "props" object from which to recover values.</p>
        /// </param>
        /// <param name="oldDirty"><p>The old "dirty" object from which to recover state.</p>
        /// </param>
        public void recoverProp(JsString propName, object oldProps, object oldDirty){}
        /// <summary>
        /// Queue the removal of a class name (or array of class names) from this ContextItem's target when next flushed.
        /// </summary>
        /// <param name="removeCls">
        /// </param>
        public void removeCls(object removeCls){}
        /// <summary>
        /// Queue the setting of a DOM attribute on this ContextItem's target when next flushed.
        /// </summary>
        /// <param name="name">
        /// </param>
        /// <param name="value">
        /// </param>
        public void setAttribute(object name, object value){}
        /// <summary>
        /// Sets the contentHeight property. If the component uses raw content, then only the
        /// measured height is acceptable.
        /// Calculated values can sometimes be NaN or undefined, which generally mean the
        /// calculation is not done. To indicate that such as value was passed, 0 is returned.
        /// Otherwise, 1 is returned.
        /// If the caller is not measuring (i.e., they are calculating) and the component has raw
        /// content, 1 is returned indicating that the caller is done.
        /// </summary>
        /// <param name="height">
        /// </param>
        /// <param name="measured">
        /// </param>
        public void setContentHeight(object height, object measured){}
        /// <summary>
        /// Sets the contentWidth and contentHeight properties. If the component uses raw content,
        /// then only the measured values are acceptable.
        /// Calculated values can sometimes be NaN or undefined, which generally means that the
        /// calculation is not done. To indicate that either passed value was such a value, false
        /// returned. Otherwise, true is returned.
        /// If the caller is not measuring (i.e., they are calculating) and the component has raw
        /// content, true is returned indicating that the caller is done.
        /// </summary>
        /// <param name="width">
        /// </param>
        /// <param name="height">
        /// </param>
        /// <param name="measured">
        /// </param>
        public void setContentSize(object width, object height, object measured){}
        /// <summary>
        /// Sets the contentWidth property. If the component uses raw content, then only the
        /// measured width is acceptable.
        /// Calculated values can sometimes be NaN or undefined, which generally means that the
        /// calculation is not done. To indicate that such as value was passed, 0 is returned.
        /// Otherwise, 1 is returned.
        /// If the caller is not measuring (i.e., they are calculating) and the component has raw
        /// content, 1 is returned indicating that the caller is done.
        /// </summary>
        /// <param name="width">
        /// </param>
        /// <param name="measured">
        /// </param>
        public void setContentWidth(object width, object measured){}
        /// <summary>
        /// Sets the height and constrains the height to min/maxHeight range.
        /// </summary>
        /// <param name="height"><p>The height.</p>
        /// </param>
        /// <param name="dirty"><p>Specifies if the value is currently in the DOM. A
        /// value of <c>false</c> indicates that the value is already in the DOM.</p>
        /// <p>Defaults to: <c>true</c></p></param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The actual height after constraining.</p>
        /// </div>
        /// </returns>
        public JsNumber setHeight(JsNumber height, object dirty=null){return null;}
        /// <summary>
        /// Sets a property value. This will unblock and/or trigger dependent layouts if the
        /// property value is being changed. Values of NaN and undefined are not accepted by
        /// this method.
        /// </summary>
        /// <param name="propName"><p>The property name (e.g., 'width').</p>
        /// </param>
        /// <param name="value"><p>The new value of the property.</p>
        /// </param>
        /// <param name="dirty"><p>Optionally specifies if the value is currently in the DOM
        /// (default is <c>true</c> which indicates the value is not in the DOM and must be flushed
        /// at some point).</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>1 if this call specified the property value, 0 if not.</p>
        /// </div>
        /// </returns>
        public JsNumber setProp(JsString propName, object value, object dirty=null){return null;}
        /// <summary>
        /// Sets the height and constrains the width to min/maxWidth range.
        /// </summary>
        /// <param name="width"><p>The width.</p>
        /// </param>
        /// <param name="dirty"><p>Specifies if the value is currently in the DOM. A
        /// value of <c>false</c> indicates that the value is already in the DOM.</p>
        /// <p>Defaults to: <c>true</c></p></param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The actual width after constraining.</p>
        /// </div>
        /// </returns>
        public JsNumber setWidth(JsNumber width, object dirty=null){return null;}
        public ContextItem(ContextItemConfig config){}
        public ContextItem(){}
        public ContextItem(params object[] args){}
    }
    #endregion
    #region ContextItemConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ContextItemConfig : Ext.BaseConfig
    {
        public ContextItemConfig(params object[] args){}
    }
    #endregion
    #region ContextItemEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ContextItemEvents : Ext.BaseEvents
    {
        public ContextItemEvents(params object[] args){}
    }
    #endregion
}
