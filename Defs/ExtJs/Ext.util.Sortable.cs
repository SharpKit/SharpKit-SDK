//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:42 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.util
{
    #region Sortable
    /// <summary>
    /// <p>A mixin which allows a data component to be sorted. This is used by e.g. <see cref="Ext.data.Store">Ext.data.Store</see> and <see cref="Ext.data.TreeStore">Ext.data.TreeStore</see>.</p>
    /// <p><strong>NOTE</strong>: This mixin is mainly for internal use and most users should not need to use it directly. It
    /// is more likely you will want to use one of the component classes that import this mixin, such as
    /// <see cref="Ext.data.Store">Ext.data.Store</see> or <see cref="Ext.data.TreeStore">Ext.data.TreeStore</see>.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial interface Sortable
    {
        /// <summary>
        /// Defaults to: <c>&quot;Ext.Base&quot;</c>
        /// </summary>
        [JsProperty(Name="$className")]
        JsString @className{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        JsObject configMap{get;set;}
        /// <summary>
        /// The default sort direction to use if one is not specified.
        /// Defaults to: <c>&quot;ASC&quot;</c>
        /// </summary>
        JsString defaultSortDirection{get;set;}
        /// <summary>
        /// Defaults to: <c>[]</c>
        /// </summary>
        JsArray initConfigList{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        JsObject initConfigMap{get;set;}
        /// <summary>
        /// Defaults to: <c>true</c>
        /// </summary>
        bool isInstance{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Sortable, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        bool isSortable{get;set;}
        /// <summary>
        /// Get the reference to the current class from which this object was instantiated. Unlike statics,
        /// this.self is scope-dependent and it's meant to be used for dynamic inheritance. See statics
        /// for a detailed comparison
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// statics: {
        /// speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        /// },
        /// constructor: function() {
        /// alert(this.self.speciesName); // dependent on 'this'
        /// },
        /// clone: function() {
        /// return new this.self();
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.SnowLeopard', {
        /// extend: 'My.Cat',
        /// statics: {
        /// speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
        /// }
        /// });
        /// var cat = new My.Cat();                     // alerts 'Cat'
        /// var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
        /// var clone = snowLeopard.clone();
        /// alert(<see cref="Ext.ExtContext.getClassName">Ext.getClassName</see>(clone));             // alerts 'My.SnowLeopard'
        /// </code>
        /// </summary>
        Class self{get;set;}
        /// <summary>
        /// The property in each item that contains the data to sort.
        /// </summary>
        JsString sortRoot{get;set;}
        /// <summary>
        /// The collection of Sorters currently applied to this Store
        /// </summary>
        MixedCollection sorters{get;set;}
        /// <summary>
        /// Normalizes an array of sorter objects, ensuring that they are all Ext.util.Sorter instances
        /// </summary>
        /// <param name="sorters"><p>The sorters array</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see>[]</span><div><p>Array of <see cref="Ext.util.Sorter">Ext.util.Sorter</see> objects</p>
        /// </div>
        /// </returns>
        Sorter[] decodeSorters(JsArray<Object> sorters);
        /// <summary>
        /// Returns a comparator function which compares two items and returns -1, 0, or 1 depending
        /// on the currently defined set of sorters.
        /// If there are no <see cref="Ext.util.Sortable.sorters">sorters</see> defined, it returns a function which returns <c>0</c> meaning that no sorting will occur.
        /// </summary>
        void generateComparator();
        /// <summary>
        /// Gets the first sorter from the sorters collection, excluding
        /// any groupers that may be in place
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see></span><div><p>The sorter, null if none exist</p>
        /// </div>
        /// </returns>
        Sorter getFirstSorter();
        /// <summary>
        /// Performs initialization of this mixin. Component classes using this mixin should call this method during their
        /// own initialization.
        /// </summary>
        void initSortable();
        /// <summary>
        /// Sorts the data in the Store by one or more of its properties. Example usage:
        /// <code>//sort by a single field
        /// myStore.sort('myField', 'DESC');
        /// //sorting by multiple fields
        /// myStore.sort([
        /// {
        /// property : 'age',
        /// direction: 'ASC'
        /// },
        /// {
        /// property : 'name',
        /// direction: 'DESC'
        /// }
        /// ]);
        /// </code>
        /// Internally, Store converts the passed arguments into an array of <see cref="Ext.util.Sorter">Ext.util.Sorter</see> instances, and delegates
        /// the actual sorting to its internal <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see>.
        /// When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
        /// <code>store.sort('myField');
        /// store.sort('myField');
        /// </code>
        /// Is equivalent to this code, because Store handles the toggling automatically:
        /// <code>store.sort('myField', 'ASC');
        /// store.sort('myField', 'DESC');
        /// </code>
        /// </summary>
        /// <param name="sorters"><p>Either a string name of one of the fields in this Store's configured
        /// <see cref="Ext.data.Model">Model</see>, or an array of sorter configurations.</p>
        /// </param>
        /// <param name="direction"><p>The overall direction to sort the data by.</p>
        /// <p>Defaults to: <c>&quot;ASC&quot;</c></p></param>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see>[]</span><div>
        /// </div>
        /// </returns>
        Sorter[] sort(object sorters=null, object direction=null);
    }
    #endregion
    #region SortableConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class SortableConfig : Ext.BaseConfig
    {
        public SortableConfig(params object[] args){}
    }
    #endregion
    #region SortableEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class SortableEvents : Ext.BaseEvents
    {
        public SortableEvents(params object[] args){}
    }
    #endregion
}
