//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:41 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.layout.container
{
    #region Container
    /// <inheritdocs />
    /// <summary>
    /// <p>This class is intended to be extended or created via the <see cref="Ext.container.ContainerConfig.layout">layout</see>
    /// configuration property.  See <see cref="Ext.container.ContainerConfig.layout">Ext.container.Container.layout</see> for additional details.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Container : Layout, Ext.util.ElementContainer
    {
        /// <summary>
        /// An optional extra CSS class that will be added to the container. This can be useful for
        /// adding customized styles to the container or any of its children using standard CSS
        /// rules. See Ext.Component.componentCls also.
        /// </summary>
        public JsString itemCls;
        /// <summary>
        /// One of the following values:
        /// <li>0 if the layout should ignore overflow.</li>
        /// <li>1 if the layout should be rerun if scrollbars are needed.</li>
        /// <li>2 if the layout should also correct padding when overflowed.</li>
        /// Defaults to: <c>0</c>
        /// </summary>
        public JsNumber manageOverflow;
        /// <summary>
        /// Set to true to leave space for a vertical scrollbar (if the OS shows space-consuming scrollbars) regardless
        /// of whether a scrollbar is needed.
        /// This is useful if content height changes during application usage, but you do not want the calculated width
        /// of child items to change when a scrollbar appears or disappears. The scrollbar will appear in the reserved space,
        /// and the calculated width of child Components will not change.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Employee', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// fields: [
        /// {name: 'rating', type: 'int'},
        /// {name: 'salary', type: 'float'},
        /// {name: 'name'}
        /// ]
        /// });
        /// function createFakeData(count) {
        /// var firstNames   = ['Ed', 'Tommy', 'Aaron', 'Abe', 'Jamie', 'Adam', 'Dave', 'David', 'Jay', 'Nicolas', 'Nige'],
        /// lastNames    = ['Spencer', 'Maintz', 'Conran', 'Elias', 'Avins', 'Mishcon', 'Kaneda', 'Davis', 'Robinson', 'Ferrero', 'White'],
        /// ratings      = [1, 2, 3, 4, 5],
        /// salaries     = [100, 400, 900, 1500, 1000000];
        /// var data = [];
        /// for (var i = 0; i &lt; (count || 25); i++) {
        /// var ratingId    = Math.floor(Math.random() * ratings.length),
        /// salaryId    = Math.floor(Math.random() * salaries.length),
        /// firstNameId = Math.floor(Math.random() * firstNames.length),
        /// lastNameId  = Math.floor(Math.random() * lastNames.length),
        /// rating      = ratings[ratingId],
        /// salary      = salaries[salaryId],
        /// name        = <see cref="Ext.String.format">Ext.String.format</see>("{0} {1}", firstNames[firstNameId], lastNames[lastNameId]);
        /// data.push({
        /// rating: rating,
        /// salary: salary,
        /// name: name
        /// });
        /// }
        /// store.loadData(data);
        /// }
        /// // create the Data Store
        /// var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
        /// id: 'store',
        /// model: 'Employee',
        /// proxy: {
        /// type: 'memory'
        /// }
        /// });
        /// createFakeData(10);
        /// var grid = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.grid.Panel">Ext.grid.Panel</see>', {
        /// title: 'Grid loaded with varying number of records',
        /// anchor: '100%',
        /// store: store,
        /// columns: [{
        /// xtype: 'rownumberer',
        /// width: 40,
        /// sortable: false
        /// },{
        /// text: 'Name',
        /// flex: 1,
        /// sortable: true,
        /// dataIndex: 'name'
        /// },{
        /// text: 'Rating',
        /// width: 125,
        /// sortable: true,
        /// dataIndex: 'rating'
        /// },{
        /// text: 'Salary',
        /// width: 125,
        /// sortable: true,
        /// dataIndex: 'salary',
        /// align: 'right',
        /// renderer: <see cref="Ext.util.Format.usMoney">Ext.util.Format.usMoney</see>
        /// }]
        /// });
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.panel.Panel">Ext.panel.Panel</see>', {
        /// renderTo: document.body,
        /// width: 800,
        /// height: 600,
        /// layout: {
        /// type: 'anchor',
        /// reserveScrollbar: true // There will be a gap even when there's no scrollbar
        /// },
        /// autoScroll: true,
        /// items: grid,
        /// tbar: {
        /// defaults: {
        /// handler: function(b) {
        /// createFakeData(b.count);
        /// }
        /// },
        /// items: [{
        /// text: '10 Items',
        /// count: 10
        /// },{
        /// text: '100 Items',
        /// count: 100
        /// },{
        /// text: '300 Items',
        /// count: 300
        /// },{
        /// text: '1000 Items',
        /// count: 1000
        /// },{
        /// text: '5000 Items',
        /// count: 5000
        /// }]
        /// }
        /// });
        /// </code>
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool reserveScrollbar;
        /// <summary>
        /// An object which contains boolean properties specifying which properties are to be
        /// animated upon flush of child Component ContextItems. For example, Accordion would
        /// have:
        /// <code> {
        /// y: true,
        /// height: true
        /// }
        /// </code>
        /// Defaults to: <c>null</c>
        /// </summary>
        private JsObject animatePolicy{get;set;}
        /// <summary>
        /// Returns flags indicating cross-browser handling of scrollHeight/Width. In particular,
        /// IE has issues with padding-bottom in a scrolling element (it does not include that
        /// padding in the scrollHeight). Also, margin-bottom on a child in a scrolling element
        /// can be lost.
        /// All browsers seem to ignore margin-right on children and padding-right on the parent
        /// element (the one with the overflow)
        /// This method returns a number with the follow bit positions set based on things not
        /// accounted for in scrollHeight and scrollWidth:
        /// <li>1: Scrolling element's padding-bottom is not included in scrollHeight.</li>
        /// <li>2: Last child's margin-bottom is not included in scrollHeight.</li>
        /// <li>4: Scrolling element's padding-right is not included in scrollWidth.</li>
        /// <li>8: Child's margin-right is not included in scrollWidth.</li>
        /// To work around the margin-bottom issue, it is sufficient to create a 0px tall last
        /// child that will "hide" the margin. This can also be handled by wrapping the children
        /// in an element, again "hiding" the margin. Wrapping the elements is about the only
        /// way to preserve their right margins. This is the strategy used by Column layout.
        /// To work around the padding-bottom problem, since it is comes from a style on the
        /// parent element, about the only simple fix is to create a last child with height
        /// equal to padding-bottom. To preserve the right padding, the sizing element needs to
        /// have a width that includes the right padding.
        /// </summary>
        public JsObject getScrollRangeFlags{get;set;}
        /// <summary>
        /// The element used to correct body padding during overflow.
        /// </summary>
        public Ext.dom.Element overflowPadderEl{get;set;}
        /// <summary>
        /// Adds each argument passed to this method to the childEls array.
        /// </summary>
        public virtual void addChildEls(){}
        /// <summary>
        /// Sets references to elements inside the component.
        /// </summary>
        /// <param name="el">
        /// </param>
        /// <param name="id">
        /// </param>
        public virtual void applyChildEls(object el, object id){}
        /// <summary>
        /// Called by an owning Panel before the Panel begins its collapse process.
        /// Most layouts will not need to override the default Ext.emptyFn implementation.
        /// </summary>
        private void beginCollapse(){}
        /// <summary>
        /// Called by an owning Panel before the Panel begins its expand process.
        /// Most layouts will not need to override the default Ext.emptyFn implementation.
        /// </summary>
        private void beginExpand(){}
        /// <summary>
        /// Handles overflow processing for a container. This should be called once the layout
        /// has determined contentWidth/Height. In addition to the ownerContext passed to the
        /// calculate method, this method also needs the containerSize (the object
        /// returned by getContainerSize).
        /// </summary>
        /// <param name="ownerContext">
        /// </param>
        /// <param name="containerSize">
        /// </param>
        /// <param name="dimensions"><p>A bit mask for the overflow managed dimensions. The 0-bit
        /// is for <c>width</c> and the 1-bit is for <c>height</c>. In other words, a value of 1 would be
        /// only <c>width</c>, 2 would be only <c>height</c> and 3 would be both.</p>
        /// </param>
        public void calculateOverflow(ContextItem ownerContext, object containerSize, JsNumber dimensions){}
        /// <summary>
        /// Creates an element that makes bottom/right body padding consistent across browsers.
        /// This element is sized based on the need for scrollbars in calculateOverflow.
        /// If the manageOverflow option is false, this element is not created.
        /// See <see cref="Ext.layout.container.Container.getScrollRangeFlags">getScrollRangeFlags</see> for more details.
        /// </summary>
        /// <param name="out">
        /// </param>
        /// <param name="renderData">
        /// </param>
        public void doRenderPadder(object @out, object renderData){}
        /// <summary>
        /// Returns the container size (that of the target). Only the fixed-sized dimensions can
        /// be returned because the shrinkWrap dimensions are based on the contentWidth/Height
        /// as determined by the container layout.
        /// If the <see cref="Ext.layout.container.Container.calculateOverflow">calculateOverflow</see> method is used and if <see cref="Ext.layout.container.ContainerConfig.manageOverflow">manageOverflow</see> is
        /// true, this may adjust the width/height by the size of scrollbars.
        /// </summary>
        /// <param name="ownerContext"><p>The owner's context item.</p>
        /// </param>
        /// <param name="inDom"><p>True if the container size must be in the DOM.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The size</p>
        /// <ul><li><span>width</span> : <see cref="Number">Number</see><div><p>The width</p>
        /// </div></li><li><span>height</span> : <see cref="Number">Number</see><div><p>The height</p>
        /// </div></li></ul></div>
        /// </returns>
        protected object getContainerSize(ContextItem ownerContext, object inDom=null){return null;}
        /// <summary>
        /// Returns the element into which extra functional DOM elements can be inserted. Defaults to the owner Component's encapsulating element.
        /// May be overridden in Component layout managers which implement a <see cref="Ext.layout.container.Container.getRenderTarget">component render target</see> which must only
        /// contain child components.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.dom.Element">Ext.Element</see></span><div>
        /// </div>
        /// </returns>
        public Ext.dom.Element getElementTarget(){return null;}
        /// <summary>
        /// Returns the element into which rendering must take place. Defaults to the owner Container's
        /// target element.
        /// May be overridden in layout managers which implement an inner element.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.dom.Element">Ext.Element</see></span><div>
        /// </div>
        /// </returns>
        public Ext.dom.Element getRenderTarget(){return null;}
        /// <summary>
        /// Returns all items that are rendered
        /// </summary>
        /// <returns>
        /// <span><see cref="Array">Array</see></span><div><p>All matching items</p>
        /// </div>
        /// </returns>
        protected JsArray getRenderedItems(){return null;}
        /// <summary>
        /// Returns the owner component's resize element.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.dom.Element">Ext.Element</see></span><div>
        /// </div>
        /// </returns>
        public Ext.dom.Element getTarget(){return null;}
        /// <summary>
        /// Returns all items that are both rendered and visible
        /// </summary>
        /// <returns>
        /// <span><see cref="Array">Array</see></span><div><p>All matching items</p>
        /// </div>
        /// </returns>
        protected JsArray getVisibleItems(){return null;}
        /// <summary>
        /// Called for every layout in the layout context after all the layouts have been finally flushed
        /// Overrides: <see cref="Ext.layout.Layout.notifyOwner">Ext.layout.Layout.notifyOwner</see>
        /// </summary>
        private void notifyOwner(){}
        /// <summary>
        /// Removes items in the childEls array based on the return value of a supplied test
        /// function. The function is called with a entry in childEls and if the test function
        /// return true, that entry is removed. If false, that entry is kept.
        /// </summary>
        /// <param name="testFn"><p>The test function.</p>
        /// </param>
        public virtual void removeChildEls(System.Delegate testFn){}
        public Container(Ext.layout.container.ContainerConfig config){}
        public Container(){}
        public Container(params object[] args){}
    }
    #endregion
    #region ContainerConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ContainerConfig : LayoutConfig
    {
        /// <summary>
        /// An optional extra CSS class that will be added to the container. This can be useful for
        /// adding customized styles to the container or any of its children using standard CSS
        /// rules. See Ext.Component.componentCls also.
        /// </summary>
        public JsString itemCls;
        /// <summary>
        /// One of the following values:
        /// <li>0 if the layout should ignore overflow.</li>
        /// <li>1 if the layout should be rerun if scrollbars are needed.</li>
        /// <li>2 if the layout should also correct padding when overflowed.</li>
        /// Defaults to: <c>0</c>
        /// </summary>
        public JsNumber manageOverflow;
        /// <summary>
        /// Set to true to leave space for a vertical scrollbar (if the OS shows space-consuming scrollbars) regardless
        /// of whether a scrollbar is needed.
        /// This is useful if content height changes during application usage, but you do not want the calculated width
        /// of child items to change when a scrollbar appears or disappears. The scrollbar will appear in the reserved space,
        /// and the calculated width of child Components will not change.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Employee', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// fields: [
        /// {name: 'rating', type: 'int'},
        /// {name: 'salary', type: 'float'},
        /// {name: 'name'}
        /// ]
        /// });
        /// function createFakeData(count) {
        /// var firstNames   = ['Ed', 'Tommy', 'Aaron', 'Abe', 'Jamie', 'Adam', 'Dave', 'David', 'Jay', 'Nicolas', 'Nige'],
        /// lastNames    = ['Spencer', 'Maintz', 'Conran', 'Elias', 'Avins', 'Mishcon', 'Kaneda', 'Davis', 'Robinson', 'Ferrero', 'White'],
        /// ratings      = [1, 2, 3, 4, 5],
        /// salaries     = [100, 400, 900, 1500, 1000000];
        /// var data = [];
        /// for (var i = 0; i &lt; (count || 25); i++) {
        /// var ratingId    = Math.floor(Math.random() * ratings.length),
        /// salaryId    = Math.floor(Math.random() * salaries.length),
        /// firstNameId = Math.floor(Math.random() * firstNames.length),
        /// lastNameId  = Math.floor(Math.random() * lastNames.length),
        /// rating      = ratings[ratingId],
        /// salary      = salaries[salaryId],
        /// name        = <see cref="Ext.String.format">Ext.String.format</see>("{0} {1}", firstNames[firstNameId], lastNames[lastNameId]);
        /// data.push({
        /// rating: rating,
        /// salary: salary,
        /// name: name
        /// });
        /// }
        /// store.loadData(data);
        /// }
        /// // create the Data Store
        /// var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
        /// id: 'store',
        /// model: 'Employee',
        /// proxy: {
        /// type: 'memory'
        /// }
        /// });
        /// createFakeData(10);
        /// var grid = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.grid.Panel">Ext.grid.Panel</see>', {
        /// title: 'Grid loaded with varying number of records',
        /// anchor: '100%',
        /// store: store,
        /// columns: [{
        /// xtype: 'rownumberer',
        /// width: 40,
        /// sortable: false
        /// },{
        /// text: 'Name',
        /// flex: 1,
        /// sortable: true,
        /// dataIndex: 'name'
        /// },{
        /// text: 'Rating',
        /// width: 125,
        /// sortable: true,
        /// dataIndex: 'rating'
        /// },{
        /// text: 'Salary',
        /// width: 125,
        /// sortable: true,
        /// dataIndex: 'salary',
        /// align: 'right',
        /// renderer: <see cref="Ext.util.Format.usMoney">Ext.util.Format.usMoney</see>
        /// }]
        /// });
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.panel.Panel">Ext.panel.Panel</see>', {
        /// renderTo: document.body,
        /// width: 800,
        /// height: 600,
        /// layout: {
        /// type: 'anchor',
        /// reserveScrollbar: true // There will be a gap even when there's no scrollbar
        /// },
        /// autoScroll: true,
        /// items: grid,
        /// tbar: {
        /// defaults: {
        /// handler: function(b) {
        /// createFakeData(b.count);
        /// }
        /// },
        /// items: [{
        /// text: '10 Items',
        /// count: 10
        /// },{
        /// text: '100 Items',
        /// count: 100
        /// },{
        /// text: '300 Items',
        /// count: 300
        /// },{
        /// text: '1000 Items',
        /// count: 1000
        /// },{
        /// text: '5000 Items',
        /// count: 5000
        /// }]
        /// }
        /// });
        /// </code>
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool reserveScrollbar;
        public ContainerConfig(params object[] args){}
    }
    #endregion
    #region ContainerEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ContainerEvents : LayoutEvents
    {
        public ContainerEvents(params object[] args){}
    }
    #endregion
}
