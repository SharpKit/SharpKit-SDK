//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.container
{
    #region AbstractContainer
    /// <inheritdocs />
    /// <summary>
    /// <p><strong>NOTE</strong> This is a private utility class for internal use by the framework. Don't rely on its existence.</p><p>An abstract base class which provides shared methods for Containers across the Sencha product line.</p>
    /// <p>Please refer to sub class's documentation</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractContainer : Ext.Component
    {
        /// <summary>
        /// A string component id or the numeric index of the component that should be
        /// initially activated within the container's layout on render.  For example,
        /// activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the
        /// container's collection).  activeItem only applies to layout styles that can
        /// display items one at a time (like Ext.layout.container.Card and
        /// Ext.layout.container.Fit).
        /// </summary>
        public object activeItem;
        /// <summary>
        /// If true the container will automatically destroy any contained component that is removed
        /// from it, else destruction must be handled manually.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool autoDestroy;
        /// <summary>
        /// An array of events that, when fired, should be bubbled to any parent container.
        /// See Ext.util.Observable.enableBubble.
        /// Defaults to: <c>[&quot;add&quot;, &quot;remove&quot;]</c>
        /// </summary>
        public JsString bubbleEvents;
        /// <summary>
        /// The default xtype of child Components to create in this Container when
        /// a child item is specified as a raw configuration object, rather than as an instantiated Component.
        /// Defaults to: <c>&quot;panel&quot;</c>
        /// </summary>
        public JsString defaultType;
        /// <summary>
        /// This option is a means of applying default settings to all added items whether added
        /// through the items config or via the add or insert methods.
        /// Defaults are applied to both config objects and instantiated components conditionally
        /// so as not to override existing properties in the item (see <see cref="Ext.ExtContext.applyIf">Ext.applyIf</see>).
        /// If the defaults option is specified as a function, then the function will be called
        /// using this Container as the scope (<c>this</c> reference) and passing the added item as
        /// the first parameter. Any resulting object from that call is then applied to the item
        /// as default properties.
        /// For example, to automatically apply padding to the body of each of a set of
        /// contained <see cref="Ext.panel.Panel">Ext.panel.Panel</see> items, you could pass:
        /// <c>defaults: {bodyStyle:'padding:15px'}</c>.
        /// Usage:
        /// <code>defaults: { // defaults are applied to items, not the container
        /// autoScroll: true
        /// },
        /// items: [
        /// // default will not be applied here, panel1 will be autoScroll: false
        /// {
        /// xtype: 'panel',
        /// id: 'panel1',
        /// autoScroll: false
        /// },
        /// // this component will have autoScroll: true
        /// new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// id: 'panel2'
        /// })
        /// ]
        /// </code>
        /// </summary>
        public object defaults;
        /// <summary>
        /// True to move any component to the detachedBody when the component is
        /// removed from this container. This option is only applicable when the component is not destroyed while
        /// being removed, see autoDestroy and remove. If this option is set to false, the DOM
        /// of the component will remain in the current place until it is explicitly moved.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool detachOnRemove;
        /// <summary>
        /// Important: In order for child items to be correctly sized and
        /// positioned, typically a layout manager must be specified through
        /// the layout configuration option.
        /// The sizing and positioning of child <see cref="Ext.container.AbstractContainerConfig.items">items</see> is the responsibility of
        /// the Container's layout manager which creates and manages the type of layout
        /// you have in mind.  For example:
        /// If the <see cref="Ext.container.AbstractContainerConfig.layout">layout</see> configuration is not explicitly specified for
        /// a general purpose container (e.g. Container or Panel) the
        /// <see cref="Ext.layout.container.Auto">default layout manager</see> will be used
        /// which does nothing but render child components sequentially into the
        /// Container (no sizing or positioning will be performed in this situation).
        /// <strong>layout</strong> may be specified as either as an Object or as a String:
        /// Specify as an Object
        /// Example usage:
        /// <code>layout: {
        /// type: 'vbox',
        /// align: 'left'
        /// }
        /// </code>
        /// <li><p><strong>type</strong></p>
        /// <p>The layout type to be used for this container.  If not specified,
        /// a default <see cref="Ext.layout.container.Auto">Ext.layout.container.Auto</see> will be created and used.</p>
        /// <p>Valid layout <c>type</c> values are:</p>
        /// <ul>
        /// <li><see cref="Ext.layout.container.Auto">Auto</see> - <strong>Default</strong></li>
        /// <li><see cref="Ext.layout.container.Card">card</see></li>
        /// <li><see cref="Ext.layout.container.Fit">fit</see></li>
        /// <li><see cref="Ext.layout.container.HBox">hbox</see></li>
        /// <li><see cref="Ext.layout.container.VBox">vbox</see></li>
        /// <li><see cref="Ext.layout.container.Anchor">anchor</see></li>
        /// <li><see cref="Ext.layout.container.Table">table</see></li>
        /// </ul>
        /// </li>
        /// <li><p>Layout specific configuration properties</p>
        /// <p>Additional layout specific configuration properties may also be
        /// specified. For complete details regarding the valid config options for
        /// each layout type, see the layout class corresponding to the <c>type</c>
        /// specified.</p></li>
        /// Specify as a String
        /// Example usage:
        /// <code>layout: 'vbox'
        /// </code>
        /// <li><p><strong>layout</strong></p>
        /// <p>The layout <c>type</c> to be used for this container (see list
        /// of valid layout type values above).</p>
        /// <p>Additional layout specific configuration properties. For complete
        /// details regarding the valid config options for each layout type, see the
        /// layout class corresponding to the <c>layout</c> specified.</p></li>
        /// Configuring the default layout type
        /// <code>If a certain Container class has a default layout (For example a <see cref="Ext.toolbar.Toolbar">Toolbar</see>
        /// with a default `Box` layout), then to simply configure the default layout,
        /// use an object, but without the `type` property:
        /// xtype: 'toolbar',
        /// layout: {
        /// pack: 'center'
        /// }
        /// </code>
        /// </summary>
        public object layout;
        /// <summary>
        /// If true, suspend calls to doLayout. Useful when batching multiple adds to a container
        /// and not passing them as multiple arguments or an array.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool suspendLayout;
        /// <summary>
        /// The MixedCollection containing all the child items of this container.
        /// </summary>
        public Ext.util.AbstractMixedCollection items{get;set;}
        /// <summary>
        /// The number of container layout calls made on this object.
        /// Defaults to: <c>0</c>
        /// </summary>
        private JsNumber layoutCounter{get;set;}
        /// <summary>
        /// Adds Component(s) to this Container.
        /// Description:
        /// <li>Fires the <see cref="Ext.container.AbstractContainerEvents.beforeadd">beforeadd</see> event before adding.</li>
        /// <li>The Container's <see cref="Ext.container.AbstractContainerConfig.defaults">default config values</see> will be applied
        /// accordingly (see <c><see cref="Ext.container.AbstractContainerConfig.defaults">defaults</see></c> for details).</li>
        /// <li>Fires the <c><see cref="Ext.container.AbstractContainerEvents.add">add</see></c> event after the component has been added.</li>
        /// Notes:
        /// If the Container is <strong>already rendered</strong> when <c>add</c>
        /// is called, it will render the newly added Component into its content area.
        /// <strong>If</strong> the Container was configured with a size-managing <see cref="Ext.container.AbstractContainerConfig.layout">layout</see> manager,
        /// the Container will recalculate its internal layout at this time too.
        /// Note that the default layout manager simply renders child Components sequentially
        /// into the content area and thereafter performs no sizing.
        /// If adding multiple new child Components, pass them as an array to the <c>add</c> method,
        /// so that only one layout recalculation is performed.
        /// <code>tb = new <see cref="Ext.toolbar.Toolbar">Ext.toolbar.Toolbar</see>({
        /// renderTo: document.body
        /// });  // toolbar is rendered
        /// // add multiple items.
        /// // (<see cref="Ext.container.AbstractContainerConfig.defaultType">defaultType</see> for <see cref="Ext.toolbar.Toolbar">Toolbar</see> is 'button')
        /// tb.add([{text:'Button 1'}, {text:'Button 2'}]);
        /// </code>
        /// To inject components between existing ones, use the <see cref="Ext.container.AbstractContainer.insert">insert</see> method.
        /// Warning:
        /// Components directly managed by the BorderLayout layout manager may not be removed
        /// or added.  See the Notes for <see cref="Ext.layout.container.Border">BorderLayout</see> for
        /// more details.
        /// </summary>
        /// <param name="component"><p>Either one or more Components to add or an Array of Components to add.
        /// See <c><see cref="Ext.container.AbstractContainerConfig.items">items</see></c> for additional information.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see>[]/<see cref="Ext.Component">Ext.Component</see></span><div><p>The Components that were added.</p>
        /// </div>
        /// </returns>
        public object[] add(params object[] component){return null;}
        /// <summary>
        /// Invoked after the Container has laid out (and rendered if necessary)
        /// its child Components.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="layout">
        /// </param>
        protected virtual void afterLayout(Ext.layout.container.Container layout){}
        /// <summary>
        /// Occurs before componentLayout is run. Returning false from this method
        /// will prevent the containerLayout from being executed.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        protected virtual void beforeLayout(){}
        /// <summary>
        /// Cascades down the component/container heirarchy from this component (passed in
        /// the first call), calling the specified function with each component. The scope
        /// (this reference) of the function call will be the scope provided or the current
        /// component. The arguments to the function will be the args provided or the current
        /// component. If the function returns false at any point, the cascade is stopped on
        /// that branch.
        /// </summary>
        /// <param name="fn"><p>The function to call</p>
        /// </param>
        /// <param name="scope"><p>The scope of the function (defaults to current component)</p>
        /// </param>
        /// <param name="args"><p>The args to call the function with. The current component
        /// always passed as the last argument.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.container.Container">Ext.Container</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.container.Container cascade(System.Delegate fn, object scope=null, object args=null){return null;}
        /// <summary>
        /// Retrieves the first direct child of this container which matches the passed selector.
        /// The passed in selector must comply with an Ext.ComponentQuery selector.
        /// </summary>
        /// <param name="selector"><p>An <see cref="Ext.ComponentQuery">Ext.ComponentQuery</see> selector. If no selector is
        /// specified, the first child will be returned.</p>
        /// </param>
        public AbstractContainer child(object selector=null){return null;}
        /// <summary>
        /// Manually force this container's layout to be recalculated. The framework uses this internally to refresh layouts
        /// form most cases.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.container.Container">Ext.container.Container</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.container.Container doLayout(){return null;}
        /// <summary>
        /// Retrieves the first descendant of this container which matches the passed selector.
        /// The passed in selector must comply with an Ext.ComponentQuery selector.
        /// </summary>
        /// <param name="selector"><p>An <see cref="Ext.ComponentQuery">Ext.ComponentQuery</see> selector. If no selector is
        /// specified, the first child will be returned.</p>
        /// </param>
        public AbstractContainer down(object selector=null){return null;}
        /// <summary>
        /// Gets a list of child components to enable/disable when the container is
        /// enabled/disabled
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see>[]</span><div><p>Items to be enabled/disabled</p>
        /// </div>
        /// </returns>
        private Ext.Component[] getChildItemsToDisable(){return null;}
        /// <summary>
        /// Examines this container's items property and gets a direct child
        /// component of this container.
        /// </summary>
        /// <param name="comp"><p>This parameter may be any of the following:</p>
        /// <ul>
        /// <li>a <strong>String</strong> : representing the <see cref="Ext.ComponentConfig.itemId">itemId</see>
        /// or <see cref="Ext.ComponentConfig.id">id</see> of the child component.</li>
        /// <li>a <strong>Number</strong> : representing the position of the child component
        /// within the <see cref="Ext.container.AbstractContainer.items">items</see> <strong>property</strong></li>
        /// </ul>
        /// <p>For additional information see <see cref="Ext.util.MixedCollection.get">Ext.util.MixedCollection.get</see>.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>The component (if found).</p>
        /// </div>
        /// </returns>
        public Ext.Component getComponent(object comp){return null;}
        /// <summary>
        /// Returns the layout instance currently associated with this Container.
        /// If a layout has not been instantiated yet, that is done first
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.layout.container.Container">Ext.layout.container.Container</see></span><div><p>The layout</p>
        /// </div>
        /// </returns>
        public Ext.layout.container.Container getLayout(){return null;}
        /// <summary>
        /// Inserts a Component into this Container at a specified index. Fires the
        /// beforeadd event before inserting, then fires the add
        /// event after the Component has been inserted.
        /// </summary>
        /// <param name="index"><p>The index at which the Component will be inserted
        /// into the Container's items collection</p>
        /// </param>
        /// <param name="component"><p>The child Component to insert.</p>
        /// <p>Ext uses lazy rendering, and will only render the inserted Component should
        /// it become necessary.</p>
        /// <p>A Component config object may be passed in order to avoid the overhead of
        /// constructing a real Component object if lazy rendering might mean that the
        /// inserted Component will not be rendered immediately. To take advantage of
        /// this 'lazy instantiation', set the <see cref="Ext.ComponentConfig.xtype">Ext.Component.xtype</see> config
        /// property to the registered type of the Component wanted.</p>
        /// <p>For a list of all available xtypes, see <see cref="Ext.Component">Ext.Component</see>.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>component The Component (or config object) that was
        /// inserted with the Container's default config values applied.</p>
        /// </div>
        /// </returns>
        public Ext.Component insert(JsNumber index, Ext.Component component){return null;}
        /// <summary>
        /// Determines whether this Container is an ancestor of the passed Component.
        /// This will return true if the passed Component is anywhere within the subtree
        /// beneath this Container.
        /// </summary>
        /// <param name="possibleDescendant"><p>The Component to test for presence
        /// within this Container's subtree.</p>
        /// </param>
        public void isAncestor(Ext.Component possibleDescendant){}
        /// <summary>
        /// Moves a Component within the Container
        /// </summary>
        /// <param name="fromIdx"><p>The index the Component you wish to move is currently at.</p>
        /// </param>
        /// <param name="toIdx"><p>The new index for the Component.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>component The Component (or config object) that was moved.</p>
        /// </div>
        /// </returns>
        public Ext.Component move(JsNumber fromIdx, JsNumber toIdx){return null;}
        /// <summary>
        /// This method is invoked after a new Component has been added. It
        /// is passed the Component which has been added. This method may
        /// be used to update any internal structure which may depend upon
        /// the state of the child items.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="component">
        /// </param>
        /// <param name="position">
        /// </param>
        protected virtual void onAdd(Ext.Component component, JsNumber position){}
        /// <summary>
        /// This method is invoked before adding a new child Component. It
        /// is passed the new Component, and may be used to modify the
        /// Component, or prepare the Container in some way. Returning
        /// false aborts the add operation.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="item">
        /// </param>
        protected virtual void onBeforeAdd(Ext.Component item){}
        /// <summary>
        /// This method is invoked after a new Component has been
        /// removed. It is passed the Component which has been
        /// removed. This method may be used to update any internal
        /// structure which may depend upon the state of the child items.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="component">
        /// </param>
        /// <param name="autoDestroy">
        /// </param>
        protected virtual void onRemove(Ext.Component component, bool autoDestroy){}
        /// <summary>
        /// Retrieves all descendant components which match the passed selector.
        /// Executes an Ext.ComponentQuery.query using this container as its root.
        /// </summary>
        /// <param name="selector"><p>Selector complying to an <see cref="Ext.ComponentQuery">Ext.ComponentQuery</see> selector.
        /// If no selector is specified all items will be returned.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see>[]</span><div><p>Components which matched the selector</p>
        /// </div>
        /// </returns>
        public Ext.Component[] query(object selector=null){return null;}
        /// <summary>
        /// Retrieves all descendant components which match the passed function.
        /// The function should return false for components that are to be
        /// excluded from the selection.
        /// </summary>
        /// <param name="fn"><p>The matcher function. It will be called with a single argument,
        /// the component being tested.</p>
        /// </param>
        /// <param name="scope"><p>The scope in which to run the function. If not specified,
        /// it will default to the active component.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see>[]</span><div><p>Components matched by the passed function</p>
        /// </div>
        /// </returns>
        public Ext.Component[] queryBy(System.Delegate fn, object scope=null){return null;}
        /// <summary>
        /// Finds a component at any level under this container matching the id/itemId.
        /// This is a shorthand for calling ct.down('#' + id);
        /// </summary>
        /// <param name="id"><p>The id to find</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>The matching id, null if not found</p>
        /// </div>
        /// </returns>
        public Ext.Component queryById(JsString id){return null;}
        /// <summary>
        /// Removes a component from this container.  Fires the beforeremove event
        /// before removing, then fires the remove event after the component has
        /// been removed.
        /// </summary>
        /// <param name="component"><p>The component reference or id to remove.</p>
        /// </param>
        /// <param name="autoDestroy"><p>True to automatically invoke the removed Component's
        /// <see cref="Ext.Component">Ext.Component.destroy</see> function.</p>
        /// <p>Defaults to the value of this Container's <see cref="Ext.container.AbstractContainerConfig.autoDestroy">autoDestroy</see> config.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>component The Component that was removed.</p>
        /// </div>
        /// </returns>
        public Ext.Component remove(object component, object autoDestroy=null){return null;}
        /// <summary>
        /// Removes all components from this container.
        /// </summary>
        /// <param name="autoDestroy"><p>True to automatically invoke the removed
        /// Component's <see cref="Ext.Component">Ext.Component.destroy</see> function.
        /// Defaults to the value of this Container's <see cref="Ext.container.AbstractContainerConfig.autoDestroy">autoDestroy</see> config.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see>[]</span><div><p>Array of the removed components</p>
        /// </div>
        /// </returns>
        public Ext.Component[] removeAll(object autoDestroy=null){return null;}
        public AbstractContainer(AbstractContainerConfig config){}
        public AbstractContainer(){}
        public AbstractContainer(params object[] args){}
    }
    #endregion
    #region AbstractContainerConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractContainerConfig : Ext.ComponentConfig
    {
        /// <summary>
        /// A string component id or the numeric index of the component that should be
        /// initially activated within the container's layout on render.  For example,
        /// activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the
        /// container's collection).  activeItem only applies to layout styles that can
        /// display items one at a time (like Ext.layout.container.Card and
        /// Ext.layout.container.Fit).
        /// </summary>
        public object activeItem;
        /// <summary>
        /// If true the container will automatically destroy any contained component that is removed
        /// from it, else destruction must be handled manually.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool autoDestroy;
        /// <summary>
        /// An array of events that, when fired, should be bubbled to any parent container.
        /// See Ext.util.Observable.enableBubble.
        /// Defaults to: <c>[&quot;add&quot;, &quot;remove&quot;]</c>
        /// </summary>
        public JsString bubbleEvents;
        /// <summary>
        /// The default xtype of child Components to create in this Container when
        /// a child item is specified as a raw configuration object, rather than as an instantiated Component.
        /// Defaults to: <c>&quot;panel&quot;</c>
        /// </summary>
        public JsString defaultType;
        /// <summary>
        /// This option is a means of applying default settings to all added items whether added
        /// through the items config or via the add or insert methods.
        /// Defaults are applied to both config objects and instantiated components conditionally
        /// so as not to override existing properties in the item (see <see cref="Ext.ExtContext.applyIf">Ext.applyIf</see>).
        /// If the defaults option is specified as a function, then the function will be called
        /// using this Container as the scope (<c>this</c> reference) and passing the added item as
        /// the first parameter. Any resulting object from that call is then applied to the item
        /// as default properties.
        /// For example, to automatically apply padding to the body of each of a set of
        /// contained <see cref="Ext.panel.Panel">Ext.panel.Panel</see> items, you could pass:
        /// <c>defaults: {bodyStyle:'padding:15px'}</c>.
        /// Usage:
        /// <code>defaults: { // defaults are applied to items, not the container
        /// autoScroll: true
        /// },
        /// items: [
        /// // default will not be applied here, panel1 will be autoScroll: false
        /// {
        /// xtype: 'panel',
        /// id: 'panel1',
        /// autoScroll: false
        /// },
        /// // this component will have autoScroll: true
        /// new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// id: 'panel2'
        /// })
        /// ]
        /// </code>
        /// </summary>
        public object defaults;
        /// <summary>
        /// True to move any component to the detachedBody when the component is
        /// removed from this container. This option is only applicable when the component is not destroyed while
        /// being removed, see autoDestroy and remove. If this option is set to false, the DOM
        /// of the component will remain in the current place until it is explicitly moved.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool detachOnRemove;
        /// <summary>
        /// A single item, or an array of child Components to be added to this container
        /// <strong>Unless configured with a <see cref="Ext.container.AbstractContainerConfig.layout">layout</see>, a Container simply renders child
        /// Components serially into its encapsulating element and performs no sizing or
        /// positioning upon them.</strong>
        /// Example:
        /// <code>// specifying a single item
        /// items: {...},
        /// layout: 'fit',    // The single items is sized to fit
        /// // specifying multiple items
        /// items: [{...}, {...}],
        /// layout: 'hbox', // The items are arranged horizontally
        /// </code>
        /// Each item may be:
        /// <li>A <see cref="Ext.Component">Component</see></li>
        /// <li>A Component configuration object</li>
        /// If a configuration object is specified, the actual type of Component to be
        /// instantiated my be indicated by using the <see cref="Ext.ComponentConfig.xtype">xtype</see> option.
        /// Every Component class has its own <see cref="Ext.ComponentConfig.xtype">xtype</see>.
        /// If an <see cref="Ext.ComponentConfig.xtype">xtype</see> is not explicitly specified, the
        /// <see cref="Ext.container.AbstractContainerConfig.defaultType">defaultType</see> for the Container is used, which by default is usually <c>panel</c>.
        /// Notes:
        /// Ext uses lazy rendering. Child Components will only be rendered
        /// should it become necessary. Items are automatically laid out when they are first
        /// shown (no sizing is done while hidden), or in response to a <see cref="Ext.container.AbstractContainer.doLayout">doLayout</see> call.
        /// Do not specify <see cref="Ext.panel.PanelConfig.contentEl">contentEl</see> or
        /// <see cref="Ext.panel.PanelConfig.html">html</see> with <c>items</c>.
        /// </summary>
        public object items;
        /// <summary>
        /// Important: In order for child items to be correctly sized and
        /// positioned, typically a layout manager must be specified through
        /// the layout configuration option.
        /// The sizing and positioning of child <see cref="Ext.container.AbstractContainerConfig.items">items</see> is the responsibility of
        /// the Container's layout manager which creates and manages the type of layout
        /// you have in mind.  For example:
        /// If the <see cref="Ext.container.AbstractContainerConfig.layout">layout</see> configuration is not explicitly specified for
        /// a general purpose container (e.g. Container or Panel) the
        /// <see cref="Ext.layout.container.Auto">default layout manager</see> will be used
        /// which does nothing but render child components sequentially into the
        /// Container (no sizing or positioning will be performed in this situation).
        /// <strong>layout</strong> may be specified as either as an Object or as a String:
        /// Specify as an Object
        /// Example usage:
        /// <code>layout: {
        /// type: 'vbox',
        /// align: 'left'
        /// }
        /// </code>
        /// <li><p><strong>type</strong></p>
        /// <p>The layout type to be used for this container.  If not specified,
        /// a default <see cref="Ext.layout.container.Auto">Ext.layout.container.Auto</see> will be created and used.</p>
        /// <p>Valid layout <c>type</c> values are:</p>
        /// <ul>
        /// <li><see cref="Ext.layout.container.Auto">Auto</see> - <strong>Default</strong></li>
        /// <li><see cref="Ext.layout.container.Card">card</see></li>
        /// <li><see cref="Ext.layout.container.Fit">fit</see></li>
        /// <li><see cref="Ext.layout.container.HBox">hbox</see></li>
        /// <li><see cref="Ext.layout.container.VBox">vbox</see></li>
        /// <li><see cref="Ext.layout.container.Anchor">anchor</see></li>
        /// <li><see cref="Ext.layout.container.Table">table</see></li>
        /// </ul>
        /// </li>
        /// <li><p>Layout specific configuration properties</p>
        /// <p>Additional layout specific configuration properties may also be
        /// specified. For complete details regarding the valid config options for
        /// each layout type, see the layout class corresponding to the <c>type</c>
        /// specified.</p></li>
        /// Specify as a String
        /// Example usage:
        /// <code>layout: 'vbox'
        /// </code>
        /// <li><p><strong>layout</strong></p>
        /// <p>The layout <c>type</c> to be used for this container (see list
        /// of valid layout type values above).</p>
        /// <p>Additional layout specific configuration properties. For complete
        /// details regarding the valid config options for each layout type, see the
        /// layout class corresponding to the <c>layout</c> specified.</p></li>
        /// Configuring the default layout type
        /// <code>If a certain Container class has a default layout (For example a <see cref="Ext.toolbar.Toolbar">Toolbar</see>
        /// with a default `Box` layout), then to simply configure the default layout,
        /// use an object, but without the `type` property:
        /// xtype: 'toolbar',
        /// layout: {
        /// pack: 'center'
        /// }
        /// </code>
        /// </summary>
        public object layout;
        /// <summary>
        /// If true, suspend calls to doLayout. Useful when batching multiple adds to a container
        /// and not passing them as multiple arguments or an array.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool suspendLayout;
        public AbstractContainerConfig(params object[] args){}
    }
    #endregion
    #region AbstractContainerEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractContainerEvents : Ext.ComponentEvents
    {
        /// <summary>
        /// Fires after any Ext.Component is added or inserted into the container.
        /// <strong>This event bubbles:</strong> 'add' will also be fired when Component is added to any of
        /// the child containers or their childern or ...
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="component"><p>The component that was added</p>
        /// </param>
        /// <param name="index"><p>The index at which the component was added to the container's items collection</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void add(Ext.container.Container @this, Ext.Component component, JsNumber index, object eOpts){}
        /// <summary>
        /// Fires when the components in this container are arranged by the associated layout manager.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="layout"><p>The ContainerLayout implementation for this container</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void afterlayout(Ext.container.Container @this, Ext.layout.container.Container layout, object eOpts){}
        /// <summary>
        /// Fires before any Ext.Component is added or inserted into the container.
        /// A handler can return false to cancel the add.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="component"><p>The component being added</p>
        /// </param>
        /// <param name="index"><p>The index at which the component will be added to the container's items collection</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforeadd(Ext.container.Container @this, Ext.Component component, JsNumber index, object eOpts){}
        /// <summary>
        /// Fires before any Ext.Component is removed from the container.  A handler can return
        /// false to cancel the remove.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="component"><p>The component being removed</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforeremove(Ext.container.Container @this, Ext.Component component, object eOpts){}
        /// <summary>
        /// Fires after any Ext.Component is removed from the container.
        /// <strong>This event bubbles:</strong> 'remove' will also be fired when Component is removed from any of
        /// the child containers or their children or ...
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="component"><p>The component that was removed</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void remove(Ext.container.Container @this, Ext.Component component, object eOpts){}
        public AbstractContainerEvents(params object[] args){}
    }
    #endregion
}
