//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.data
{
    #region AbstractStore
    /// <inheritdocs />
    /// <summary>
    /// <p>AbstractStore is a superclass of <see cref="Ext.data.Store">Ext.data.Store</see> and <see cref="Ext.data.TreeStore">Ext.data.TreeStore</see>. It's never used directly,
    /// but offers a set of methods used by both of those subclasses.</p>
    /// <p>We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
    /// you're probably looking for is <see cref="Ext.data.Store">Ext.data.Store</see>. If you're still interested, here's a brief description of what
    /// AbstractStore is and is not.</p>
    /// <p>AbstractStore provides the basic configuration for anything that can be considered a Store. It expects to be
    /// given a <see cref="Ext.data.Model">Model</see> that represents the type of data in the Store. It also expects to be given a
    /// <see cref="Ext.data.proxy.Proxy">Proxy</see> that handles the loading of data into the Store.</p>
    /// <p>AbstractStore provides a few helpful methods such as <see cref="Ext.data.AbstractStore.load">load</see> and <see cref="Ext.data.AbstractStore.sync">sync</see>, which load and save data
    /// respectively, passing the requests through the configured <see cref="Ext.data.AbstractStoreConfig.proxy">proxy</see>. Both built-in Store subclasses add extra
    /// behavior to each of these functions. Note also that each AbstractStore subclass has its own way of storing data -
    /// in <see cref="Ext.data.Store">Ext.data.Store</see> the data is saved as a flat <see cref="Ext.util.MixedCollection">MixedCollection</see>, whereas in
    /// <see cref="Ext.data.TreeStore">TreeStore</see> we use a <see cref="Ext.data.Tree">Ext.data.Tree</see> to maintain the data's hierarchy.</p>
    /// <p>The store provides filtering and sorting support. This sorting/filtering can happen on the client side
    /// or can be completed on the server. This is controlled by the <see cref="Ext.data.StoreConfig.remoteSort">remoteSort</see> and
    /// <see cref="Ext.data.StoreConfig.remoteFilter">remoteFilter</see> config options. For more information see the <see cref="Ext.data.AbstractStore.sort">sort</see> and
    /// <see cref="Ext.data.Store.filter">filter</see> methods.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractStore : Ext.Base, Ext.util.Observable, Ext.util.Sortable
    {
        /// <summary>
        /// If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
        /// after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
        /// Defaults to false.
        /// </summary>
        public object autoLoad;
        /// <summary>
        /// True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool autoSync;
        /// <summary>
        /// Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
        /// internal representation of the data after each operation of the batch has completed, 'complete' will wait until
        /// the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
        /// storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
        /// Defaults to: <c>&quot;operation&quot;</c>
        /// </summary>
        public JsString batchUpdateMode;
        /// <summary>
        /// This may be used in place of specifying a model configuration. The fields should be a
        /// set of Ext.data.Field configuration objects. The store will automatically create a Ext.data.Model
        /// with these fields. In general this configuration option should only be used for simple stores like
        /// a two-field store of ComboBox. For anything more complicated, such as specifying a particular id property or
        /// associations, a Ext.data.Model should be defined and specified for the model
        /// config.
        /// </summary>
        public JsObject fields;
        /// <summary>
        /// If true, any filters attached to this Store will be run after loading data, before the datachanged event is fired.
        /// Defaults to true, ignored if remoteFilter is true
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool filterOnLoad;
        /// <summary>
        /// A config object containing one or more event handlers to be added to this object during initialization. This
        /// should be a valid listeners config object as specified in the addListener example for attaching multiple
        /// handlers at once.
        /// <strong>DOM events from Ext JS <see cref="Ext.Component">Components</see></strong>
        /// While <em>some</em> Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
        /// only done when extra value can be added. For example the <see cref="Ext.view.View">DataView</see>'s <strong><c><see cref="Ext.view.ViewEvents.itemclick">itemclick</see></c></strong> event passing the node clicked on. To access DOM events directly from a
        /// child element of a Component, we need to specify the <c>element</c> option to identify the Component property to add a
        /// DOM listener to:
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// width: 400,
        /// height: 200,
        /// dockedItems: [{
        /// xtype: 'toolbar'
        /// }],
        /// listeners: {
        /// click: {
        /// element: 'el', //bind to the underlying el property on the panel
        /// fn: function(){ console.log('click el'); }
        /// },
        /// dblclick: {
        /// element: 'body', //bind to the underlying body property on the panel
        /// fn: function(){ console.log('dblclick body'); }
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsObject listeners;
        /// <summary>
        /// Name of the Model associated with this store.
        /// The string is used as an argument for Ext.ModelManager.getModel.
        /// </summary>
        public JsString model;
        /// <summary>
        /// The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
        /// see setProxy for details.
        /// </summary>
        public object proxy;
        /// <summary>
        /// True to defer any filtering operation to the server. If false, filtering is done locally on the client.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool remoteFilter;
        /// <summary>
        /// True to defer any sorting operation to the server. If false, sorting is done locally on the client.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool remoteSort;
        /// <summary>
        /// If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
        /// Defaults to true, igored if remoteSort is true
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool sortOnLoad;
        /// <summary>
        /// Unique identifier for this store. If present, this Store will be registered with the Ext.data.StoreManager,
        /// making it easy to reuse elsewhere.
        /// Note that when store is instatiated by Controller, the storeId will be overridden by the name of the store.
        /// </summary>
        public JsString storeId;
        /// <summary>
        /// The string type of the Proxy to create if none is specified. This defaults to creating a
        /// memory proxy.
        /// Defaults to: <c>&quot;memory&quot;</c>
        /// </summary>
        public JsString defaultProxyType{get;set;}
        /// <summary>
        /// The default sort direction to use if one is not specified.
        /// Defaults to: <c>&quot;ASC&quot;</c>
        /// </summary>
        public JsString defaultSortDirection{get;set;}
        /// <summary>
        /// Initial suspended call count. Incremented when suspendEvents is called, decremented when resumeEvents is called.
        /// Defaults to: <c>0</c>
        /// </summary>
        public JsNumber eventsSuspended{get;set;}
        /// <summary>
        /// The collection of Filters currently applied to this Store
        /// </summary>
        public Ext.util.MixedCollection filters{get;set;}
        /// <summary>
        /// This object holds a key for any event that has a listener. The listener may be set
        /// directly on the instance, or on its class or a super class (via observe) or
        /// on the MVC EventBus. The values of this object are truthy
        /// (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
        /// of listeners. The value for an event is truthy if the event must be fired and is
        /// falsy if there is no need to fire the event.
        /// The intended use of this property is to avoid the expense of fireEvent calls when
        /// there are no listeners. This can be particularly helpful when one would otherwise
        /// have to call fireEvent hundreds or thousands of times. It is used like this:
        /// <code> if (this.hasListeners.foo) {
        /// this.fireEvent('foo', this, arg1);
        /// }
        /// </code>
        /// </summary>
        public JsObject hasListeners{get;set;}
        /// <summary>
        /// True if a model was created implicitly for this Store. This happens if a fields array is passed to the Store's
        /// constructor instead of a model constructor or name.
        /// Defaults to: <c>false</c>
        /// </summary>
        private bool implicitModel{get;set;}
        /// <summary>
        /// True if the Store has already been destroyed. If this is true, the reference to Store should be deleted
        /// as it will not function correctly any more.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool isDestroyed{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Observable, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool isObservable{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Sortable, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool isSortable{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Store, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool isStore{get;set;}
        /// <summary>
        /// A set of default values to be applied to every model instance added via insert or created
        /// via createModel. This is used internally by associations to set foreign keys and
        /// other fields. See the Association classes source code for examples. This should not need to be used by application developers.
        /// </summary>
        private JsObject modelDefaults{get;set;}
        /// <summary>
        /// Temporary cache in which removed model instances are kept until successfully synchronised with a Proxy,
        /// at which point this is cleared.
        /// Defaults to: <c>[]</c>
        /// </summary>
        protected Ext.data.Model removed{get;set;}
        /// <summary>
        /// The property in each item that contains the data to sort.
        /// </summary>
        public JsString sortRoot{get;set;}
        /// <summary>
        /// The collection of Sorters currently applied to this Store
        /// </summary>
        public Ext.util.MixedCollection sorters{get;set;}
        /// <summary>
        /// Adds the specified events to the list of events which this Observable may fire.
        /// </summary>
        /// <param name="eventNames"><p>Either an object with event names as properties with
        /// a value of <c>true</c>. For example:</p>
        /// <pre><code>this.addEvents({
        /// storeloaded: true,
        /// storecleared: true
        /// });
        /// </code></pre>
        /// <p>Or any number of event names as separate parameters. For example:</p>
        /// <pre><code>this.addEvents('storeloaded', 'storecleared');
        /// </code></pre>
        /// </param>
        public virtual void addEvents(object eventNames){}
        /// <summary>
        /// Appends an event handler to this object.  For example:
        /// <code>myGridPanel.on("mouseover", this.onMouseOver, this);
        /// </code>
        /// The method also allows for a single argument to be passed which is a config object
        /// containing properties which specify multiple events. For example:
        /// <code>myGridPanel.on({
        /// cellClick: this.onCellClick,
        /// mouseover: this.onMouseOver,
        /// mouseout: this.onMouseOut,
        /// scope: this // Important. Ensure "this" is correct during handler execution
        /// });
        /// </code>
        /// One can also specify options for each event handler separately:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: this.onCellClick, scope: this, single: true},
        /// mouseover: {fn: panel.onMouseOver, scope: panel}
        /// });
        /// </code>
        /// <em>Names</em> of methods in a specified scope may also be used. Note that
        /// <c>scope</c> MUST be specified to use this option:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: 'onCellClick', scope: this, single: true},
        /// mouseover: {fn: 'onMouseOver', scope: panel}
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventName"><p>The name of the event to listen for.
        /// May also be an object who's property names are event names.</p>
        /// </param>
        /// <param name="fn"><p>The method the event invokes, or <em>if <c>scope</c> is specified, the </em>name* of the method within
        /// the specified <c>scope</c>.  Will be called with arguments
        /// given to <see cref="Ext.util.Observable.fireEvent">fireEvent</see> plus the <c>options</c> parameter described below.</p>
        /// </param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the handler function is
        /// executed. <strong>If omitted, defaults to the object which fired the event.</strong></p>
        /// </param>
        /// <param name="options"><p>An object containing handler configuration.</p>
        /// <p><strong>Note:</strong> Unlike in ExtJS 3.x, the options object will also be passed as the last
        /// argument to every event handler.</p>
        /// <p>This object may contain any of the following properties:</p>
        /// <ul><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope (<c>this</c> reference) in which the handler function is executed. <strong>If omitted,
        /// defaults to the object which fired the event.</strong></p>
        /// </div></li><li><span>delay</span> : <see cref="Number">Number</see><div><p>The number of milliseconds to delay the invocation of the handler after the event fires.</p>
        /// </div></li><li><span>single</span> : <see cref="bool">Boolean</see><div><p>True to add a handler to handle just the next firing of the event, and then remove itself.</p>
        /// </div></li><li><span>buffer</span> : <see cref="Number">Number</see><div><p>Causes the handler to be scheduled to run in an <see cref="Ext.util.DelayedTask">Ext.util.DelayedTask</see> delayed
        /// by the specified number of milliseconds. If the event fires again within that time,
        /// the original handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p>
        /// </div></li><li><span>target</span> : <see cref="Ext.util.Observable">Ext.util.Observable</see><div><p>Only call the handler if the event was fired on the target Observable, <em>not</em> if the event
        /// was bubbled up from a child Observable.</p>
        /// </div></li><li><span>element</span> : <see cref="String">String</see><div><p><strong>This option is only valid for listeners bound to <see cref="Ext.Component">Components</see>.</strong>
        /// The name of a Component property which references an element to add a listener to.</p>
        /// <p>  This option is useful during Component construction to add DOM event listeners to elements of
        /// <see cref="Ext.Component">Components</see> which will exist only after the Component is rendered.
        /// For example, to add a click listener to a Panel's body:</p>
        /// <pre><code>  new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'The title',
        /// listeners: {
        /// click: this.handlePanelClick,
        /// element: 'body'
        /// }
        /// });
        /// </code></pre>
        /// <p><strong>Combining Options</strong></p>
        /// <p>Using the options argument, it is possible to combine different types of listeners:</p>
        /// <p>A delayed, one-time listener.</p>
        /// <pre><code>myPanel.on('hide', this.handleClick, this, {
        /// single: true,
        /// delay: 100
        /// });
        /// </code></pre>
        /// </div></li></ul></param>
        public virtual void addListener(object eventName, System.Delegate fn=null, object scope=null, object options=null){}
        /// <summary>
        /// Adds listeners to any Observable object (or Ext.Element) which are automatically removed when this Component is
        /// destroyed.
        /// </summary>
        /// <param name="item"><p>The item to which to add a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        /// <param name="opt"><p>If the <c>ename</c> parameter was an event name, this is the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> options.</p>
        /// </param>
        public virtual void addManagedListener(object item, object ename, System.Delegate fn=null, object scope=null, object opt=null){}
        /// <summary>
        /// A model instance should call this method on the Store it has been joined to.
        /// </summary>
        /// <param name="record"><p>The model instance that was edited</p>
        /// </param>
        private void afterCommit(Ext.data.Model record){}
        /// <summary>
        /// A model instance should call this method on the Store it has been joined to.
        /// </summary>
        /// <param name="record"><p>The model instance that was edited</p>
        /// </param>
        /// <param name="modifiedFieldNames"><p>Array of field names changed during edit.</p>
        /// </param>
        private void afterEdit(Ext.data.Model record, object modifiedFieldNames=null){}
        /// <summary>
        /// A model instance should call this method on the Store it has been joined to..
        /// </summary>
        /// <param name="record"><p>The model instance that was edited</p>
        /// </param>
        private void afterReject(Ext.data.Model record){}
        /// <summary>
        /// Removes all listeners for this object including the managed listeners
        /// </summary>
        public virtual void clearListeners(){}
        /// <summary>
        /// Removes all managed listeners for this object.
        /// </summary>
        public virtual void clearManagedListeners(){}
        /// <summary>
        /// Continue to fire event.
        /// </summary>
        /// <param name="eventName">
        /// </param>
        /// <param name="args">
        /// </param>
        /// <param name="bubbles">
        /// </param>
        public virtual void continueFireEvent(JsString eventName, object args=null, object bubbles=null){}
        /// <summary>
        /// Creates an event handling function which refires the event from this object as the passed event name.
        /// </summary>
        /// <param name="newName">
        /// </param>
        /// <param name="beginEnd"><p>The caller can specify on which indices to slice</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Function">Function</see></span><div>
        /// </div>
        /// </returns>
        public virtual System.Delegate createRelayer(object newName, object beginEnd=null){return null;}
        /// <summary>
        /// Normalizes an array of filter objects, ensuring that they are all Ext.util.Filter instances
        /// </summary>
        /// <param name="filters"><p>The filters array</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.util.Filter">Ext.util.Filter</see>[]</span><div><p>Array of <see cref="Ext.util.Filter">Ext.util.Filter</see> objects</p>
        /// </div>
        /// </returns>
        private Ext.util.Filter[] decodeFilters(JsArray<Object> filters){return null;}
        /// <summary>
        /// Normalizes an array of sorter objects, ensuring that they are all Ext.util.Sorter instances
        /// </summary>
        /// <param name="sorters"><p>The sorters array</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see>[]</span><div><p>Array of <see cref="Ext.util.Sorter">Ext.util.Sorter</see> objects</p>
        /// </div>
        /// </returns>
        public virtual Ext.util.Sorter[] decodeSorters(JsArray<Object> sorters){return null;}
        /// <summary>
        /// Enables events fired by this Observable to bubble up an owner hierarchy by calling this.getBubbleTarget() if
        /// present. There is no implementation in the Observable base class.
        /// This is commonly used by Ext.Components to bubble events to owner Containers.
        /// See <see cref="Ext.Component.getBubbleTarget">Ext.Component.getBubbleTarget</see>. The default implementation in <see cref="Ext.Component">Ext.Component</see> returns the
        /// Component's immediate owner. But if a known target is required, this can be overridden to access the
        /// required target more quickly.
        /// Example:
        /// <code><see cref="Ext.ExtContext.override">Ext.override</see>(<see cref="Ext.form.field.Base">Ext.form.field.Base</see>, {
        /// //  Add functionality to Field's initComponent to enable the change event to bubble
        /// initComponent : <see cref="Ext.Function.createSequence">Ext.Function.createSequence</see>(Ext.form.field.Base.prototype.initComponent, function() {
        /// this.enableBubble('change');
        /// }),
        /// //  We know that we want Field's events to bubble directly to the FormPanel.
        /// getBubbleTarget : function() {
        /// if (!this.formPanel) {
        /// this.formPanel = this.findParentByType('form');
        /// }
        /// return this.formPanel;
        /// }
        /// });
        /// var myForm = new Ext.formPanel({
        /// title: 'User Details',
        /// items: [{
        /// ...
        /// }],
        /// listeners: {
        /// change: function() {
        /// // Title goes red if form has been modified.
        /// myForm.header.setStyle('color', 'red');
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventNames"><p>The event name to bubble, or an Array of event names.</p>
        /// </param>
        public virtual void enableBubble(object eventNames){}
        /// <summary>
        /// Filter function for new records.
        /// </summary>
        /// <param name="item">
        /// </param>
        private void filterNew(object item){}
        /// <summary>
        /// Filter function for updated records.
        /// </summary>
        /// <param name="item">
        /// </param>
        private void filterUpdated(object item){}
        /// <summary>
        /// Fires the specified event with the passed parameters (minus the event name, plus the options object passed
        /// to addListener).
        /// An event may be set to bubble up an Observable parent hierarchy (See <see cref="Ext.Component.getBubbleTarget">Ext.Component.getBubbleTarget</see>) by
        /// calling <see cref="Ext.util.Observable.enableBubble">enableBubble</see>.
        /// </summary>
        /// <param name="eventName"><p>The name of the event to fire.</p>
        /// </param>
        /// <param name="args"><p>Variable number of parameters are passed to handlers.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>returns false if any of the handlers return false otherwise it returns true.</p>
        /// </div>
        /// </returns>
        public virtual bool fireEvent(JsString eventName, params object[] args){return false;}
        /// <summary>
        /// Returns a comparator function which compares two items and returns -1, 0, or 1 depending
        /// on the currently defined set of sorters.
        /// If there are no <see cref="Ext.util.Sortable.sorters">sorters</see> defined, it returns a function which returns <c>0</c> meaning that no sorting will occur.
        /// </summary>
        public virtual void generateComparator(){}
        /// <summary>
        /// Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
        /// This is broken out into a separate function to allow for customisation of the listeners
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The listeners object</p>
        /// </div>
        /// </returns>
        private object getBatchListeners(){return null;}
        /// <summary>
        /// Gets the bubbling parent for an Observable
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.util.Observable">Ext.util.Observable</see></span><div><p>The bubble parent. null is returned if no bubble target exists</p>
        /// </div>
        /// </returns>
        public virtual Ext.util.Observable getBubbleParent(){return null;}
        /// <summary>
        /// Gets the first sorter from the sorters collection, excluding
        /// any groupers that may be in place
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see></span><div><p>The sorter, null if none exist</p>
        /// </div>
        /// </returns>
        public virtual Ext.util.Sorter getFirstSorter(){return null;}
        /// <summary>
        /// Gets all records added or updated since the last commit. Note that the order of records
        /// returned is not deterministic and does not indicate the order in which records were modified. Note also that
        /// removed records are not included (use getRemovedRecords for that).
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see>[]</span><div><p>The added and updated Model instances</p>
        /// </div>
        /// </returns>
        public Ext.data.Model[] getModifiedRecords(){return null;}
        /// <summary>
        /// Returns all Model instances that are either currently a phantom (e.g. have no id), or have an ID but have not
        /// yet been saved on this Store (this happens when adding a non-phantom record from another Store into this one)
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see>[]</span><div><p>The Model instances</p>
        /// </div>
        /// </returns>
        public Ext.data.Model[] getNewRecords(){return null;}
        /// <summary>
        /// Returns the proxy currently attached to this proxy instance
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.data.proxy.Proxy">Ext.data.proxy.Proxy</see></span><div><p>The Proxy instance</p>
        /// </div>
        /// </returns>
        public Ext.data.proxy.Proxy getProxy(){return null;}
        /// <summary>
        /// Returns any records that have been removed from the store but not yet destroyed on the proxy.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see>[]</span><div><p>The removed Model instances</p>
        /// </div>
        /// </returns>
        public Ext.data.Model[] getRemovedRecords(){return null;}
        /// <summary>
        /// Returns all Model instances that have been updated in the Store but not yet synchronized with the Proxy
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see>[]</span><div><p>The updated Model instances</p>
        /// </div>
        /// </returns>
        public Ext.data.Model[] getUpdatedRecords(){return null;}
        /// <summary>
        /// Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
        /// indicates whether the event needs firing or not.
        /// </summary>
        /// <param name="eventName"><p>The name of the event to check for</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p><c>true</c> if the event is being listened for or bubbles, else <c>false</c></p>
        /// </div>
        /// </returns>
        public virtual bool hasListener(JsString eventName){return false;}
        /// <summary>
        /// Performs initialization of this mixin. Component classes using this mixin should call this method during their
        /// own initialization.
        /// </summary>
        public virtual void initSortable(){}
        /// <summary>
        /// Returns true if the Store is currently performing a load operation
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if the Store is currently loading</p>
        /// </div>
        /// </returns>
        public bool isLoading(){return false;}
        /// <summary>
        /// Loads the Store using its configured proxy.
        /// </summary>
        /// <param name="options"><p>config object. This is passed into the <see cref="Ext.data.Operation">Operation</see>
        /// object that is created and then sent to the proxy's <see cref="Ext.data.proxy.Proxy.read">Ext.data.proxy.Proxy.read</see> function</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Store">Ext.data.Store</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.data.Store load(object options=null){return null;}
        /// <summary>
        /// Shorthand for addManagedListener.
        /// Adds listeners to any Observable object (or <see cref="Ext.dom.Element">Ext.Element</see>) which are automatically removed when this Component is
        /// destroyed.
        /// </summary>
        /// <param name="item"><p>The item to which to add a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        /// <param name="opt"><p>If the <c>ename</c> parameter was an event name, this is the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> options.</p>
        /// </param>
        public virtual void mon(object item, object ename, System.Delegate fn=null, object scope=null, object opt=null){}
        /// <summary>
        /// Shorthand for removeManagedListener.
        /// Removes listeners that were added by the <see cref="Ext.util.Observable.mon">mon</see> method.
        /// </summary>
        /// <param name="item"><p>The item from which to remove a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        public virtual void mun(object item, object ename, System.Delegate fn=null, object scope=null){}
        /// <summary>
        /// Shorthand for addListener.
        /// Appends an event handler to this object.  For example:
        /// <code>myGridPanel.on("mouseover", this.onMouseOver, this);
        /// </code>
        /// The method also allows for a single argument to be passed which is a config object
        /// containing properties which specify multiple events. For example:
        /// <code>myGridPanel.on({
        /// cellClick: this.onCellClick,
        /// mouseover: this.onMouseOver,
        /// mouseout: this.onMouseOut,
        /// scope: this // Important. Ensure "this" is correct during handler execution
        /// });
        /// </code>
        /// One can also specify options for each event handler separately:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: this.onCellClick, scope: this, single: true},
        /// mouseover: {fn: panel.onMouseOver, scope: panel}
        /// });
        /// </code>
        /// <em>Names</em> of methods in a specified scope may also be used. Note that
        /// <c>scope</c> MUST be specified to use this option:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: 'onCellClick', scope: this, single: true},
        /// mouseover: {fn: 'onMouseOver', scope: panel}
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventName"><p>The name of the event to listen for.
        /// May also be an object who's property names are event names.</p>
        /// </param>
        /// <param name="fn"><p>The method the event invokes, or <em>if <c>scope</c> is specified, the </em>name* of the method within
        /// the specified <c>scope</c>.  Will be called with arguments
        /// given to <see cref="Ext.util.Observable.fireEvent">fireEvent</see> plus the <c>options</c> parameter described below.</p>
        /// </param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the handler function is
        /// executed. <strong>If omitted, defaults to the object which fired the event.</strong></p>
        /// </param>
        /// <param name="options"><p>An object containing handler configuration.</p>
        /// <p><strong>Note:</strong> Unlike in ExtJS 3.x, the options object will also be passed as the last
        /// argument to every event handler.</p>
        /// <p>This object may contain any of the following properties:</p>
        /// <ul><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope (<c>this</c> reference) in which the handler function is executed. <strong>If omitted,
        /// defaults to the object which fired the event.</strong></p>
        /// </div></li><li><span>delay</span> : <see cref="Number">Number</see><div><p>The number of milliseconds to delay the invocation of the handler after the event fires.</p>
        /// </div></li><li><span>single</span> : <see cref="bool">Boolean</see><div><p>True to add a handler to handle just the next firing of the event, and then remove itself.</p>
        /// </div></li><li><span>buffer</span> : <see cref="Number">Number</see><div><p>Causes the handler to be scheduled to run in an <see cref="Ext.util.DelayedTask">Ext.util.DelayedTask</see> delayed
        /// by the specified number of milliseconds. If the event fires again within that time,
        /// the original handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p>
        /// </div></li><li><span>target</span> : <see cref="Ext.util.Observable">Ext.util.Observable</see><div><p>Only call the handler if the event was fired on the target Observable, <em>not</em> if the event
        /// was bubbled up from a child Observable.</p>
        /// </div></li><li><span>element</span> : <see cref="String">String</see><div><p><strong>This option is only valid for listeners bound to <see cref="Ext.Component">Components</see>.</strong>
        /// The name of a Component property which references an element to add a listener to.</p>
        /// <p>  This option is useful during Component construction to add DOM event listeners to elements of
        /// <see cref="Ext.Component">Components</see> which will exist only after the Component is rendered.
        /// For example, to add a click listener to a Panel's body:</p>
        /// <pre><code>  new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'The title',
        /// listeners: {
        /// click: this.handlePanelClick,
        /// element: 'body'
        /// }
        /// });
        /// </code></pre>
        /// <p><strong>Combining Options</strong></p>
        /// <p>Using the options argument, it is possible to combine different types of listeners:</p>
        /// <p>A delayed, one-time listener.</p>
        /// <pre><code>myPanel.on('hide', this.handleClick, this, {
        /// single: true,
        /// delay: 100
        /// });
        /// </code></pre>
        /// </div></li></ul></param>
        public virtual void on(object eventName, System.Delegate fn=null, object scope=null, object options=null){}
        /// <summary>
        /// Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
        /// and updates the Store's internal data MixedCollection.
        /// </summary>
        /// <param name="batch">
        /// </param>
        /// <param name="operation">
        /// </param>
        private void onBatchComplete(object batch, object operation){}
        /// <summary>
        /// Parameters<li><span>batch</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>operation</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="batch">
        /// </param>
        /// <param name="operation">
        /// </param>
        private void onBatchException(object batch, object operation){}
        /// <summary>
        /// Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
        /// to onProxyWrite.
        /// </summary>
        /// <param name="batch">
        /// </param>
        /// <param name="operation">
        /// </param>
        private void onBatchOperationComplete(object batch, object operation){}
        /// <summary>
        /// Removes any records when a write is returned from the server.
        /// </summary>
        /// <param name="records"><p>The array of removed records</p>
        /// </param>
        /// <param name="operation"><p>The operation that just completed</p>
        /// </param>
        /// <param name="success"><p>True if the operation was successful</p>
        /// </param>
        private void onDestroyRecords(JsArray<Ext.data.Model> records, Operation operation, bool success){}
        /// <summary>
        /// Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
        /// the updates provided by the Proxy
        /// </summary>
        /// <param name="operation">
        /// </param>
        private void onProxyWrite(object operation){}
        /// <summary>
        /// Prepares a given class for observable instances. This method is called when a
        /// class derives from this class or uses this class as a mixin.
        /// </summary>
        /// <param name="T"><p>The class constructor to prepare.</p>
        /// </param>
        public virtual void prepareClass(System.Delegate T){}
        /// <summary>
        /// Relays selected events from the specified Observable as if the events were fired by this.
        /// For example if you are extending Grid, you might decide to forward some events from store.
        /// So you can do this inside your initComponent:
        /// <code>this.relayEvents(this.getStore(), ['load']);
        /// </code>
        /// The grid instance will then have an observable 'load' event which will be passed the
        /// parameters of the store's load event and any function fired with the grid's load event
        /// would have access to the grid using the <c>this</c> keyword.
        /// </summary>
        /// <param name="origin"><p>The Observable whose events this object is to relay.</p>
        /// </param>
        /// <param name="events"><p>Array of event names to relay.</p>
        /// </param>
        /// <param name="prefix"><p>A common prefix to prepend to the event names. For example:</p>
        /// <pre><code>this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
        /// </code></pre>
        /// <p>Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.</p>
        /// </param>
        public virtual void relayEvents(object origin, JsArray<String> events, object prefix=null){}
        /// <summary>
        /// Reloads the store using the last options passed to the load method.
        /// </summary>
        /// <param name="options"><p>A config object which contains options which may override the options passed to the previous load call.</p>
        /// </param>
        public void reload(object options){}
        /// <summary>
        /// Removes all records from the store. This method does a "fast remove",
        /// individual remove events are not called. The clear event is
        /// fired upon completion.
        /// </summary>
        public void removeAll(){}
        /// <summary>
        /// Removes an event handler.
        /// </summary>
        /// <param name="eventName"><p>The type of event the handler was associated with.</p>
        /// </param>
        /// <param name="fn"><p>The handler to remove. <strong>This must be a reference to the function passed into the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> call.</strong></p>
        /// </param>
        /// <param name="scope"><p>The scope originally specified for the handler. It must be the same as the
        /// scope argument specified in the original call to <see cref="Ext.util.Observable.addListener">addListener</see> or the listener will not be removed.</p>
        /// </param>
        public virtual void removeListener(JsString eventName, System.Delegate fn, object scope=null){}
        /// <summary>
        /// Removes listeners that were added by the mon method.
        /// </summary>
        /// <param name="item"><p>The item from which to remove a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        public virtual void removeManagedListener(object item, object ename, System.Delegate fn=null, object scope=null){}
        /// <summary>
        /// Remove a single managed listener item
        /// </summary>
        /// <param name="isClear"><p>True if this is being called during a clear</p>
        /// </param>
        /// <param name="managedListener"><p>The managed listener item
        /// See removeManagedListener for other args</p>
        /// </param>
        public virtual void removeManagedListenerItem(bool isClear, object managedListener){}
        /// <summary>
        /// Resumes automatically syncing the Store with its Proxy.  Only applicable if autoSync is true
        /// </summary>
        public void resumeAutoSync(){}
        /// <summary>
        /// Resumes firing events (see suspendEvents).
        /// If events were suspended using the <c>queueSuspended</c> parameter, then all events fired
        /// during event suspension will be sent to any listeners now.
        /// </summary>
        public virtual void resumeEvents(){}
        /// <summary>
        /// Saves all pending changes via the configured proxy. Use sync instead.
        /// <p>This method has been <strong>deprecated</strong> since 4.0.0</p>
        /// <p>Will be removed in the next major version</p>
        /// </summary>
        public void save(){}
        /// <summary>
        /// Sets the Store's Proxy by string, config object or Proxy instance
        /// </summary>
        /// <param name="proxy"><p>The new Proxy, which can be either a type string, a configuration object
        /// or an <see cref="Ext.data.proxy.Proxy">Ext.data.proxy.Proxy</see> instance</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.proxy.Proxy">Ext.data.proxy.Proxy</see></span><div><p>The attached Proxy object</p>
        /// </div>
        /// </returns>
        public Ext.data.proxy.Proxy setProxy(object proxy){return null;}
        /// <summary>
        /// Sorts the data in the Store by one or more of its properties. Example usage:
        /// <code>//sort by a single field
        /// myStore.sort('myField', 'DESC');
        /// //sorting by multiple fields
        /// myStore.sort([
        /// {
        /// property : 'age',
        /// direction: 'ASC'
        /// },
        /// {
        /// property : 'name',
        /// direction: 'DESC'
        /// }
        /// ]);
        /// </code>
        /// Internally, Store converts the passed arguments into an array of <see cref="Ext.util.Sorter">Ext.util.Sorter</see> instances, and delegates
        /// the actual sorting to its internal <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see>.
        /// When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
        /// <code>store.sort('myField');
        /// store.sort('myField');
        /// </code>
        /// Is equivalent to this code, because Store handles the toggling automatically:
        /// <code>store.sort('myField', 'ASC');
        /// store.sort('myField', 'DESC');
        /// </code>
        /// </summary>
        /// <param name="sorters"><p>Either a string name of one of the fields in this Store's configured
        /// <see cref="Ext.data.Model">Model</see>, or an array of sorter configurations.</p>
        /// </param>
        /// <param name="direction"><p>The overall direction to sort the data by.</p>
        /// <p>Defaults to: <c>&quot;ASC&quot;</c></p></param>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see>[]</span><div>
        /// </div>
        /// </returns>
        public virtual Ext.util.Sorter[] sort(object sorters=null, object direction=null){return null;}
        /// <summary>
        /// Suspends automatically syncing the Store with its Proxy.  Only applicable if autoSync is true
        /// </summary>
        public void suspendAutoSync(){}
        /// <summary>
        /// Suspends the firing of all events. (see resumeEvents)
        /// </summary>
        /// <param name="queueSuspended"><p>Pass as true to queue up suspended events to be fired
        /// after the <see cref="Ext.util.Observable.resumeEvents">resumeEvents</see> call instead of discarding all suspended events.</p>
        /// </param>
        public virtual void suspendEvents(bool queueSuspended){}
        /// <summary>
        /// Synchronizes the store with its proxy. This asks the proxy to batch together any new, updated
        /// and deleted records in the store, updating the store's internal representation of the records
        /// as each operation completes.
        /// </summary>
        /// <param name="options"><p>Object containing one or more properties supported by the sync method (these get
        /// passed along to the underlying proxy's <see cref="Ext.data.proxy.Proxy.batch">batch</see> method):</p>
        /// <ul><li><span>batch</span> : <see cref="Ext.data.Batch">Ext.data.Batch</see>/<see cref="Object">Object</see> (optional)<div><p>A <see cref="Ext.data.Batch">Ext.data.Batch</see> object (or batch config to apply
        /// to the created batch). If unspecified a default batch will be auto-created as needed.</p>
        /// </div></li><li><span>callback</span> : <see cref="Function">Function</see> (optional)<div><p>The function to be called upon completion of the sync.
        /// The callback is called regardless of success or failure and is passed the following parameters:</p>
        /// <h3>Parameters</h3><ul><li><span>batch</span> : <see cref="Ext.data.Batch">Ext.data.Batch</see><div><p>The <see cref="Ext.data.Batch">batch</see> that was processed,
        /// containing all operations in their current state after processing</p>
        /// </div></li><li><span>options</span> : <see cref="Object">Object</see><div><p>The options argument that was originally passed into sync</p>
        /// </div></li></ul></div></li><li><span>success</span> : <see cref="Function">Function</see> (optional)<div><p>The function to be called upon successful completion of the sync. The
        /// success function is called only if no exceptions were reported in any operations. If one or more exceptions
        /// occurred then the failure function will be called instead. The success function is called
        /// with the following parameters:</p>
        /// <h3>Parameters</h3><ul><li><span>batch</span> : <see cref="Ext.data.Batch">Ext.data.Batch</see><div><p>The <see cref="Ext.data.Batch">batch</see> that was processed,
        /// containing all operations in their current state after processing</p>
        /// </div></li><li><span>options</span> : <see cref="Object">Object</see><div><p>The options argument that was originally passed into sync</p>
        /// </div></li></ul></div></li><li><span>failure</span> : <see cref="Function">Function</see> (optional)<div><p>The function to be called upon unsuccessful completion of the sync. The
        /// failure function is called when one or more operations returns an exception during processing (even if some
        /// operations were also successful). In this case you can check the batch's <see cref="Ext.data.Batch.exceptions">exceptions</see> array to see exactly which operations had exceptions. The failure function is called with the
        /// following parameters:</p>
        /// <h3>Parameters</h3><ul><li><span>batch</span> : <see cref="Ext.data.Batch">Ext.data.Batch</see><div><p>The <see cref="Ext.data.Batch">Ext.data.Batch</see> that was processed, containing all
        /// operations in their current state after processing</p>
        /// </div></li><li><span>options</span> : <see cref="Object">Object</see><div><p>The options argument that was originally passed into sync</p>
        /// </div></li></ul></div></li><li><span>scope</span> : <see cref="Object">Object</see> (optional)<div><p>The scope in which to execute any callbacks (i.e. the <c>this</c> object inside
        /// the callback, success and/or failure functions). Defaults to the store's proxy.</p>
        /// </div></li></ul></param>
        /// <returns>
        /// <span><see cref="Ext.data.Store">Ext.data.Store</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.data.Store sync(object options=null){return null;}
        /// <summary>
        /// Shorthand for removeListener.
        /// Removes an event handler.
        /// </summary>
        /// <param name="eventName"><p>The type of event the handler was associated with.</p>
        /// </param>
        /// <param name="fn"><p>The handler to remove. <strong>This must be a reference to the function passed into the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> call.</strong></p>
        /// </param>
        /// <param name="scope"><p>The scope originally specified for the handler. It must be the same as the
        /// scope argument specified in the original call to <see cref="Ext.util.Observable.addListener">addListener</see> or the listener will not be removed.</p>
        /// </param>
        public virtual void un(JsString eventName, System.Delegate fn, object scope=null){}
        /// <summary>
        /// Creates a store from config object.
        /// </summary>
        /// <param name="store"><p>A config for
        /// the store to be created.  It may contain a <c>type</c> field
        /// which defines the particular type of store to create.</p>
        /// <p>Alteratively passing an actual store to this method will
        /// just return it, no changes made.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.AbstractStore">Ext.data.AbstractStore</see></span><div><p>The created store.</p>
        /// </div>
        /// </returns>
        public static AbstractStore create(object store){return null;}
        public AbstractStore(AbstractStoreConfig config){}
        public AbstractStore(){}
        public AbstractStore(params object[] args){}
    }
    #endregion
    #region AbstractStoreConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractStoreConfig : Ext.BaseConfig
    {
        /// <summary>
        /// If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
        /// after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
        /// Defaults to false.
        /// </summary>
        public object autoLoad;
        /// <summary>
        /// True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool autoSync;
        /// <summary>
        /// Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
        /// internal representation of the data after each operation of the batch has completed, 'complete' will wait until
        /// the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
        /// storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
        /// Defaults to: <c>&quot;operation&quot;</c>
        /// </summary>
        public JsString batchUpdateMode;
        /// <summary>
        /// This may be used in place of specifying a model configuration. The fields should be a
        /// set of Ext.data.Field configuration objects. The store will automatically create a Ext.data.Model
        /// with these fields. In general this configuration option should only be used for simple stores like
        /// a two-field store of ComboBox. For anything more complicated, such as specifying a particular id property or
        /// associations, a Ext.data.Model should be defined and specified for the model
        /// config.
        /// </summary>
        public JsObject fields;
        /// <summary>
        /// If true, any filters attached to this Store will be run after loading data, before the datachanged event is fired.
        /// Defaults to true, ignored if remoteFilter is true
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool filterOnLoad;
        /// <summary>
        /// Array of Filters for this store. Can also be passed array of
        /// functions which will be used as the filterFn config
        /// for filters:
        /// <code>filters: [
        /// function(item) {
        /// return item.internalId &gt; 0;
        /// }
        /// ]
        /// </code>
        /// To filter after the grid is loaded use the <see cref="Ext.data.Store.filterBy">filterBy</see> function.
        /// </summary>
        public object filters;
        /// <summary>
        /// A config object containing one or more event handlers to be added to this object during initialization. This
        /// should be a valid listeners config object as specified in the addListener example for attaching multiple
        /// handlers at once.
        /// <strong>DOM events from Ext JS <see cref="Ext.Component">Components</see></strong>
        /// While <em>some</em> Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
        /// only done when extra value can be added. For example the <see cref="Ext.view.View">DataView</see>'s <strong><c><see cref="Ext.view.ViewEvents.itemclick">itemclick</see></c></strong> event passing the node clicked on. To access DOM events directly from a
        /// child element of a Component, we need to specify the <c>element</c> option to identify the Component property to add a
        /// DOM listener to:
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// width: 400,
        /// height: 200,
        /// dockedItems: [{
        /// xtype: 'toolbar'
        /// }],
        /// listeners: {
        /// click: {
        /// element: 'el', //bind to the underlying el property on the panel
        /// fn: function(){ console.log('click el'); }
        /// },
        /// dblclick: {
        /// element: 'body', //bind to the underlying body property on the panel
        /// fn: function(){ console.log('dblclick body'); }
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsObject listeners;
        /// <summary>
        /// Name of the Model associated with this store.
        /// The string is used as an argument for Ext.ModelManager.getModel.
        /// </summary>
        public JsString model;
        /// <summary>
        /// The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
        /// see setProxy for details.
        /// </summary>
        public object proxy;
        /// <summary>
        /// True to defer any filtering operation to the server. If false, filtering is done locally on the client.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool remoteFilter;
        /// <summary>
        /// True to defer any sorting operation to the server. If false, sorting is done locally on the client.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool remoteSort;
        /// <summary>
        /// If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
        /// Defaults to true, igored if remoteSort is true
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool sortOnLoad;
        /// <summary>
        /// Unique identifier for this store. If present, this Store will be registered with the Ext.data.StoreManager,
        /// making it easy to reuse elsewhere.
        /// Note that when store is instatiated by Controller, the storeId will be overridden by the name of the store.
        /// </summary>
        public JsString storeId;
        public AbstractStoreConfig(params object[] args){}
    }
    #endregion
    #region AbstractStoreEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractStoreEvents : Ext.BaseEvents
    {
        /// <summary>
        /// Fired when a Model instance has been added to this Store
        /// </summary>
        /// <param name="store"><p>The store</p>
        /// </param>
        /// <param name="records"><p>The Model instances that were added</p>
        /// </param>
        /// <param name="index"><p>The index at which the instances were inserted</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void add(Ext.data.Store store, JsArray<Ext.data.Model> records, JsNumber index, object eOpts){}
        /// <summary>
        /// Fires before a request is made for a new data object. If the beforeload handler returns false the load
        /// action will be canceled.
        /// </summary>
        /// <param name="store"><p>This Store</p>
        /// </param>
        /// <param name="operation"><p>The <see cref="Ext.data.Operation">Ext.data.Operation</see> object that will be passed to the Proxy to
        /// load the Store</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforeload(Ext.data.Store store, Operation operation, object eOpts){}
        /// <summary>
        /// Fired before a call to sync is executed. Return false from any listener to cancel the sync
        /// </summary>
        /// <param name="options"><p>Hash of all records to be synchronized, broken down into create, update and destroy</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforesync(object options, object eOpts){}
        /// <summary>
        /// Fired after the removeAll method is called.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void clear(Ext.data.Store @this, object eOpts){}
        /// <summary>
        /// Fires whenever the records in the Store have changed in some way - this could include adding or removing
        /// records, or updating the data in existing records
        /// </summary>
        /// <param name="this"><p>The data store</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void datachanged(Ext.data.Store @this, object eOpts){}
        /// <summary>
        /// Fires whenever the store reads data from a remote data source.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="records"><p>An array of records</p>
        /// </param>
        /// <param name="successful"><p>True if the operation was successful.</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void load(Ext.data.Store @this, JsArray<Ext.data.Model> records, bool successful, object eOpts){}
        /// <summary>
        /// Fires when this store's underlying reader (available via the proxy) provides new metadata.
        /// Metadata usually consists of new field definitions, but can include any configuration data
        /// required by an application, and can be processed as needed in the event handler.
        /// This event is currently only fired for JsonReaders.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="meta"><p>The JSON metadata</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void metachange(Ext.data.Store @this, object meta, object eOpts){}
        /// <summary>
        /// Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
        /// widget that is using this Store as a Record cache should refresh its view.
        /// </summary>
        /// <param name="this"><p>The data store</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void refresh(Ext.data.Store @this, object eOpts){}
        /// <summary>
        /// Fired when a Model instance has been removed from this Store
        /// </summary>
        /// <param name="store"><p>The Store object</p>
        /// </param>
        /// <param name="record"><p>The record that was removed</p>
        /// </param>
        /// <param name="index"><p>The index of the record that was removed</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void remove(Ext.data.Store store, Ext.data.Model record, JsNumber index, object eOpts){}
        /// <summary>
        /// Fires when a Model instance has been updated
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="record"><p>The Model instance that was updated</p>
        /// </param>
        /// <param name="operation"><p>The update operation being performed. Value may be one of:</p>
        /// <pre><code><see cref="Ext.data.Model.EDIT">Ext.data.Model.EDIT</see>
        /// <see cref="Ext.data.Model.REJECT">Ext.data.Model.REJECT</see>
        /// <see cref="Ext.data.Model.COMMIT">Ext.data.Model.COMMIT</see>
        /// </code></pre>
        /// </param>
        /// <param name="modifiedFieldNames"><p>Array of field names changed during edit.</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void update(Ext.data.Store @this, Ext.data.Model record, JsString operation, object modifiedFieldNames=null, object eOpts=null){}
        /// <summary>
        /// Fires whenever a successful write has been made via the configured Proxy
        /// </summary>
        /// <param name="store"><p>This Store</p>
        /// </param>
        /// <param name="operation"><p>The <see cref="Ext.data.Operation">Operation</see> object that was used in
        /// the write</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void write(Ext.data.Store store, Operation operation, object eOpts){}
        public AbstractStoreEvents(params object[] args){}
    }
    #endregion
}
