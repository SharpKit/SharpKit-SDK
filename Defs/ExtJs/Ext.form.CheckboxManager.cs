//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:40 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.form
{
    #region CheckboxManager
    /// <inheritdocs />
    /// <summary>
    /// <p><strong>NOTE</strong> This is a private utility class for internal use by the framework. Don't rely on its existence.</p><p>Private utility class for managing all <see cref="Ext.form.field.Checkbox">Ext.form.field.Checkbox</see> fields grouped by name.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class CheckboxManager : Ext.util.MixedCollection
    {
        /// <summary>
        /// Specify true if the addAll
        /// function should add function references to the collection. Defaults to
        /// false.
        /// Defaults to: <c>false</c>
        /// </summary>
        public static bool allowFunctions;
        /// <summary>
        /// A config object containing one or more event handlers to be added to this object during initialization. This
        /// should be a valid listeners config object as specified in the addListener example for attaching multiple
        /// handlers at once.
        /// <strong>DOM events from Ext JS <see cref="Ext.Component">Components</see></strong>
        /// While <em>some</em> Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
        /// only done when extra value can be added. For example the <see cref="Ext.view.View">DataView</see>'s <strong><c><see cref="Ext.view.ViewEvents.itemclick">itemclick</see></c></strong> event passing the node clicked on. To access DOM events directly from a
        /// child element of a Component, we need to specify the <c>element</c> option to identify the Component property to add a
        /// DOM listener to:
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// width: 400,
        /// height: 200,
        /// dockedItems: [{
        /// xtype: 'toolbar'
        /// }],
        /// listeners: {
        /// click: {
        /// element: 'el', //bind to the underlying el property on the panel
        /// fn: function(){ console.log('click el'); }
        /// },
        /// dblclick: {
        /// element: 'body', //bind to the underlying body property on the panel
        /// fn: function(){ console.log('dblclick body'); }
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        public static JsObject listeners;
        /// <summary>
        /// Defaults to: <c>&quot;Ext.Base&quot;</c>
        /// </summary>
        [JsProperty(Name="$className")]
        private static JsString @className{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        private static JsObject configMap{get;set;}
        /// <summary>
        /// The default sort direction to use if one is not specified.
        /// Defaults to: <c>&quot;ASC&quot;</c>
        /// </summary>
        public static JsString defaultSortDirection{get;set;}
        /// <summary>
        /// Initial suspended call count. Incremented when suspendEvents is called, decremented when resumeEvents is called.
        /// Defaults to: <c>0</c>
        /// </summary>
        private static JsNumber eventsSuspended{get;set;}
        /// <summary>
        /// Mutation counter which is incremented upon add and remove.
        /// Defaults to: <c>0</c>
        /// </summary>
        private static JsNumber generation{get;set;}
        /// <summary>
        /// This object holds a key for any event that has a listener. The listener may be set
        /// directly on the instance, or on its class or a super class (via observe) or
        /// on the MVC EventBus. The values of this object are truthy
        /// (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
        /// of listeners. The value for an event is truthy if the event must be fired and is
        /// falsy if there is no need to fire the event.
        /// The intended use of this property is to avoid the expense of fireEvent calls when
        /// there are no listeners. This can be particularly helpful when one would otherwise
        /// have to call fireEvent hundreds or thousands of times. It is used like this:
        /// <code> if (this.hasListeners.foo) {
        /// this.fireEvent('foo', this, arg1);
        /// }
        /// </code>
        /// </summary>
        public static JsObject hasListeners{get;set;}
        /// <summary>
        /// Defaults to: <c>[]</c>
        /// </summary>
        private static JsArray initConfigList{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        private static JsObject initConfigMap{get;set;}
        /// <summary>
        /// Defaults to: <c>true</c>
        /// </summary>
        private static bool isInstance{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated MixedCollection, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public static bool isMixedCollection{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Observable, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public static bool isObservable{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Sortable, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public static bool isSortable{get;set;}
        /// <summary>
        /// Get the reference to the current class from which this object was instantiated. Unlike statics,
        /// this.self is scope-dependent and it's meant to be used for dynamic inheritance. See statics
        /// for a detailed comparison
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// statics: {
        /// speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        /// },
        /// constructor: function() {
        /// alert(this.self.speciesName); // dependent on 'this'
        /// },
        /// clone: function() {
        /// return new this.self();
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.SnowLeopard', {
        /// extend: 'My.Cat',
        /// statics: {
        /// speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
        /// }
        /// });
        /// var cat = new My.Cat();                     // alerts 'Cat'
        /// var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
        /// var clone = snowLeopard.clone();
        /// alert(<see cref="Ext.ExtContext.getClassName">Ext.getClassName</see>(clone));             // alerts 'My.SnowLeopard'
        /// </code>
        /// </summary>
        protected static Class self{get;set;}
        /// <summary>
        /// The property in each item that contains the data to sort.
        /// </summary>
        public static JsString sortRoot{get;set;}
        /// <summary>
        /// The collection of Sorters currently applied to this Store
        /// </summary>
        public static Ext.util.MixedCollection sorters{get;set;}
        /// <summary>
        /// Creates new MixedCollection.
        /// </summary>
        /// <param name="allowFunctions"><p>Specify <tt>true</tt> if the <see cref="Ext.util.MixedCollection.addAll">addAll</see>
        /// function should add function references to the collection. Defaults to
        /// <tt>false</tt>.</p>
        /// </param>
        /// <param name="keyFn"><p>A function that can accept an item of the type(s) stored in this MixedCollection
        /// and return the key value for that item.  This is used when available to look up the key on items that
        /// were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
        /// equivalent to providing an implementation for the <see cref="Ext.util.MixedCollection.getKey">getKey</see> method.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public CheckboxManager(bool allowFunctions, System.Delegate keyFn){}
        /// <summary>
        /// Performs the actual sorting based on a direction and a sorting function. Internally,
        /// this creates a temporary array of all items in the MixedCollection, sorts it and then writes
        /// the sorted array data back into this.items and this.keys
        /// </summary>
        /// <param name="property"><p>Property to sort by ('key', 'value', or 'index')</p>
        /// </param>
        /// <param name="dir"><p>Direction to sort 'ASC' or 'DESC'. Defaults to 'ASC'.</p>
        /// </param>
        /// <param name="fn"><p>Comparison function that defines the sort order.
        /// Defaults to sorting by numeric value.</p>
        /// </param>
        private static void _sort(JsString property, object dir=null, System.Delegate fn=null){}
        /// <summary>
        /// Adds an item to the collection. Fires the add event when complete.
        /// </summary>
        /// <param name="key"><p>The key to associate with the item, or the new item.</p>
        /// <p>If a <see cref="Ext.util.AbstractMixedCollection.getKey">getKey</see> implementation was specified for this MixedCollection,
        /// or if the key of the stored items is in a property called <c>id</c>,
        /// the MixedCollection will be able to <em>derive</em> the key for the new item.
        /// In this case just pass the new item in this parameter.</p>
        /// </param>
        /// <param name="o"><p>The item to add.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The item added.</p>
        /// </div>
        /// </returns>
        public static object add(object key, object o=null){return null;}
        /// <summary>
        /// Adds all elements of an Array or an Object to the collection.
        /// </summary>
        /// <param name="objs"><p>An Object containing properties which will be added
        /// to the collection, or an Array of values, each of which are added to the collection.
        /// Functions references will be added to the collection if <c><see cref="Ext.util.AbstractMixedCollectionConfig.allowFunctions">allowFunctions</see></c>
        /// has been set to <c>true</c>.</p>
        /// </param>
        public static void addAll(object objs){}
        /// <summary>
        /// Adds the specified events to the list of events which this Observable may fire.
        /// </summary>
        /// <param name="eventNames"><p>Either an object with event names as properties with
        /// a value of <c>true</c>. For example:</p>
        /// <pre><code>this.addEvents({
        /// storeloaded: true,
        /// storecleared: true
        /// });
        /// </code></pre>
        /// <p>Or any number of event names as separate parameters. For example:</p>
        /// <pre><code>this.addEvents('storeloaded', 'storecleared');
        /// </code></pre>
        /// </param>
        public static void addEvents(object eventNames){}
        /// <summary>
        /// Appends an event handler to this object.  For example:
        /// <code>myGridPanel.on("mouseover", this.onMouseOver, this);
        /// </code>
        /// The method also allows for a single argument to be passed which is a config object
        /// containing properties which specify multiple events. For example:
        /// <code>myGridPanel.on({
        /// cellClick: this.onCellClick,
        /// mouseover: this.onMouseOver,
        /// mouseout: this.onMouseOut,
        /// scope: this // Important. Ensure "this" is correct during handler execution
        /// });
        /// </code>
        /// One can also specify options for each event handler separately:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: this.onCellClick, scope: this, single: true},
        /// mouseover: {fn: panel.onMouseOver, scope: panel}
        /// });
        /// </code>
        /// <em>Names</em> of methods in a specified scope may also be used. Note that
        /// <c>scope</c> MUST be specified to use this option:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: 'onCellClick', scope: this, single: true},
        /// mouseover: {fn: 'onMouseOver', scope: panel}
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventName"><p>The name of the event to listen for.
        /// May also be an object who's property names are event names.</p>
        /// </param>
        /// <param name="fn"><p>The method the event invokes, or <em>if <c>scope</c> is specified, the </em>name* of the method within
        /// the specified <c>scope</c>.  Will be called with arguments
        /// given to <see cref="Ext.util.Observable.fireEvent">fireEvent</see> plus the <c>options</c> parameter described below.</p>
        /// </param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the handler function is
        /// executed. <strong>If omitted, defaults to the object which fired the event.</strong></p>
        /// </param>
        /// <param name="options"><p>An object containing handler configuration.</p>
        /// <p><strong>Note:</strong> Unlike in ExtJS 3.x, the options object will also be passed as the last
        /// argument to every event handler.</p>
        /// <p>This object may contain any of the following properties:</p>
        /// <ul><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope (<c>this</c> reference) in which the handler function is executed. <strong>If omitted,
        /// defaults to the object which fired the event.</strong></p>
        /// </div></li><li><span>delay</span> : <see cref="Number">Number</see><div><p>The number of milliseconds to delay the invocation of the handler after the event fires.</p>
        /// </div></li><li><span>single</span> : <see cref="bool">Boolean</see><div><p>True to add a handler to handle just the next firing of the event, and then remove itself.</p>
        /// </div></li><li><span>buffer</span> : <see cref="Number">Number</see><div><p>Causes the handler to be scheduled to run in an <see cref="Ext.util.DelayedTask">Ext.util.DelayedTask</see> delayed
        /// by the specified number of milliseconds. If the event fires again within that time,
        /// the original handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p>
        /// </div></li><li><span>target</span> : <see cref="Ext.util.Observable">Ext.util.Observable</see><div><p>Only call the handler if the event was fired on the target Observable, <em>not</em> if the event
        /// was bubbled up from a child Observable.</p>
        /// </div></li><li><span>element</span> : <see cref="String">String</see><div><p><strong>This option is only valid for listeners bound to <see cref="Ext.Component">Components</see>.</strong>
        /// The name of a Component property which references an element to add a listener to.</p>
        /// <p>  This option is useful during Component construction to add DOM event listeners to elements of
        /// <see cref="Ext.Component">Components</see> which will exist only after the Component is rendered.
        /// For example, to add a click listener to a Panel's body:</p>
        /// <pre><code>  new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'The title',
        /// listeners: {
        /// click: this.handlePanelClick,
        /// element: 'body'
        /// }
        /// });
        /// </code></pre>
        /// <p><strong>Combining Options</strong></p>
        /// <p>Using the options argument, it is possible to combine different types of listeners:</p>
        /// <p>A delayed, one-time listener.</p>
        /// <pre><code>myPanel.on('hide', this.handleClick, this, {
        /// single: true,
        /// delay: 100
        /// });
        /// </code></pre>
        /// </div></li></ul></param>
        public static void addListener(object eventName, System.Delegate fn=null, object scope=null, object options=null){}
        /// <summary>
        /// Adds listeners to any Observable object (or Ext.Element) which are automatically removed when this Component is
        /// destroyed.
        /// </summary>
        /// <param name="item"><p>The item to which to add a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        /// <param name="opt"><p>If the <c>ename</c> parameter was an event name, this is the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> options.</p>
        /// </param>
        public static void addManagedListener(object item, object ename, System.Delegate fn=null, object scope=null, object opt=null){}
        /// <summary>
        /// Call the original method that was previously overridden with override
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// constructor: function() {
        /// alert("I'm a cat!");
        /// }
        /// });
        /// My.Cat.override({
        /// constructor: function() {
        /// alert("I'm going to be a cat!");
        /// this.callOverridden();
        /// alert("Meeeeoooowwww");
        /// }
        /// });
        /// var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
        /// // alerts "I'm a cat!"
        /// // alerts "Meeeeoooowwww"
        /// </code>
        /// <p>This method has been <strong>deprecated</strong> </p>
        /// <p>as of 4.1. Use <see cref="Ext.Base.callParent">callParent</see> instead.</p>
        /// </summary>
        /// <param name="args"><p>The arguments, either an array or the <c>arguments</c> object
        /// from the current method, for example: <c>this.callOverridden(arguments)</c></p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>Returns the result of calling the overridden method</p>
        /// </div>
        /// </returns>
        protected static object callOverridden(object args=null){return null;}
        /// <summary>
        /// Call the "parent" method of the current method. That is the method previously
        /// overridden by derivation or by an override (see Ext.define).
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Base', {
        /// constructor: function (x) {
        /// this.x = x;
        /// },
        /// statics: {
        /// method: function (x) {
        /// return x;
        /// }
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived', {
        /// extend: 'My.Base',
        /// constructor: function () {
        /// this.callParent([21]);
        /// }
        /// });
        /// var obj = new My.Derived();
        /// alert(obj.x);  // alerts 21
        /// </code>
        /// This can be used with an override as follows:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.DerivedOverride', {
        /// override: 'My.Derived',
        /// constructor: function (x) {
        /// this.callParent([x*2]); // calls original My.Derived constructor
        /// }
        /// });
        /// var obj = new My.Derived();
        /// alert(obj.x);  // now alerts 42
        /// </code>
        /// This also works with static methods.
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived2', {
        /// extend: 'My.Base',
        /// statics: {
        /// method: function (x) {
        /// return this.callParent([x*2]); // calls My.Base.method
        /// }
        /// }
        /// });
        /// alert(My.Base.method(10);     // alerts 10
        /// alert(My.Derived2.method(10); // alerts 20
        /// </code>
        /// Lastly, it also works with overridden static methods.
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived2Override', {
        /// override: 'My.Derived2',
        /// statics: {
        /// method: function (x) {
        /// return this.callParent([x*2]); // calls My.Derived2.method
        /// }
        /// }
        /// });
        /// alert(My.Derived2.method(10); // now alerts 40
        /// </code>
        /// </summary>
        /// <param name="args"><p>The arguments, either an array or the <c>arguments</c> object
        /// from the current method, for example: <c>this.callParent(arguments)</c></p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>Returns the result of calling the parent method</p>
        /// </div>
        /// </returns>
        protected static object callParent(object args=null){return null;}
        /// <summary>
        /// Removes all items from the collection.  Fires the clear event when complete.
        /// </summary>
        public static void clear(){}
        /// <summary>
        /// Removes all listeners for this object including the managed listeners
        /// </summary>
        public static void clearListeners(){}
        /// <summary>
        /// Removes all managed listeners for this object.
        /// </summary>
        public static void clearManagedListeners(){}
        /// <summary>
        /// Creates a shallow copy of this collection
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see></span><div>
        /// </div>
        /// </returns>
        public static Ext.util.MixedCollection clone(){return null;}
        /// <summary>
        /// Collects unique values of a particular property in this MixedCollection
        /// </summary>
        /// <param name="property"><p>The property to collect on</p>
        /// </param>
        /// <param name="root"><p>'root' property to extract the first argument from. This is used mainly when
        /// summing fields in records, where the fields are all stored inside the 'data' object</p>
        /// </param>
        /// <param name="allowBlank"><p>Pass true to allow null, undefined or empty string values</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Array">Array</see></span><div><p>The unique values</p>
        /// </div>
        /// </returns>
        public static JsArray collect(JsString property, object root=null, object allowBlank=null){return null;}
        /// <summary>
        /// </summary>
        private static void configClass(){}
        /// <summary>
        /// Returns true if the collection contains the passed Object as an item.
        /// </summary>
        /// <param name="o"><p>The Object to look for in the collection.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if the collection contains the Object as an item.</p>
        /// </div>
        /// </returns>
        public static bool contains(object o){return false;}
        /// <summary>
        /// Returns true if the collection contains the passed Object as a key.
        /// </summary>
        /// <param name="key"><p>The key to look for in the collection.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if the collection contains the Object as a key.</p>
        /// </div>
        /// </returns>
        public static bool containsKey(JsString key){return false;}
        /// <summary>
        /// Continue to fire event.
        /// </summary>
        /// <param name="eventName">
        /// </param>
        /// <param name="args">
        /// </param>
        /// <param name="bubbles">
        /// </param>
        private static void continueFireEvent(JsString eventName, object args=null, object bubbles=null){}
        /// <summary>
        /// Creates an event handling function which refires the event from this object as the passed event name.
        /// </summary>
        /// <param name="newName">
        /// </param>
        /// <param name="beginEnd"><p>The caller can specify on which indices to slice</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Function">Function</see></span><div>
        /// </div>
        /// </returns>
        private static System.Delegate createRelayer(object newName, object beginEnd=null){return null;}
        /// <summary>
        /// Returns a regular expression based on the given value and matching options. This is used internally for finding and filtering,
        /// and by Ext.data.Store.filter
        /// </summary>
        /// <param name="value"><p>The value to create the regex for. This is escaped using <see cref="Ext.ExtContext.escapeRe">Ext.escapeRe</see></p>
        /// </param>
        /// <param name="anyMatch"><p>True to allow any match - no regex start/end line anchors will be added. Defaults to false</p>
        /// </param>
        /// <param name="caseSensitive"><p>True to make the regex case sensitive (adds 'i' switch to regex). Defaults to false.</p>
        /// </param>
        /// <param name="exactMatch"><p>True to force exact match (^ and $ characters added to the regex). Defaults to false. Ignored if anyMatch is true.</p>
        /// </param>
        private static void createValueMatcher(JsString value, object anyMatch, bool caseSensitive, bool exactMatch){}
        /// <summary>
        /// Normalizes an array of sorter objects, ensuring that they are all Ext.util.Sorter instances
        /// </summary>
        /// <param name="sorters"><p>The sorters array</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see>[]</span><div><p>Array of <see cref="Ext.util.Sorter">Ext.util.Sorter</see> objects</p>
        /// </div>
        /// </returns>
        private static Ext.util.Sorter[] decodeSorters(JsArray<Object> sorters){return null;}
        /// <summary>
        /// Overrides: <see cref="Ext.AbstractComponent.destroy">Ext.AbstractComponent.destroy</see>, <see cref="Ext.AbstractPlugin.destroy">Ext.AbstractPlugin.destroy</see>, <see cref="Ext.layout.Layout.destroy">Ext.layout.Layout.destroy</see>
        /// </summary>
        private static void destroy(){}
        /// <summary>
        /// Executes the specified function once for every item in the collection.
        /// The function should return a boolean value.
        /// Returning false from the function will stop the iteration.
        /// </summary>
        /// <param name="fn"><p>The function to execute for each item.</p>
        /// <h3>Parameters</h3><ul><li><span>item</span> : Mixed<div><p>The collection item.</p>
        /// </div></li><li><span>index</span> : <see cref="Number">Number</see><div><p>The index of item.</p>
        /// </div></li><li><span>len</span> : <see cref="Number">Number</see><div><p>Total length of collection.</p>
        /// </div></li></ul></param>
        /// <param name="scope"><p>The scope (<c>this</c> reference)
        /// in which the function is executed. Defaults to the current item in the iteration.</p>
        /// </param>
        public static void each(System.Delegate fn, object scope=null){}
        /// <summary>
        /// Executes the specified function once for every key in the collection, passing each
        /// key, and its associated item as the first two parameters.
        /// </summary>
        /// <param name="fn"><p>The function to execute for each item.</p>
        /// <h3>Parameters</h3><ul><li><span>key</span> : <see cref="String">String</see><div><p>The key of collection item.</p>
        /// </div></li><li><span>item</span> : Mixed<div><p>The collection item.</p>
        /// </div></li><li><span>index</span> : <see cref="Number">Number</see><div><p>The index of item.</p>
        /// </div></li><li><span>len</span> : <see cref="Number">Number</see><div><p>Total length of collection.</p>
        /// </div></li></ul></param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the
        /// function is executed. Defaults to the browser window.</p>
        /// </param>
        public static void eachKey(System.Delegate fn, object scope=null){}
        /// <summary>
        /// Enables events fired by this Observable to bubble up an owner hierarchy by calling this.getBubbleTarget() if
        /// present. There is no implementation in the Observable base class.
        /// This is commonly used by Ext.Components to bubble events to owner Containers.
        /// See <see cref="Ext.Component.getBubbleTarget">Ext.Component.getBubbleTarget</see>. The default implementation in <see cref="Ext.Component">Ext.Component</see> returns the
        /// Component's immediate owner. But if a known target is required, this can be overridden to access the
        /// required target more quickly.
        /// Example:
        /// <code><see cref="Ext.ExtContext.override">Ext.override</see>(<see cref="Ext.form.field.Base">Ext.form.field.Base</see>, {
        /// //  Add functionality to Field's initComponent to enable the change event to bubble
        /// initComponent : <see cref="Ext.Function.createSequence">Ext.Function.createSequence</see>(Ext.form.field.Base.prototype.initComponent, function() {
        /// this.enableBubble('change');
        /// }),
        /// //  We know that we want Field's events to bubble directly to the FormPanel.
        /// getBubbleTarget : function() {
        /// if (!this.formPanel) {
        /// this.formPanel = this.findParentByType('form');
        /// }
        /// return this.formPanel;
        /// }
        /// });
        /// var myForm = new Ext.formPanel({
        /// title: 'User Details',
        /// items: [{
        /// ...
        /// }],
        /// listeners: {
        /// change: function() {
        /// // Title goes red if form has been modified.
        /// myForm.header.setStyle('color', 'red');
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventNames"><p>The event name to bubble, or an Array of event names.</p>
        /// </param>
        public static void enableBubble(object eventNames){}
        /// <summary>
        /// Extracts all of the given property values from the items in the MC. Mainly used as a supporting method for
        /// functions like sum and collect.
        /// </summary>
        /// <param name="property"><p>The property to extract</p>
        /// </param>
        /// <param name="root"><p>'root' property to extract the first argument from. This is used mainly when
        /// extracting field data from Model instances, where the fields are stored inside the 'data' object</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Array">Array</see></span><div><p>The extracted values</p>
        /// </div>
        /// </returns>
        private static JsArray extractValues(JsString property, object root=null){return null;}
        /// <summary>
        /// Filters the objects in this collection by a set of Filters, or by a single
        /// property/value pair with optional parameters for substring matching and case sensitivity. See
        /// Filter for an example of using Filter objects (preferred). Alternatively,
        /// MixedCollection can be easily filtered by property like this:
        /// <code>//create a simple store with a few people defined
        /// var people = new <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see>();
        /// people.addAll([
        /// {id: 1, age: 25, name: 'Ed'},
        /// {id: 2, age: 24, name: 'Tommy'},
        /// {id: 3, age: 24, name: 'Arne'},
        /// {id: 4, age: 26, name: 'Aaron'}
        /// ]);
        /// //a new MixedCollection containing only the items where age == 24
        /// var middleAged = people.filter('age', 24);
        /// </code>
        /// </summary>
        /// <param name="property"><p>A property on your objects, or an array of <see cref="Ext.util.Filter">Filter</see> objects</p>
        /// </param>
        /// <param name="value"><p>Either string that the property values
        /// should start with or a RegExp to test against the property</p>
        /// </param>
        /// <param name="anyMatch"><p>True to match any part of the string, not just the beginning</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="caseSensitive"><p>True for case sensitive comparison.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see></span><div><p>The new filtered collection</p>
        /// </div>
        /// </returns>
        public static Ext.util.MixedCollection filter(object property, object value, object anyMatch=null, object caseSensitive=null){return null;}
        /// <summary>
        /// Filter by a function. Returns a new collection that has been filtered.
        /// The passed function will be called with each object in the collection.
        /// If the function returns true, the value is included otherwise it is filtered.
        /// </summary>
        /// <param name="fn"><p>The function to be called.</p>
        /// <h3>Parameters</h3><ul><li><span>item</span> : Mixed<div><p>The collection item.</p>
        /// </div></li><li><span>key</span> : <see cref="String">String</see><div><p>The key of collection item.</p>
        /// </div></li></ul></param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in
        /// which the function is executed. Defaults to this MixedCollection.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see></span><div><p>The new filtered collection</p>
        /// </div>
        /// </returns>
        public static Ext.util.MixedCollection filterBy(System.Delegate fn, object scope=null){return null;}
        /// <summary>
        /// Returns the first item in the collection which elicits a true return value from the
        /// passed selection function.
        /// </summary>
        /// <param name="fn"><p>The selection function to execute for each item.</p>
        /// <h3>Parameters</h3><ul><li><span>item</span> : Mixed<div><p>The collection item.</p>
        /// </div></li><li><span>key</span> : <see cref="String">String</see><div><p>The key of collection item.</p>
        /// </div></li></ul></param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the
        /// function is executed. Defaults to the browser window.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The first item in the collection which returned true from the selection
        /// function, or null if none was found.</p>
        /// </div>
        /// </returns>
        public static object findBy(System.Delegate fn, object scope=null){return null;}
        /// <summary>
        /// Finds the index of the first matching object in this collection by a specific property/value.
        /// </summary>
        /// <param name="property"><p>The name of a property on your objects.</p>
        /// </param>
        /// <param name="value"><p>A string that the property values
        /// should start with or a RegExp to test against the property.</p>
        /// </param>
        /// <param name="start"><p>The index to start searching at.</p>
        /// <p>Defaults to: <c>0</c></p></param>
        /// <param name="anyMatch"><p>True to match any part of the string, not just the beginning.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="caseSensitive"><p>True for case sensitive comparison.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The matched index or -1</p>
        /// </div>
        /// </returns>
        public static JsNumber findIndex(JsString property, object value, object start=null, object anyMatch=null, object caseSensitive=null){return null;}
        /// <summary>
        /// Find the index of the first matching object in this collection by a function.
        /// If the function returns true it is considered a match.
        /// </summary>
        /// <param name="fn"><p>The function to be called.</p>
        /// <h3>Parameters</h3><ul><li><span>item</span> : Mixed<div><p>The collection item.</p>
        /// </div></li><li><span>key</span> : <see cref="String">String</see><div><p>The key of collection item.</p>
        /// </div></li></ul></param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the function is executed. Defaults to this MixedCollection.</p>
        /// </param>
        /// <param name="start"><p>The index to start searching at.</p>
        /// <p>Defaults to: <c>0</c></p></param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The matched index or -1</p>
        /// </div>
        /// </returns>
        public static JsNumber findIndexBy(System.Delegate fn, object scope=null, object start=null){return null;}
        /// <summary>
        /// Calculates the insertion index of the new item based upon the comparison function passed, or the current sort order.
        /// </summary>
        /// <param name="newItem"><p>The new object to find the insertion position of.</p>
        /// </param>
        /// <param name="sorterFn"><p>The function to sort by. This is the same as the sorting function
        /// passed to <see cref="Ext.util.MixedCollection.sortBy">sortBy</see>. It accepts 2 items from this MixedCollection, and returns -1 0, or 1
        /// depending on the relative sort positions of the 2 compared items.</p>
        /// <p>If omitted, a function <see cref="Ext.util.MixedCollection.generateComparator">generated</see> from the currently defined set of
        /// <see cref="Ext.util.MixedCollection.sorters">sorters</see> will be used.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The insertion point to add the new item into this MixedCollection at using <see cref="Ext.util.MixedCollection.insert">insert</see></p>
        /// </div>
        /// </returns>
        public static JsNumber findInsertionIndex(object newItem, object sorterFn=null){return null;}
        /// <summary>
        /// Fires the specified event with the passed parameters (minus the event name, plus the options object passed
        /// to addListener).
        /// An event may be set to bubble up an Observable parent hierarchy (See <see cref="Ext.Component.getBubbleTarget">Ext.Component.getBubbleTarget</see>) by
        /// calling <see cref="Ext.util.Observable.enableBubble">enableBubble</see>.
        /// </summary>
        /// <param name="eventName"><p>The name of the event to fire.</p>
        /// </param>
        /// <param name="args"><p>Variable number of parameters are passed to handlers.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>returns false if any of the handlers return false otherwise it returns true.</p>
        /// </div>
        /// </returns>
        public static bool fireEvent(JsString eventName, params object[] args){return false;}
        /// <summary>
        /// Returns the first item in the collection.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>the first item in the collection..</p>
        /// </div>
        /// </returns>
        public static object first(){return null;}
        /// <summary>
        /// Returns a comparator function which compares two items and returns -1, 0, or 1 depending
        /// on the currently defined set of sorters.
        /// If there are no <see cref="Ext.util.Sortable.sorters">sorters</see> defined, it returns a function which returns <c>0</c> meaning that no sorting will occur.
        /// </summary>
        public static void generateComparator(){}
        /// <summary>
        /// Returns the item associated with the passed key OR index.
        /// Key has priority over index.  This is the equivalent
        /// of calling getByKey first, then if nothing matched calling getAt.
        /// </summary>
        /// <param name="key"><p>The key or index of the item.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>If the item is found, returns the item.  If the item was not found, returns <c>undefined</c>.
        /// If an item was found, but is a Class, returns <c>null</c>.</p>
        /// </div>
        /// </returns>
        public static object get(object key){return null;}
        /// <summary>
        /// Returns the item at the specified index.
        /// </summary>
        /// <param name="index"><p>The index of the item.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The item at the specified index.</p>
        /// </div>
        /// </returns>
        public static object getAt(JsNumber index){return null;}
        /// <summary>
        /// Gets the bubbling parent for an Observable
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.util.Observable">Ext.util.Observable</see></span><div><p>The bubble parent. null is returned if no bubble target exists</p>
        /// </div>
        /// </returns>
        private static Ext.util.Observable getBubbleParent(){return null;}
        /// <summary>
        /// Returns the item associated with the passed key.
        /// </summary>
        /// <param name="key"><p>The key of the item.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The item associated with the passed key.</p>
        /// </div>
        /// </returns>
        public static object getByKey(object key){return null;}
        /// <summary>
        /// Parameters<li><span>name</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="name">
        /// </param>
        private static void getConfig(object name){}
        /// <summary>
        /// Returns the number of items in the collection.
        /// </summary>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>the number of items in the collection.</p>
        /// </div>
        /// </returns>
        public static JsNumber getCount(){return null;}
        /// <summary>
        /// Gets the first sorter from the sorters collection, excluding
        /// any groupers that may be in place
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see></span><div><p>The sorter, null if none exist</p>
        /// </div>
        /// </returns>
        protected static Ext.util.Sorter getFirstSorter(){return null;}
        /// <summary>
        /// Returns the initial configuration passed to constructor when instantiating
        /// this class.
        /// </summary>
        /// <param name="name"><p>Name of the config option to return.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see>/Mixed</span><div><p>The full config object or a single config value
        /// when <c>name</c> parameter specified.</p>
        /// </div>
        /// </returns>
        public static object getInitialConfig(object name=null){return null;}
        /// <summary>
        /// MixedCollection has a generic way to fetch keys if you implement getKey.  The default implementation
        /// simply returns item.id but you can provide your own implementation
        /// to return a different value as in the following examples:
        /// <code>// normal way
        /// var mc = new <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see>();
        /// mc.add(someEl.dom.id, someEl);
        /// mc.add(otherEl.dom.id, otherEl);
        /// //and so on
        /// // using getKey
        /// var mc = new <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see>();
        /// mc.getKey = function(el){
        /// return el.dom.id;
        /// };
        /// mc.add(someEl);
        /// mc.add(otherEl);
        /// // or via the constructor
        /// var mc = new <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see>(false, function(el){
        /// return el.dom.id;
        /// });
        /// mc.add(someEl);
        /// mc.add(otherEl);
        /// </code>
        /// </summary>
        /// <param name="item"><p>The item for which to find the key.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The key for the passed item.</p>
        /// </div>
        /// </returns>
        public static object getKey(object item){return null;}
        /// <summary>
        /// Returns a range of items in this collection
        /// </summary>
        /// <param name="startIndex"><p>The starting index. Defaults to 0.</p>
        /// </param>
        /// <param name="endIndex"><p>The ending index. Defaults to the last item.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Array">Array</see></span><div><p>An array of items</p>
        /// </div>
        /// </returns>
        public static JsArray getRange(object startIndex=null, object endIndex=null){return null;}
        /// <summary>
        /// Parameters<li><span>config</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="config">
        /// </param>
        private static void hasConfig(object config){}
        /// <summary>
        /// Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
        /// indicates whether the event needs firing or not.
        /// </summary>
        /// <param name="eventName"><p>The name of the event to check for</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p><c>true</c> if the event is being listened for or bubbles, else <c>false</c></p>
        /// </div>
        /// </returns>
        public static bool hasListener(JsString eventName){return false;}
        /// <summary>
        /// Returns index within the collection of the passed Object.
        /// </summary>
        /// <param name="o"><p>The item to find the index of.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>index of the item. Returns -1 if not found.</p>
        /// </div>
        /// </returns>
        public static JsNumber indexOf(object o){return null;}
        /// <summary>
        /// Returns index within the collection of the passed key.
        /// </summary>
        /// <param name="key"><p>The key to find the index of.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>index of the key.</p>
        /// </div>
        /// </returns>
        public static JsNumber indexOfKey(JsString key){return null;}
        /// <summary>
        /// Initialize configuration for this class. a typical example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.awesome.Class', {
        /// // The default config
        /// config: {
        /// name: 'Awesome',
        /// isAwesome: true
        /// },
        /// constructor: function(config) {
        /// this.initConfig(config);
        /// }
        /// });
        /// var awesome = new My.awesome.Class({
        /// name: 'Super Awesome'
        /// });
        /// alert(awesome.getName()); // 'Super Awesome'
        /// </code>
        /// </summary>
        /// <param name="config">
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Base">Ext.Base</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        protected static Ext.Base initConfig(object config){return null;}
        /// <summary>
        /// Performs initialization of this mixin. Component classes using this mixin should call this method during their
        /// own initialization.
        /// </summary>
        public static void initSortable(){}
        /// <summary>
        /// Inserts an item at the specified index in the collection. Fires the add event when complete.
        /// </summary>
        /// <param name="index"><p>The index to insert the item at.</p>
        /// </param>
        /// <param name="key"><p>The key to associate with the new item, or the item itself.</p>
        /// </param>
        /// <param name="o"><p>If the second parameter was a key, the new item.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The item inserted.</p>
        /// </div>
        /// </returns>
        public static object insert(JsNumber index, JsString key, object o=null){return null;}
        /// <summary>
        /// Returns the last item in the collection.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>the last item in the collection..</p>
        /// </div>
        /// </returns>
        public static object last(){return null;}
        /// <summary>
        /// Shorthand for addManagedListener.
        /// Adds listeners to any Observable object (or <see cref="Ext.dom.Element">Ext.Element</see>) which are automatically removed when this Component is
        /// destroyed.
        /// </summary>
        /// <param name="item"><p>The item to which to add a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        /// <param name="opt"><p>If the <c>ename</c> parameter was an event name, this is the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> options.</p>
        /// </param>
        public static void mon(object item, object ename, System.Delegate fn=null, object scope=null, object opt=null){}
        /// <summary>
        /// Shorthand for removeManagedListener.
        /// Removes listeners that were added by the <see cref="Ext.util.Observable.mon">mon</see> method.
        /// </summary>
        /// <param name="item"><p>The item from which to remove a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        public static void mun(object item, object ename, System.Delegate fn=null, object scope=null){}
        /// <summary>
        /// Shorthand for addListener.
        /// Appends an event handler to this object.  For example:
        /// <code>myGridPanel.on("mouseover", this.onMouseOver, this);
        /// </code>
        /// The method also allows for a single argument to be passed which is a config object
        /// containing properties which specify multiple events. For example:
        /// <code>myGridPanel.on({
        /// cellClick: this.onCellClick,
        /// mouseover: this.onMouseOver,
        /// mouseout: this.onMouseOut,
        /// scope: this // Important. Ensure "this" is correct during handler execution
        /// });
        /// </code>
        /// One can also specify options for each event handler separately:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: this.onCellClick, scope: this, single: true},
        /// mouseover: {fn: panel.onMouseOver, scope: panel}
        /// });
        /// </code>
        /// <em>Names</em> of methods in a specified scope may also be used. Note that
        /// <c>scope</c> MUST be specified to use this option:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: 'onCellClick', scope: this, single: true},
        /// mouseover: {fn: 'onMouseOver', scope: panel}
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventName"><p>The name of the event to listen for.
        /// May also be an object who's property names are event names.</p>
        /// </param>
        /// <param name="fn"><p>The method the event invokes, or <em>if <c>scope</c> is specified, the </em>name* of the method within
        /// the specified <c>scope</c>.  Will be called with arguments
        /// given to <see cref="Ext.util.Observable.fireEvent">fireEvent</see> plus the <c>options</c> parameter described below.</p>
        /// </param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the handler function is
        /// executed. <strong>If omitted, defaults to the object which fired the event.</strong></p>
        /// </param>
        /// <param name="options"><p>An object containing handler configuration.</p>
        /// <p><strong>Note:</strong> Unlike in ExtJS 3.x, the options object will also be passed as the last
        /// argument to every event handler.</p>
        /// <p>This object may contain any of the following properties:</p>
        /// <ul><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope (<c>this</c> reference) in which the handler function is executed. <strong>If omitted,
        /// defaults to the object which fired the event.</strong></p>
        /// </div></li><li><span>delay</span> : <see cref="Number">Number</see><div><p>The number of milliseconds to delay the invocation of the handler after the event fires.</p>
        /// </div></li><li><span>single</span> : <see cref="bool">Boolean</see><div><p>True to add a handler to handle just the next firing of the event, and then remove itself.</p>
        /// </div></li><li><span>buffer</span> : <see cref="Number">Number</see><div><p>Causes the handler to be scheduled to run in an <see cref="Ext.util.DelayedTask">Ext.util.DelayedTask</see> delayed
        /// by the specified number of milliseconds. If the event fires again within that time,
        /// the original handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p>
        /// </div></li><li><span>target</span> : <see cref="Ext.util.Observable">Ext.util.Observable</see><div><p>Only call the handler if the event was fired on the target Observable, <em>not</em> if the event
        /// was bubbled up from a child Observable.</p>
        /// </div></li><li><span>element</span> : <see cref="String">String</see><div><p><strong>This option is only valid for listeners bound to <see cref="Ext.Component">Components</see>.</strong>
        /// The name of a Component property which references an element to add a listener to.</p>
        /// <p>  This option is useful during Component construction to add DOM event listeners to elements of
        /// <see cref="Ext.Component">Components</see> which will exist only after the Component is rendered.
        /// For example, to add a click listener to a Panel's body:</p>
        /// <pre><code>  new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'The title',
        /// listeners: {
        /// click: this.handlePanelClick,
        /// element: 'body'
        /// }
        /// });
        /// </code></pre>
        /// <p><strong>Combining Options</strong></p>
        /// <p>Using the options argument, it is possible to combine different types of listeners:</p>
        /// <p>A delayed, one-time listener.</p>
        /// <pre><code>myPanel.on('hide', this.handleClick, this, {
        /// single: true,
        /// delay: 100
        /// });
        /// </code></pre>
        /// </div></li></ul></param>
        public static void on(object eventName, System.Delegate fn=null, object scope=null, object options=null){}
        /// <summary>
        /// Parameters<li><span>names</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>callback</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>scope</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="names">
        /// </param>
        /// <param name="callback">
        /// </param>
        /// <param name="scope">
        /// </param>
        private static void onConfigUpdate(object names, object callback, object scope){}
        /// <summary>
        /// Prepares a given class for observable instances. This method is called when a
        /// class derives from this class or uses this class as a mixin.
        /// </summary>
        /// <param name="T"><p>The class constructor to prepare.</p>
        /// </param>
        private static void prepareClass(System.Delegate T){}
        /// <summary>
        /// Relays selected events from the specified Observable as if the events were fired by this.
        /// For example if you are extending Grid, you might decide to forward some events from store.
        /// So you can do this inside your initComponent:
        /// <code>this.relayEvents(this.getStore(), ['load']);
        /// </code>
        /// The grid instance will then have an observable 'load' event which will be passed the
        /// parameters of the store's load event and any function fired with the grid's load event
        /// would have access to the grid using the <c>this</c> keyword.
        /// </summary>
        /// <param name="origin"><p>The Observable whose events this object is to relay.</p>
        /// </param>
        /// <param name="events"><p>Array of event names to relay.</p>
        /// </param>
        /// <param name="prefix"><p>A common prefix to prepend to the event names. For example:</p>
        /// <pre><code>this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
        /// </code></pre>
        /// <p>Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.</p>
        /// </param>
        public static void relayEvents(object origin, JsArray<String> events, object prefix=null){}
        /// <summary>
        /// Remove an item from the collection.
        /// </summary>
        /// <param name="o"><p>The item to remove.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The item removed or false if no item was removed.</p>
        /// </div>
        /// </returns>
        public static object remove(object o){return null;}
        /// <summary>
        /// Remove all items in the passed array from the collection.
        /// </summary>
        /// <param name="items"><p>An array of items to be removed.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see></span><div><p>this object</p>
        /// </div>
        /// </returns>
        public static Ext.util.MixedCollection removeAll(JsArray items){return null;}
        /// <summary>
        /// Remove an item from a specified index in the collection. Fires the remove event when complete.
        /// </summary>
        /// <param name="index"><p>The index within the collection of the item to remove.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The item removed or false if no item was removed.</p>
        /// </div>
        /// </returns>
        public static object removeAt(JsNumber index){return null;}
        /// <summary>
        /// Removed an item associated with the passed key fom the collection.
        /// </summary>
        /// <param name="key"><p>The key of the item to remove.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The item removed or false if no item was removed.</p>
        /// </div>
        /// </returns>
        public static object removeAtKey(JsString key){return null;}
        /// <summary>
        /// Removes an event handler.
        /// </summary>
        /// <param name="eventName"><p>The type of event the handler was associated with.</p>
        /// </param>
        /// <param name="fn"><p>The handler to remove. <strong>This must be a reference to the function passed into the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> call.</strong></p>
        /// </param>
        /// <param name="scope"><p>The scope originally specified for the handler. It must be the same as the
        /// scope argument specified in the original call to <see cref="Ext.util.Observable.addListener">addListener</see> or the listener will not be removed.</p>
        /// </param>
        public static void removeListener(JsString eventName, System.Delegate fn, object scope=null){}
        /// <summary>
        /// Removes listeners that were added by the mon method.
        /// </summary>
        /// <param name="item"><p>The item from which to remove a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        public static void removeManagedListener(object item, object ename, System.Delegate fn=null, object scope=null){}
        /// <summary>
        /// Remove a single managed listener item
        /// </summary>
        /// <param name="isClear"><p>True if this is being called during a clear</p>
        /// </param>
        /// <param name="managedListener"><p>The managed listener item
        /// See removeManagedListener for other args</p>
        /// </param>
        private static void removeManagedListenerItem(bool isClear, object managedListener){}
        /// <summary>
        /// Reorders each of the items based on a mapping from old index to new index. Internally this
        /// just translates into a sort. The 'sort' event is fired whenever reordering has occured.
        /// </summary>
        /// <param name="mapping"><p>Mapping from old item index to new item index</p>
        /// </param>
        public static void reorder(object mapping){}
        /// <summary>
        /// Replaces an item in the collection. Fires the replace event when complete.
        /// </summary>
        /// <param name="key"><p>The key associated with the item to replace, or the replacement item.</p>
        /// <p>If you supplied a <see cref="Ext.util.AbstractMixedCollection.getKey">getKey</see> implementation for this MixedCollection, or if the key
        /// of your stored items is in a property called <c><b>id</b></c>, then the MixedCollection
        /// will be able to <i>derive</i> the key of the replacement item. If you want to replace an item
        /// with one having the same key value, then just pass the replacement item in this parameter.</p>
        /// </param>
        /// <param name="o"><p>{Object} o (optional) If the first parameter passed was a key, the item to associate
        /// with that key.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The new item.</p>
        /// </div>
        /// </returns>
        public static object replace(JsString key, object o=null){return null;}
        /// <summary>
        /// Resumes firing events (see suspendEvents).
        /// If events were suspended using the <c>queueSuspended</c> parameter, then all events fired
        /// during event suspension will be sent to any listeners now.
        /// </summary>
        public static void resumeEvents(){}
        /// <summary>
        /// Parameters<li><span>config</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>applyIfNotSet</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="config">
        /// </param>
        /// <param name="applyIfNotSet">
        /// </param>
        private static void setConfig(object config, object applyIfNotSet){}
        /// <summary>
        /// Sorts the data in the Store by one or more of its properties. Example usage:
        /// <code>//sort by a single field
        /// myStore.sort('myField', 'DESC');
        /// //sorting by multiple fields
        /// myStore.sort([
        /// {
        /// property : 'age',
        /// direction: 'ASC'
        /// },
        /// {
        /// property : 'name',
        /// direction: 'DESC'
        /// }
        /// ]);
        /// </code>
        /// Internally, Store converts the passed arguments into an array of <see cref="Ext.util.Sorter">Ext.util.Sorter</see> instances, and delegates
        /// the actual sorting to its internal <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see>.
        /// When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
        /// <code>store.sort('myField');
        /// store.sort('myField');
        /// </code>
        /// Is equivalent to this code, because Store handles the toggling automatically:
        /// <code>store.sort('myField', 'ASC');
        /// store.sort('myField', 'DESC');
        /// </code>
        /// </summary>
        /// <param name="sorters"><p>Either a string name of one of the fields in this Store's configured
        /// <see cref="Ext.data.Model">Model</see>, or an array of sorter configurations.</p>
        /// </param>
        /// <param name="direction"><p>The overall direction to sort the data by.</p>
        /// <p>Defaults to: <c>&quot;ASC&quot;</c></p></param>
        /// <returns>
        /// <span><see cref="Ext.util.Sorter">Ext.util.Sorter</see>[]</span><div>
        /// </div>
        /// </returns>
        public static Ext.util.Sorter[] sort(object sorters=null, object direction=null){return null;}
        /// <summary>
        /// Sorts the collection by a single sorter function
        /// </summary>
        /// <param name="sorterFn"><p>The function to sort by</p>
        /// </param>
        public static void sortBy(System.Delegate sorterFn){}
        /// <summary>
        /// Sorts this collection by keys.
        /// </summary>
        /// <param name="direction"><p>'ASC' or 'DESC'. Defaults to 'ASC'.</p>
        /// </param>
        /// <param name="fn"><p>Comparison function that defines the sort order.
        /// Defaults to sorting by case insensitive string.</p>
        /// </param>
        public static void sortByKey(object direction=null, System.Delegate fn=null){}
        /// <summary>
        /// Get the reference to the class from which this object was instantiated. Note that unlike self,
        /// this.statics() is scope-independent and it always returns the class from which it was called, regardless of what
        /// this points to during run-time
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// statics: {
        /// totalCreated: 0,
        /// speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        /// },
        /// constructor: function() {
        /// var statics = this.statics();
        /// alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
        /// // equivalent to: My.Cat.speciesName
        /// alert(this.self.speciesName);   // dependent on 'this'
        /// statics.totalCreated++;
        /// },
        /// clone: function() {
        /// var cloned = new this.self;                      // dependent on 'this'
        /// cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
        /// return cloned;
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.SnowLeopard', {
        /// extend: 'My.Cat',
        /// statics: {
        /// speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
        /// },
        /// constructor: function() {
        /// this.callParent();
        /// }
        /// });
        /// var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
        /// var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
        /// var clone = snowLeopard.clone();
        /// alert(<see cref="Ext.ExtContext.getClassName">Ext.getClassName</see>(clone));         // alerts 'My.SnowLeopard'
        /// alert(clone.groupName);                 // alerts 'Cat'
        /// alert(My.Cat.totalCreated);             // alerts 3
        /// </code>
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.Class">Ext.Class</see></span><div>
        /// </div>
        /// </returns>
        protected static Class statics(){return null;}
        /// <summary>
        /// Collects all of the values of the given property and returns their sum
        /// </summary>
        /// <param name="property"><p>The property to sum by</p>
        /// </param>
        /// <param name="root"><p>'root' property to extract the first argument from. This is used mainly when
        /// summing fields in records, where the fields are all stored inside the 'data' object</p>
        /// </param>
        /// <param name="start"><p>The record index to start at</p>
        /// <p>Defaults to: <c>0</c></p></param>
        /// <param name="end"><p>The record index to end at</p>
        /// <p>Defaults to: <c>-1</c></p></param>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div><p>The total</p>
        /// </div>
        /// </returns>
        public static JsNumber sum(JsString property, object root=null, object start=null, object end=null){return null;}
        /// <summary>
        /// Suspends the firing of all events. (see resumeEvents)
        /// </summary>
        /// <param name="queueSuspended"><p>Pass as true to queue up suspended events to be fired
        /// after the <see cref="Ext.util.Observable.resumeEvents">resumeEvents</see> call instead of discarding all suspended events.</p>
        /// </param>
        public static void suspendEvents(bool queueSuspended){}
        /// <summary>
        /// Shorthand for removeListener.
        /// Removes an event handler.
        /// </summary>
        /// <param name="eventName"><p>The type of event the handler was associated with.</p>
        /// </param>
        /// <param name="fn"><p>The handler to remove. <strong>This must be a reference to the function passed into the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> call.</strong></p>
        /// </param>
        /// <param name="scope"><p>The scope originally specified for the handler. It must be the same as the
        /// scope argument specified in the original call to <see cref="Ext.util.Observable.addListener">addListener</see> or the listener will not be removed.</p>
        /// </param>
        public static void un(JsString eventName, System.Delegate fn, object scope=null){}
        public CheckboxManager(CheckboxManagerConfig config){}
        public CheckboxManager(){}
        public CheckboxManager(params object[] args){}
    }
    #endregion
    #region CheckboxManagerConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class CheckboxManagerConfig : Ext.util.MixedCollectionConfig
    {
        public CheckboxManagerConfig(params object[] args){}
    }
    #endregion
    #region CheckboxManagerEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class CheckboxManagerEvents : Ext.util.MixedCollectionEvents
    {
        public CheckboxManagerEvents(params object[] args){}
    }
    #endregion
}
