//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.data
{
    #region Model
    /// <inheritdocs />
    /// <summary>
    /// <p>A Model represents some object that your application manages. For example, one might define a Model for Users,
    /// Products, Cars, or any other real-world object that we want to model in the system. Models are registered via the
    /// <see cref="Ext.ModelManager">model manager</see>, and are used by <see cref="Ext.data.Store">stores</see>, which are in turn used by many
    /// of the data-bound components in Ext.</p>
    /// <p>Models are defined as a set of fields and any arbitrary methods and properties relevant to the model. For example:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: [
    /// {name: 'name',  type: 'string'},
    /// {name: 'age',   type: 'int', convert: null},
    /// {name: 'phone', type: 'string'},
    /// {name: 'alive', type: 'boolean', defaultValue: true, convert: null}
    /// ],
    /// changeName: function() {
    /// var oldName = this.get('name'),
    /// newName = oldName + " The Barbarian";
    /// this.set('name', newName);
    /// }
    /// });
    /// </code></pre>
    /// <p>The fields array is turned into a <see cref="Ext.util.MixedCollection">MixedCollection</see> automatically by the <see cref="Ext.ModelManager">ModelManager</see>, and all other functions and properties are copied to the new Model's prototype.</p>
    /// <p>By default, the built in numeric and boolean field types have a (@link <see cref="Ext.data.FieldConfig.convert">Ext.data.Field.convert</see>} function which coerces string
    /// values in raw data into the field's type. For better performance with <see cref="Ext.data.reader.Json">Json</see> or <see cref="Ext.data.reader.Array">Array</see>
    /// readers <em>if you are in control of the data fed into this Model</em>, you can null out the default convert function which will cause
    /// the raw property to be copied directly into the Field's value.</p>
    /// <p>Now we can create instances of our User model and call any model logic we defined:</p>
    /// <pre><code>var user = <see cref="Ext.ExtContext.create">Ext.create</see>('User', {
    /// name : 'Conan',
    /// age  : 24,
    /// phone: '555-555-5555'
    /// });
    /// user.changeName();
    /// user.get('name'); //returns "Conan The Barbarian"
    /// </code></pre>
    /// <h1>Validations</h1>
    /// <p>Models have built-in support for validations, which are executed against the validator functions in <see cref="Ext.data.validations">Ext.data.validations</see> (<see cref="Ext.data.validations">see all validation functions</see>). Validations are easy to add to
    /// models:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: [
    /// {name: 'name',     type: 'string'},
    /// {name: 'age',      type: 'int'},
    /// {name: 'phone',    type: 'string'},
    /// {name: 'gender',   type: 'string'},
    /// {name: 'username', type: 'string'},
    /// {name: 'alive',    type: 'boolean', defaultValue: true}
    /// ],
    /// validations: [
    /// {type: 'presence',  field: 'age'},
    /// {type: 'length',    field: 'name',     min: 2},
    /// {type: 'inclusion', field: 'gender',   list: ['Male', 'Female']},
    /// {type: 'exclusion', field: 'username', list: ['Admin', 'Operator']},
    /// {type: 'format',    field: 'username', matcher: /([a-z]+)[0-9]{2,3}/}
    /// ]
    /// });
    /// </code></pre>
    /// <p>The validations can be run by simply calling the <see cref="Ext.data.Model.validate">validate</see> function, which returns a <see cref="Ext.data.Errors">Ext.data.Errors</see>
    /// object:</p>
    /// <pre><code>var instance = <see cref="Ext.ExtContext.create">Ext.create</see>('User', {
    /// name: 'Ed',
    /// gender: 'Male',
    /// username: 'edspencer'
    /// });
    /// var errors = instance.validate();
    /// </code></pre>
    /// <h1>Associations</h1>
    /// <p>Models can have associations with other Models via <see cref="Ext.data.association.HasOne">Ext.data.association.HasOne</see>,
    /// <see cref="Ext.data.association.BelongsTo">belongsTo</see> and <see cref="Ext.data.association.HasMany">hasMany</see> associations.
    /// For example, let's say we're writing a blog administration application which deals with Users, Posts and Comments.
    /// We can express the relationships between these models like this:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('Post', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id', 'user_id'],
    /// belongsTo: 'User',
    /// hasMany  : {model: 'Comment', name: 'comments'}
    /// });
    /// <see cref="Ext.ExtContext.define">Ext.define</see>('Comment', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id', 'user_id', 'post_id'],
    /// belongsTo: 'Post'
    /// });
    /// <see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id'],
    /// hasMany: [
    /// 'Post',
    /// {model: 'Comment', name: 'comments'}
    /// ]
    /// });
    /// </code></pre>
    /// <p>See the docs for <see cref="Ext.data.association.HasOne">Ext.data.association.HasOne</see>, <see cref="Ext.data.association.BelongsTo">Ext.data.association.BelongsTo</see> and
    /// <see cref="Ext.data.association.HasMany">Ext.data.association.HasMany</see> for details on the usage and configuration of associations.
    /// Note that associations can also be specified like this:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id'],
    /// associations: [
    /// {type: 'hasMany', model: 'Post',    name: 'posts'},
    /// {type: 'hasMany', model: 'Comment', name: 'comments'}
    /// ]
    /// });
    /// </code></pre>
    /// <h1>Using a Proxy</h1>
    /// <p>Models are great for representing types of data and relationships, but sooner or later we're going to want to load or
    /// save that data somewhere. All loading and saving of data is handled via a <see cref="Ext.data.proxy.Proxy">Proxy</see>, which
    /// can be set directly on the Model:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id', 'name', 'email'],
    /// proxy: {
    /// type: 'rest',
    /// url : '/users'
    /// }
    /// });
    /// </code></pre>
    /// <p>Here we've set up a <see cref="Ext.data.proxy.Rest">Rest Proxy</see>, which knows how to load and save data to and from a
    /// RESTful backend. Let's see how this works:</p>
    /// <pre><code>var user = <see cref="Ext.ExtContext.create">Ext.create</see>('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
    /// user.save(); //POST /users
    /// </code></pre>
    /// <p>Calling <see cref="Ext.data.Model.save">save</see> on the new Model instance tells the configured RestProxy that we wish to persist this Model's
    /// data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an id,
    /// and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
    /// configure any Proxy on any Model and always follow this API - see <see cref="Ext.data.proxy.Proxy">Ext.data.proxy.Proxy</see> for a full list.</p>
    /// <p>Loading data via the Proxy is equally easy:</p>
    /// <pre><code>//get a reference to the User model class
    /// var User = <see cref="Ext.ModelManager.getModel">Ext.ModelManager.getModel</see>('User');
    /// //Uses the configured RestProxy to make a GET request to /users/123
    /// User.load(123, {
    /// success: function(user) {
    /// console.log(user.getId()); //logs 123
    /// }
    /// });
    /// </code></pre>
    /// <p>Models can also be updated and destroyed easily:</p>
    /// <pre><code>//the user Model we loaded in the last snippet:
    /// user.set('name', 'Edward Spencer');
    /// //tells the Proxy to save the Model. In this case it will perform a PUT request to /users/123 as this Model already has an id
    /// user.save({
    /// success: function() {
    /// console.log('The User was updated');
    /// }
    /// });
    /// //tells the Proxy to destroy the Model. Performs a DELETE request to /users/123
    /// user.destroy({
    /// success: function() {
    /// console.log('The User was destroyed!');
    /// }
    /// });
    /// </code></pre>
    /// <h1>Usage in Stores</h1>
    /// <p>It is very common to want to load a set of Model instances to be displayed and manipulated in the UI. We do this by
    /// creating a <see cref="Ext.data.Store">Store</see>:</p>
    /// <pre><code>var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User'
    /// });
    /// //uses the Proxy we set up on Model to load the Store data
    /// store.load();
    /// </code></pre>
    /// <p>A Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a
    /// set of added, updated and removed Model instances to be synchronized with the server via the Proxy. See the <see cref="Ext.data.Store">Store docs</see> for more information on Stores.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Model : Ext.Base, Ext.util.Observable
    {
        /// <summary>
        /// An array of associations for this model.
        /// </summary>
        public JsObject associations;
        /// <summary>
        /// One or more BelongsTo associations for this model.
        /// </summary>
        public object belongsTo;
        /// <summary>
        /// The name of a property that is used for submitting this Model's unique client-side identifier
        /// to the server when multiple phantom records are saved as part of the same Operation.
        /// In such a case, the server response should include the client id for each record
        /// so that the server response data can be used to update the client-side records if necessary.
        /// This property cannot have the same name as any of this Model's fields.
        /// Defaults to: <c>null</c>
        /// </summary>
        public JsString clientIdProperty;
        /// <summary>
        /// The string type of the default Model Proxy. Defaults to 'ajax'.
        /// Defaults to: <c>&quot;ajax&quot;</c>
        /// </summary>
        public JsString defaultProxyType;
        /// <summary>
        /// One or more HasMany associations for this model.
        /// </summary>
        public object hasMany;
        /// <summary>
        /// The name of the field treated as this Model's unique id. Defaults to 'id'.
        /// Defaults to: <c>&quot;id&quot;</c>
        /// </summary>
        public JsString idProperty;
        /// <summary>
        /// The id generator to use for this model. The default id generator does not generate
        /// values for the idProperty.
        /// This can be overridden at the model level to provide a custom generator for a model.
        /// The simplest form of this would be:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModel', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// requires: ['<see cref="Ext.data.SequentialIdGenerator">Ext.data.SequentialIdGenerator</see>'],
        /// idgen: 'sequential',
        /// ...
        /// });
        /// </code>
        /// The above would generate <see cref="Ext.data.SequentialIdGenerator">sequential</see> id's such
        /// as 1, 2, 3 etc..
        /// Another useful id generator is <see cref="Ext.data.UuidGenerator">Ext.data.UuidGenerator</see>:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModel', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// requires: ['<see cref="Ext.data.UuidGenerator">Ext.data.UuidGenerator</see>'],
        /// idgen: 'uuid',
        /// ...
        /// });
        /// </code>
        /// An id generation can also be further configured:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModel', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// idgen: {
        /// type: 'sequential',
        /// seed: 1000,
        /// prefix: 'ID_'
        /// }
        /// });
        /// </code>
        /// The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
        /// If multiple models share an id space, a single generator can be shared:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModelX', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// idgen: {
        /// type: 'sequential',
        /// id: 'xy'
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModelY', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// idgen: {
        /// type: 'sequential',
        /// id: 'xy'
        /// }
        /// });
        /// </code>
        /// For more complex, shared id generators, a custom generator is the best approach.
        /// See <see cref="Ext.data.IdGenerator">Ext.data.IdGenerator</see> for details on creating custom id generators.
        /// </summary>
        public object idgen;
        /// <summary>
        /// A config object containing one or more event handlers to be added to this object during initialization. This
        /// should be a valid listeners config object as specified in the addListener example for attaching multiple
        /// handlers at once.
        /// <strong>DOM events from Ext JS <see cref="Ext.Component">Components</see></strong>
        /// While <em>some</em> Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
        /// only done when extra value can be added. For example the <see cref="Ext.view.View">DataView</see>'s <strong><c><see cref="Ext.view.ViewEvents.itemclick">itemclick</see></c></strong> event passing the node clicked on. To access DOM events directly from a
        /// child element of a Component, we need to specify the <c>element</c> option to identify the Component property to add a
        /// DOM listener to:
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// width: 400,
        /// height: 200,
        /// dockedItems: [{
        /// xtype: 'toolbar'
        /// }],
        /// listeners: {
        /// click: {
        /// element: 'el', //bind to the underlying el property on the panel
        /// fn: function(){ console.log('click el'); }
        /// },
        /// dblclick: {
        /// element: 'body', //bind to the underlying body property on the panel
        /// fn: function(){ console.log('dblclick body'); }
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsObject listeners;
        /// <summary>
        /// The name of the property on this Persistable object that its data is saved to. Defaults to 'data'
        /// (i.e: all persistable data resides in this.data.)
        /// Defaults to: <c>&quot;data&quot;</c>
        /// </summary>
        public JsString persistenceProperty;
        /// <summary>
        /// The proxy to use for this model.
        /// </summary>
        public object proxy;
        /// <summary>
        /// An array of validations for this model.
        /// </summary>
        public JsObject validations;
        /// <summary>
        /// True if this Record has been modified.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool dirty{get;set;}
        /// <summary>
        /// Internal flag used to track whether or not the model instance is currently being edited.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool editing{get;set;}
        /// <summary>
        /// Initial suspended call count. Incremented when suspendEvents is called, decremented when resumeEvents is called.
        /// Defaults to: <c>0</c>
        /// </summary>
        public JsNumber eventsSuspended{get;set;}
        /// <summary>
        /// A Collection of the fields defined for this Model (including fields defined in superclasses)
        /// This is a collection of <see cref="Ext.data.Field">Ext.data.Field</see> instances, each of which encapsulates information that the field was configured with.
        /// By default, you can specify a field as simply a String, representing the <em>name</em> of the field, but a Field encapsulates
        /// <see cref="Ext.data.FieldConfig.type">data type</see>, <see cref="Ext.data.FieldConfig.convert">custom conversion</see> of raw data, and a <see cref="Ext.data.FieldConfig.mapping">mapping</see>
        /// property to specify by name of index, how to extract a field's value from a raw data object.
        /// </summary>
        public Ext.util.MixedCollection fields{get;set;}
        /// <summary>
        /// This object holds a key for any event that has a listener. The listener may be set
        /// directly on the instance, or on its class or a super class (via observe) or
        /// on the MVC EventBus. The values of this object are truthy
        /// (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
        /// of listeners. The value for an event is truthy if the event must be fired and is
        /// falsy if there is no need to fire the event.
        /// The intended use of this property is to avoid the expense of fireEvent calls when
        /// there are no listeners. This can be particularly helpful when one would otherwise
        /// have to call fireEvent hundreds or thousands of times. It is used like this:
        /// <code> if (this.hasListeners.foo) {
        /// this.fireEvent('foo', this, arg1);
        /// }
        /// </code>
        /// </summary>
        public JsObject hasListeners{get;set;}
        /// <summary>
        /// An internal unique ID for each Model instance, used to identify Models that don't have an ID yet
        /// </summary>
        private object internalId{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Model, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool isModel{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Observable, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool isObservable{get;set;}
        /// <summary>
        /// Key: value pairs of all fields whose values have changed
        /// Defaults to: <c>{}</c>
        /// </summary>
        public JsObject modified{get;set;}
        /// <summary>
        /// True when the record does not yet exist in a server-side database (see setDirty).
        /// Any record which has a real database pk set as its id property is NOT a phantom -- it's real.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool phantom{get;set;}
        /// <summary>
        /// The raw data used to create this model if created via a reader.
        /// </summary>
        public JsObject raw{get;set;}
        /// <summary>
        /// The Store to which this instance belongs. NOTE: If this
        /// instance is bound to multiple stores, this property will reference only the
        /// first. To examine all the stores, use the stores property instead.
        /// </summary>
        public Ext.data.Store store{get;set;}
        /// <summary>
        /// The Stores to which this instance is bound.
        /// Defaults to: <c>[]</c>
        /// </summary>
        public Ext.data.Store stores{get;set;}
        /// <summary>
        /// Creates new Model instance.
        /// </summary>
        /// <param name="data"><p>An object containing keys corresponding to this model's fields, and their associated values</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public Model(object data){}
        /// <summary>
        /// Adds the specified events to the list of events which this Observable may fire.
        /// </summary>
        /// <param name="eventNames"><p>Either an object with event names as properties with
        /// a value of <c>true</c>. For example:</p>
        /// <pre><code>this.addEvents({
        /// storeloaded: true,
        /// storecleared: true
        /// });
        /// </code></pre>
        /// <p>Or any number of event names as separate parameters. For example:</p>
        /// <pre><code>this.addEvents('storeloaded', 'storecleared');
        /// </code></pre>
        /// </param>
        public virtual void addEvents(object eventNames){}
        /// <summary>
        /// Appends an event handler to this object.  For example:
        /// <code>myGridPanel.on("mouseover", this.onMouseOver, this);
        /// </code>
        /// The method also allows for a single argument to be passed which is a config object
        /// containing properties which specify multiple events. For example:
        /// <code>myGridPanel.on({
        /// cellClick: this.onCellClick,
        /// mouseover: this.onMouseOver,
        /// mouseout: this.onMouseOut,
        /// scope: this // Important. Ensure "this" is correct during handler execution
        /// });
        /// </code>
        /// One can also specify options for each event handler separately:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: this.onCellClick, scope: this, single: true},
        /// mouseover: {fn: panel.onMouseOver, scope: panel}
        /// });
        /// </code>
        /// <em>Names</em> of methods in a specified scope may also be used. Note that
        /// <c>scope</c> MUST be specified to use this option:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: 'onCellClick', scope: this, single: true},
        /// mouseover: {fn: 'onMouseOver', scope: panel}
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventName"><p>The name of the event to listen for.
        /// May also be an object who's property names are event names.</p>
        /// </param>
        /// <param name="fn"><p>The method the event invokes, or <em>if <c>scope</c> is specified, the </em>name* of the method within
        /// the specified <c>scope</c>.  Will be called with arguments
        /// given to <see cref="Ext.util.Observable.fireEvent">fireEvent</see> plus the <c>options</c> parameter described below.</p>
        /// </param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the handler function is
        /// executed. <strong>If omitted, defaults to the object which fired the event.</strong></p>
        /// </param>
        /// <param name="options"><p>An object containing handler configuration.</p>
        /// <p><strong>Note:</strong> Unlike in ExtJS 3.x, the options object will also be passed as the last
        /// argument to every event handler.</p>
        /// <p>This object may contain any of the following properties:</p>
        /// <ul><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope (<c>this</c> reference) in which the handler function is executed. <strong>If omitted,
        /// defaults to the object which fired the event.</strong></p>
        /// </div></li><li><span>delay</span> : <see cref="Number">Number</see><div><p>The number of milliseconds to delay the invocation of the handler after the event fires.</p>
        /// </div></li><li><span>single</span> : <see cref="bool">Boolean</see><div><p>True to add a handler to handle just the next firing of the event, and then remove itself.</p>
        /// </div></li><li><span>buffer</span> : <see cref="Number">Number</see><div><p>Causes the handler to be scheduled to run in an <see cref="Ext.util.DelayedTask">Ext.util.DelayedTask</see> delayed
        /// by the specified number of milliseconds. If the event fires again within that time,
        /// the original handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p>
        /// </div></li><li><span>target</span> : <see cref="Ext.util.Observable">Ext.util.Observable</see><div><p>Only call the handler if the event was fired on the target Observable, <em>not</em> if the event
        /// was bubbled up from a child Observable.</p>
        /// </div></li><li><span>element</span> : <see cref="String">String</see><div><p><strong>This option is only valid for listeners bound to <see cref="Ext.Component">Components</see>.</strong>
        /// The name of a Component property which references an element to add a listener to.</p>
        /// <p>  This option is useful during Component construction to add DOM event listeners to elements of
        /// <see cref="Ext.Component">Components</see> which will exist only after the Component is rendered.
        /// For example, to add a click listener to a Panel's body:</p>
        /// <pre><code>  new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'The title',
        /// listeners: {
        /// click: this.handlePanelClick,
        /// element: 'body'
        /// }
        /// });
        /// </code></pre>
        /// <p><strong>Combining Options</strong></p>
        /// <p>Using the options argument, it is possible to combine different types of listeners:</p>
        /// <p>A delayed, one-time listener.</p>
        /// <pre><code>myPanel.on('hide', this.handleClick, this, {
        /// single: true,
        /// delay: 100
        /// });
        /// </code></pre>
        /// </div></li></ul></param>
        public virtual void addListener(object eventName, System.Delegate fn=null, object scope=null, object options=null){}
        /// <summary>
        /// Adds listeners to any Observable object (or Ext.Element) which are automatically removed when this Component is
        /// destroyed.
        /// </summary>
        /// <param name="item"><p>The item to which to add a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        /// <param name="opt"><p>If the <c>ename</c> parameter was an event name, this is the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> options.</p>
        /// </param>
        public virtual void addManagedListener(object item, object ename, System.Delegate fn=null, object scope=null, object opt=null){}
        /// <summary>
        /// If this Model instance has been joined to a store, the store's
        /// afterCommit method is called
        /// </summary>
        private void afterCommit(){}
        /// <summary>
        /// If this Model instance has been joined to a store, the store's
        /// afterEdit method is called
        /// </summary>
        /// <param name="modifiedFieldNames"><p>Array of field names changed during edit.</p>
        /// </param>
        private void afterEdit(object modifiedFieldNames=null){}
        /// <summary>
        /// If this Model instance has been joined to a store, the store's
        /// afterReject method is called
        /// </summary>
        private void afterReject(){}
        /// <summary>
        /// Begins an edit. While in edit mode, no events (e.g.. the update event) are relayed to the containing store.
        /// When an edit has begun, it must be followed by either endEdit or cancelEdit.
        /// </summary>
        public void beginEdit(){}
        /// <summary>
        /// Helper function used by afterEdit, afterReject and afterCommit. Calls the given method on the
        /// store that this instance has joined, if any. The store function
        /// will always be called with the model instance as its single argument. If this model is joined to
        /// a Ext.data.NodeStore, then this method calls the given method on the NodeStore and the associated Ext.data.TreeStore
        /// </summary>
        /// <param name="fn"><p>The function to call on the store</p>
        /// </param>
        private void callStore(System.Delegate fn){}
        /// <summary>
        /// Cancels all changes made in the current edit operation.
        /// </summary>
        public void cancelEdit(){}
        /// <summary>
        /// Removes all listeners for this object including the managed listeners
        /// </summary>
        public virtual void clearListeners(){}
        /// <summary>
        /// Removes all managed listeners for this object.
        /// </summary>
        public virtual void clearManagedListeners(){}
        /// <summary>
        /// Usually called by the Ext.data.Store which owns the model instance. Commits all changes made to the
        /// instance since either creation or the last commit operation.
        /// Developers should subscribe to the <see cref="Ext.data.StoreEvents.update">Ext.data.Store.update</see> event to have their code notified of commit
        /// operations.
        /// </summary>
        /// <param name="silent"><p>True to skip notification of the owning store of the change.
        /// Defaults to false.</p>
        /// </param>
        public void commit(object silent=null){}
        /// <summary>
        /// Continue to fire event.
        /// </summary>
        /// <param name="eventName">
        /// </param>
        /// <param name="args">
        /// </param>
        /// <param name="bubbles">
        /// </param>
        public virtual void continueFireEvent(JsString eventName, object args=null, object bubbles=null){}
        /// <summary>
        /// Creates a copy (clone) of this Model instance.
        /// </summary>
        /// <param name="id"><p>A new id, defaults to the id of the instance being copied.
        /// See <c><see cref="Ext.data.Model.id">id</see></c>. To generate a phantom instance with a new id use:</p>
        /// <pre><code>var rec = record.copy(); // clone the record
        /// <see cref="Ext.data.Model.id">Ext.data.Model.id</see>(rec); // automatically generate a unique sequential id
        /// </code></pre>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see></span><div>
        /// </div>
        /// </returns>
        public Ext.data.Model copy(object id=null){return null;}
        /// <summary>
        /// Copies data from the passed record into this record. If the passed record is undefined, does nothing.
        /// If this is a phantom record (represented only in the client, with no corresponding database entry), and
        /// the source record is not a phantom, then this record acquires the id of the source record.
        /// </summary>
        /// <param name="sourceRecord"><p>The record to copy data from.</p>
        /// </param>
        private void copyFrom(Ext.data.Model sourceRecord){}
        /// <summary>
        /// Creates an event handling function which refires the event from this object as the passed event name.
        /// </summary>
        /// <param name="newName">
        /// </param>
        /// <param name="beginEnd"><p>The caller can specify on which indices to slice</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Function">Function</see></span><div>
        /// </div>
        /// </returns>
        public virtual System.Delegate createRelayer(object newName, object beginEnd=null){return null;}
        /// <summary>
        /// Destroys the model using the configured proxy.
        /// </summary>
        /// <param name="options"><p>Options to pass to the proxy. Config object for <see cref="Ext.data.Operation">Ext.data.Operation</see>.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see></span><div><p>The Model instance</p>
        /// </div>
        /// </returns>
        public Ext.data.Model destroy(object options){return null;}
        /// <summary>
        /// Enables events fired by this Observable to bubble up an owner hierarchy by calling this.getBubbleTarget() if
        /// present. There is no implementation in the Observable base class.
        /// This is commonly used by Ext.Components to bubble events to owner Containers.
        /// See <see cref="Ext.Component.getBubbleTarget">Ext.Component.getBubbleTarget</see>. The default implementation in <see cref="Ext.Component">Ext.Component</see> returns the
        /// Component's immediate owner. But if a known target is required, this can be overridden to access the
        /// required target more quickly.
        /// Example:
        /// <code><see cref="Ext.ExtContext.override">Ext.override</see>(<see cref="Ext.form.field.Base">Ext.form.field.Base</see>, {
        /// //  Add functionality to Field's initComponent to enable the change event to bubble
        /// initComponent : <see cref="Ext.Function.createSequence">Ext.Function.createSequence</see>(Ext.form.field.Base.prototype.initComponent, function() {
        /// this.enableBubble('change');
        /// }),
        /// //  We know that we want Field's events to bubble directly to the FormPanel.
        /// getBubbleTarget : function() {
        /// if (!this.formPanel) {
        /// this.formPanel = this.findParentByType('form');
        /// }
        /// return this.formPanel;
        /// }
        /// });
        /// var myForm = new Ext.formPanel({
        /// title: 'User Details',
        /// items: [{
        /// ...
        /// }],
        /// listeners: {
        /// change: function() {
        /// // Title goes red if form has been modified.
        /// myForm.header.setStyle('color', 'red');
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventNames"><p>The event name to bubble, or an Array of event names.</p>
        /// </param>
        public virtual void enableBubble(object eventNames){}
        /// <summary>
        /// Ends an edit. If any data was modified, the containing store is notified (ie, the store's update event will
        /// fire).
        /// </summary>
        /// <param name="silent"><p>True to not notify the store of the change</p>
        /// </param>
        /// <param name="modifiedFieldNames"><p>Array of field names changed during edit.</p>
        /// </param>
        public void endEdit(bool silent, object modifiedFieldNames=null){}
        /// <summary>
        /// Fires the specified event with the passed parameters (minus the event name, plus the options object passed
        /// to addListener).
        /// An event may be set to bubble up an Observable parent hierarchy (See <see cref="Ext.Component.getBubbleTarget">Ext.Component.getBubbleTarget</see>) by
        /// calling <see cref="Ext.util.Observable.enableBubble">enableBubble</see>.
        /// </summary>
        /// <param name="eventName"><p>The name of the event to fire.</p>
        /// </param>
        /// <param name="args"><p>Variable number of parameters are passed to handlers.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>returns false if any of the handlers return false otherwise it returns true.</p>
        /// </div>
        /// </returns>
        public virtual bool fireEvent(JsString eventName, params object[] args){return false;}
        /// <summary>
        /// Returns the value of the given field
        /// </summary>
        /// <param name="fieldName"><p>The field to fetch the value for</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The value</p>
        /// </div>
        /// </returns>
        public object get(JsString fieldName){return null;}
        /// <summary>
        /// Gets all of the data from this Models loaded associations. It does this recursively - for example if we have a
        /// User which hasMany Orders, and each Order hasMany OrderItems, it will return an object like this:
        /// <code>{
        /// orders: [
        /// {
        /// id: 123,
        /// status: 'shipped',
        /// orderItems: [
        /// ...
        /// ]
        /// }
        /// ]
        /// }
        /// </code>
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The nested data set for the Model's loaded associations</p>
        /// </div>
        /// </returns>
        public object getAssociatedData(){return null;}
        /// <summary>
        /// Gets the bubbling parent for an Observable
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.util.Observable">Ext.util.Observable</see></span><div><p>The bubble parent. null is returned if no bubble target exists</p>
        /// </div>
        /// </returns>
        public virtual Ext.util.Observable getBubbleParent(){return null;}
        /// <summary>
        /// Gets a hash of only the fields that have been modified since this Model was created or commited.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public object getChanges(){return null;}
        /// <summary>
        /// Gets all values for each field in this model and returns an object
        /// containing the current data.
        /// </summary>
        /// <param name="includeAssociated"><p>True to also include associated data. Defaults to false.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>An object hash containing all the values in this model</p>
        /// </div>
        /// </returns>
        public object getData(bool includeAssociated){return null;}
        /// <summary>
        /// Returns an Array of Field definitions which define this Model's structure
        /// Fields are sorted upon Model class definition. Fields with custom <see cref="Ext.data.FieldConfig.convert">convert</see> functions
        /// are moved to <em>after</em> fields with no convert functions. This is so that convert functions which rely on existing
        /// field values will be able to read those field values.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.data.Field">Ext.data.Field</see>[]</span><div><p>The defined Fields for this Model.</p>
        /// </div>
        /// </returns>
        public Ext.data.Field[] getFields(){return null;}
        /// <summary>
        /// Returns the unique ID allocated to this model instance as defined by idProperty.
        /// </summary>
        /// <returns>
        /// <span><see cref="Number">Number</see>/<see cref="String">String</see></span><div><p>The id</p>
        /// </div>
        /// </returns>
        public object getId(){return null;}
        /// <summary>
        /// Gets the names of all the fields that were modified during an edit
        /// </summary>
        /// <returns>
        /// <span><see cref="String">String</see>[]</span><div><p>An array of modified field names</p>
        /// </div>
        /// </returns>
        private JsString[] getModifiedFieldNames(){return null;}
        /// <summary>
        /// </summary>
        private void getObservableId(){}
        /// <summary>
        /// Returns the configured Proxy for this Model.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.data.proxy.Proxy">Ext.data.proxy.Proxy</see></span><div><p>The proxy</p>
        /// </div>
        /// </returns>
        public Ext.data.proxy.Proxy getProxy(){return null;}
        /// <summary>
        /// Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
        /// indicates whether the event needs firing or not.
        /// </summary>
        /// <param name="eventName"><p>The name of the event to check for</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p><c>true</c> if the event is being listened for or bubbles, else <c>false</c></p>
        /// </div>
        /// </returns>
        public virtual bool hasListener(JsString eventName){return false;}
        /// <summary>
        /// Checks if two values are equal, taking into account certain
        /// special factors, for example dates.
        /// </summary>
        /// <param name="a"><p>The first value</p>
        /// </param>
        /// <param name="b"><p>The second value</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if the values are equal</p>
        /// </div>
        /// </returns>
        private bool isEqual(object a, object b){return false;}
        /// <summary>
        /// Returns true if the passed field name has been modified since the load or last commit.
        /// </summary>
        /// <param name="fieldName"><p><see cref="Ext.data.FieldConfig.name">Ext.data.Field.name</see></p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div>
        /// </div>
        /// </returns>
        public bool isModified(JsString fieldName){return false;}
        /// <summary>
        /// Checks if the model is valid. See validate.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if the model is valid.</p>
        /// </div>
        /// </returns>
        public bool isValid(){return false;}
        /// <summary>
        /// Tells this model instance that it has been added to a store.
        /// </summary>
        /// <param name="store"><p>The store to which this model has been added.</p>
        /// </param>
        public void join(Ext.data.Store store){}
        /// <summary>
        /// Shorthand for addManagedListener.
        /// Adds listeners to any Observable object (or <see cref="Ext.dom.Element">Ext.Element</see>) which are automatically removed when this Component is
        /// destroyed.
        /// </summary>
        /// <param name="item"><p>The item to which to add a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        /// <param name="opt"><p>If the <c>ename</c> parameter was an event name, this is the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> options.</p>
        /// </param>
        public virtual void mon(object item, object ename, System.Delegate fn=null, object scope=null, object opt=null){}
        /// <summary>
        /// Shorthand for removeManagedListener.
        /// Removes listeners that were added by the <see cref="Ext.util.Observable.mon">mon</see> method.
        /// </summary>
        /// <param name="item"><p>The item from which to remove a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        public virtual void mun(object item, object ename, System.Delegate fn=null, object scope=null){}
        /// <summary>
        /// Shorthand for addListener.
        /// Appends an event handler to this object.  For example:
        /// <code>myGridPanel.on("mouseover", this.onMouseOver, this);
        /// </code>
        /// The method also allows for a single argument to be passed which is a config object
        /// containing properties which specify multiple events. For example:
        /// <code>myGridPanel.on({
        /// cellClick: this.onCellClick,
        /// mouseover: this.onMouseOver,
        /// mouseout: this.onMouseOut,
        /// scope: this // Important. Ensure "this" is correct during handler execution
        /// });
        /// </code>
        /// One can also specify options for each event handler separately:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: this.onCellClick, scope: this, single: true},
        /// mouseover: {fn: panel.onMouseOver, scope: panel}
        /// });
        /// </code>
        /// <em>Names</em> of methods in a specified scope may also be used. Note that
        /// <c>scope</c> MUST be specified to use this option:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: 'onCellClick', scope: this, single: true},
        /// mouseover: {fn: 'onMouseOver', scope: panel}
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventName"><p>The name of the event to listen for.
        /// May also be an object who's property names are event names.</p>
        /// </param>
        /// <param name="fn"><p>The method the event invokes, or <em>if <c>scope</c> is specified, the </em>name* of the method within
        /// the specified <c>scope</c>.  Will be called with arguments
        /// given to <see cref="Ext.util.Observable.fireEvent">fireEvent</see> plus the <c>options</c> parameter described below.</p>
        /// </param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the handler function is
        /// executed. <strong>If omitted, defaults to the object which fired the event.</strong></p>
        /// </param>
        /// <param name="options"><p>An object containing handler configuration.</p>
        /// <p><strong>Note:</strong> Unlike in ExtJS 3.x, the options object will also be passed as the last
        /// argument to every event handler.</p>
        /// <p>This object may contain any of the following properties:</p>
        /// <ul><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope (<c>this</c> reference) in which the handler function is executed. <strong>If omitted,
        /// defaults to the object which fired the event.</strong></p>
        /// </div></li><li><span>delay</span> : <see cref="Number">Number</see><div><p>The number of milliseconds to delay the invocation of the handler after the event fires.</p>
        /// </div></li><li><span>single</span> : <see cref="bool">Boolean</see><div><p>True to add a handler to handle just the next firing of the event, and then remove itself.</p>
        /// </div></li><li><span>buffer</span> : <see cref="Number">Number</see><div><p>Causes the handler to be scheduled to run in an <see cref="Ext.util.DelayedTask">Ext.util.DelayedTask</see> delayed
        /// by the specified number of milliseconds. If the event fires again within that time,
        /// the original handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p>
        /// </div></li><li><span>target</span> : <see cref="Ext.util.Observable">Ext.util.Observable</see><div><p>Only call the handler if the event was fired on the target Observable, <em>not</em> if the event
        /// was bubbled up from a child Observable.</p>
        /// </div></li><li><span>element</span> : <see cref="String">String</see><div><p><strong>This option is only valid for listeners bound to <see cref="Ext.Component">Components</see>.</strong>
        /// The name of a Component property which references an element to add a listener to.</p>
        /// <p>  This option is useful during Component construction to add DOM event listeners to elements of
        /// <see cref="Ext.Component">Components</see> which will exist only after the Component is rendered.
        /// For example, to add a click listener to a Panel's body:</p>
        /// <pre><code>  new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'The title',
        /// listeners: {
        /// click: this.handlePanelClick,
        /// element: 'body'
        /// }
        /// });
        /// </code></pre>
        /// <p><strong>Combining Options</strong></p>
        /// <p>Using the options argument, it is possible to combine different types of listeners:</p>
        /// <p>A delayed, one-time listener.</p>
        /// <pre><code>myPanel.on('hide', this.handleClick, this, {
        /// single: true,
        /// delay: 100
        /// });
        /// </code></pre>
        /// </div></li></ul></param>
        public virtual void on(object eventName, System.Delegate fn=null, object scope=null, object options=null){}
        /// <summary>
        /// This complex-looking method takes a given Model instance and returns an object containing all data from
        /// all of that Model's loaded associations. See getAssociatedData
        /// </summary>
        /// <param name="seenKeys"><p>A hash of all the associations we've already seen</p>
        /// </param>
        /// <param name="depth"><p>The current depth</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The nested data set for the Model's loaded associations</p>
        /// </div>
        /// </returns>
        private object prepareAssociatedData(object seenKeys, JsNumber depth){return null;}
        /// <summary>
        /// Prepares a given class for observable instances. This method is called when a
        /// class derives from this class or uses this class as a mixin.
        /// </summary>
        /// <param name="T"><p>The class constructor to prepare.</p>
        /// </param>
        public virtual void prepareClass(System.Delegate T){}
        /// <summary>
        /// Usually called by the Ext.data.Store to which this model instance has been joined. Rejects
        /// all changes made to the model instance since either creation, or the last commit operation. Modified fields are
        /// reverted to their original values.
        /// Developers should subscribe to the <see cref="Ext.data.StoreEvents.update">Ext.data.Store.update</see> event to have their code notified of reject
        /// operations.
        /// </summary>
        /// <param name="silent"><p>True to skip notification of the owning store of the change.
        /// Defaults to false.</p>
        /// </param>
        public void reject(object silent=null){}
        /// <summary>
        /// Relays selected events from the specified Observable as if the events were fired by this.
        /// For example if you are extending Grid, you might decide to forward some events from store.
        /// So you can do this inside your initComponent:
        /// <code>this.relayEvents(this.getStore(), ['load']);
        /// </code>
        /// The grid instance will then have an observable 'load' event which will be passed the
        /// parameters of the store's load event and any function fired with the grid's load event
        /// would have access to the grid using the <c>this</c> keyword.
        /// </summary>
        /// <param name="origin"><p>The Observable whose events this object is to relay.</p>
        /// </param>
        /// <param name="events"><p>Array of event names to relay.</p>
        /// </param>
        /// <param name="prefix"><p>A common prefix to prepend to the event names. For example:</p>
        /// <pre><code>this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
        /// </code></pre>
        /// <p>Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.</p>
        /// </param>
        public virtual void relayEvents(object origin, JsArray<String> events, object prefix=null){}
        /// <summary>
        /// Removes an event handler.
        /// </summary>
        /// <param name="eventName"><p>The type of event the handler was associated with.</p>
        /// </param>
        /// <param name="fn"><p>The handler to remove. <strong>This must be a reference to the function passed into the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> call.</strong></p>
        /// </param>
        /// <param name="scope"><p>The scope originally specified for the handler. It must be the same as the
        /// scope argument specified in the original call to <see cref="Ext.util.Observable.addListener">addListener</see> or the listener will not be removed.</p>
        /// </param>
        public virtual void removeListener(JsString eventName, System.Delegate fn, object scope=null){}
        /// <summary>
        /// Removes listeners that were added by the mon method.
        /// </summary>
        /// <param name="item"><p>The item from which to remove a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        public virtual void removeManagedListener(object item, object ename, System.Delegate fn=null, object scope=null){}
        /// <summary>
        /// Remove a single managed listener item
        /// </summary>
        /// <param name="isClear"><p>True if this is being called during a clear</p>
        /// </param>
        /// <param name="managedListener"><p>The managed listener item
        /// See removeManagedListener for other args</p>
        /// </param>
        public virtual void removeManagedListenerItem(bool isClear, object managedListener){}
        /// <summary>
        /// Resumes firing events (see suspendEvents).
        /// If events were suspended using the <c>queueSuspended</c> parameter, then all events fired
        /// during event suspension will be sent to any listeners now.
        /// </summary>
        public virtual void resumeEvents(){}
        /// <summary>
        /// Saves the model instance using the configured proxy.
        /// </summary>
        /// <param name="options"><p>Options to pass to the proxy. Config object for <see cref="Ext.data.Operation">Ext.data.Operation</see>.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.Model">Ext.data.Model</see></span><div><p>The Model instance</p>
        /// </div>
        /// </returns>
        public Ext.data.Model save(object options){return null;}
        /// <summary>
        /// Sets the given field to the given value, marks the instance as dirty
        /// </summary>
        /// <param name="fieldName"><p>The field to set, or an object containing key/value pairs</p>
        /// </param>
        /// <param name="newValue"><p>The value to set</p>
        /// </param>
        /// <returns>
        /// <span><see cref="String">String</see>[]</span><div><p>The array of modified field names or null if nothing was modified.</p>
        /// </div>
        /// </returns>
        public JsString[] set(object fieldName, object newValue){return null;}
        /// <summary>
        /// Marks this Record as dirty. This method is used interally when adding phantom records
        /// to a writer enabled store.
        /// Marking a record <c><see cref="Ext.data.Model.dirty">dirty</see></c> causes the phantom to be returned by <see cref="Ext.data.Store.getUpdatedRecords">Ext.data.Store.getUpdatedRecords</see>
        /// where it will have a create action composed for it during <see cref="Ext.data.Model.save">model save</see> operations.
        /// </summary>
        public void setDirty(){}
        /// <summary>
        /// Sets the model instance's id field to the given id.
        /// </summary>
        /// <param name="id"><p>The new id</p>
        /// </param>
        public void setId(object id){}
        /// <summary>
        /// Sets the Proxy to use for this model. Accepts any options that can be accepted by
        /// Ext.createByAlias.
        /// </summary>
        /// <param name="proxy"><p>The proxy</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.data.proxy.Proxy">Ext.data.proxy.Proxy</see></span><div>
        /// </div>
        /// </returns>
        public Ext.data.proxy.Proxy setProxy(object proxy){return null;}
        /// <summary>
        /// Suspends the firing of all events. (see resumeEvents)
        /// </summary>
        /// <param name="queueSuspended"><p>Pass as true to queue up suspended events to be fired
        /// after the <see cref="Ext.util.Observable.resumeEvents">resumeEvents</see> call instead of discarding all suspended events.</p>
        /// </param>
        public virtual void suspendEvents(bool queueSuspended){}
        /// <summary>
        /// Shorthand for removeListener.
        /// Removes an event handler.
        /// </summary>
        /// <param name="eventName"><p>The type of event the handler was associated with.</p>
        /// </param>
        /// <param name="fn"><p>The handler to remove. <strong>This must be a reference to the function passed into the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> call.</strong></p>
        /// </param>
        /// <param name="scope"><p>The scope originally specified for the handler. It must be the same as the
        /// scope argument specified in the original call to <see cref="Ext.util.Observable.addListener">addListener</see> or the listener will not be removed.</p>
        /// </param>
        public virtual void un(JsString eventName, System.Delegate fn, object scope=null){}
        /// <summary>
        /// Tells this model instance that it has been removed from the store.
        /// </summary>
        /// <param name="store"><p>The store from which this model has been removed.</p>
        /// </param>
        public void unjoin(Ext.data.Store store){}
        /// <summary>
        /// Validates the current data against all of its configured validations.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.data.Errors">Ext.data.Errors</see></span><div><p>The errors object</p>
        /// </div>
        /// </returns>
        public Errors validate(){return null;}
        /// <summary>
        /// Defaults to: <c>1</c>
        /// </summary>
        private static JsNumber AUTO_ID{get;set;}
        /// <summary>
        /// The update operation of type 'commit'. Used by Store.update event.
        /// Defaults to: <c>&quot;commit&quot;</c>
        /// </summary>
        public static JsString COMMIT{get;set;}
        /// <summary>
        /// The update operation of type 'edit'. Used by Store.update event.
        /// Defaults to: <c>&quot;edit&quot;</c>
        /// </summary>
        public static JsString EDIT{get;set;}
        /// <summary>
        /// Defaults to: <c>&quot;ext-record&quot;</c>
        /// </summary>
        private static JsString PREFIX{get;set;}
        /// <summary>
        /// The update operation of type 'reject'. Used by Store.update event.
        /// Defaults to: <c>&quot;reject&quot;</c>
        /// </summary>
        public static JsString REJECT{get;set;}
        /// <summary>
        /// Generates a sequential id. This method is typically called when a record is created and no id has been specified. The id will automatically be assigned to the
        /// record. The returned id takes the form: {PREFIX}-{AUTO_ID}.
        /// <li><strong>PREFIX</strong> : String - Ext.data.Model.PREFIX (defaults to 'ext-record')</li>
        /// <li><strong>AUTO_ID</strong> : String - <see cref="Ext.data.Model">Ext.data.Model</see>.AUTO_ID (defaults to 1 initially)</li>
        /// </summary>
        /// <param name="rec"><p>The record being created. The record does not exist, it's a <see cref="Ext.data.Model.phantom">phantom</see>.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="String">String</see></span><div><p>auto-generated string id, <c>"ext-record-i++"</c>;</p>
        /// </div>
        /// </returns>
        public static JsString id(Ext.data.Model rec){return null;}
        /// <summary>
        /// Asynchronously loads a model instance by id. Sample usage:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.User', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// fields: [
        /// {name: 'id', type: 'int'},
        /// {name: 'name', type: 'string'}
        /// ]
        /// });
        /// MyApp.User.load(10, {
        /// scope: this,
        /// failure: function(record, operation) {
        /// //do something if the load failed
        /// },
        /// success: function(record, operation) {
        /// //do something if the load succeeded
        /// },
        /// callback: function(record, operation) {
        /// //do something whether the load succeeded or failed
        /// }
        /// });
        /// </code>
        /// </summary>
        /// <param name="id"><p>The id of the model to load</p>
        /// </param>
        /// <param name="config"><p>config object containing success, failure and callback functions, plus
        /// optional scope</p>
        /// </param>
        public static void load(object id, object config=null){}
        /// <summary>
        /// Apply a new set of field and/or property definitions to the existing model. This will replace any existing
        /// fields, including fields inherited from superclasses. Mainly for reconfiguring the
        /// model based on changes in meta data (called from Reader's onMetaChange method).
        /// </summary>
        /// <param name="fields">
        /// </param>
        /// <param name="idProperty">
        /// </param>
        /// <param name="clientIdProperty">
        /// </param>
        public static void setFields(object fields, object idProperty, object clientIdProperty){}
        public Model(Ext.data.ModelConfig config){}
        public Model(){}
        public Model(params object[] args){}
    }
    #endregion
    #region ModelConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ModelConfig : Ext.BaseConfig
    {
        /// <summary>
        /// An array of associations for this model.
        /// </summary>
        public JsObject associations;
        /// <summary>
        /// One or more BelongsTo associations for this model.
        /// </summary>
        public object belongsTo;
        /// <summary>
        /// The name of a property that is used for submitting this Model's unique client-side identifier
        /// to the server when multiple phantom records are saved as part of the same Operation.
        /// In such a case, the server response should include the client id for each record
        /// so that the server response data can be used to update the client-side records if necessary.
        /// This property cannot have the same name as any of this Model's fields.
        /// Defaults to: <c>null</c>
        /// </summary>
        public JsString clientIdProperty;
        /// <summary>
        /// The string type of the default Model Proxy. Defaults to 'ajax'.
        /// Defaults to: <c>&quot;ajax&quot;</c>
        /// </summary>
        public JsString defaultProxyType;
        /// <summary>
        /// The fields for this model. This is an Array of Field definition objects. A Field
        /// definition may simply be the name of the Field, but a Field encapsulates data type,
        /// custom conversion of raw data, and a mapping
        /// property to specify by name of index, how to extract a field's value from a raw data object, so it is best practice
        /// to specify a full set of Field config objects.
        /// </summary>
        public object fields;
        /// <summary>
        /// One or more HasMany associations for this model.
        /// </summary>
        public object hasMany;
        /// <summary>
        /// The name of the field treated as this Model's unique id. Defaults to 'id'.
        /// Defaults to: <c>&quot;id&quot;</c>
        /// </summary>
        public JsString idProperty;
        /// <summary>
        /// The id generator to use for this model. The default id generator does not generate
        /// values for the idProperty.
        /// This can be overridden at the model level to provide a custom generator for a model.
        /// The simplest form of this would be:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModel', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// requires: ['<see cref="Ext.data.SequentialIdGenerator">Ext.data.SequentialIdGenerator</see>'],
        /// idgen: 'sequential',
        /// ...
        /// });
        /// </code>
        /// The above would generate <see cref="Ext.data.SequentialIdGenerator">sequential</see> id's such
        /// as 1, 2, 3 etc..
        /// Another useful id generator is <see cref="Ext.data.UuidGenerator">Ext.data.UuidGenerator</see>:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModel', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// requires: ['<see cref="Ext.data.UuidGenerator">Ext.data.UuidGenerator</see>'],
        /// idgen: 'uuid',
        /// ...
        /// });
        /// </code>
        /// An id generation can also be further configured:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModel', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// idgen: {
        /// type: 'sequential',
        /// seed: 1000,
        /// prefix: 'ID_'
        /// }
        /// });
        /// </code>
        /// The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
        /// If multiple models share an id space, a single generator can be shared:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModelX', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// idgen: {
        /// type: 'sequential',
        /// id: 'xy'
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.data.MyModelY', {
        /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
        /// idgen: {
        /// type: 'sequential',
        /// id: 'xy'
        /// }
        /// });
        /// </code>
        /// For more complex, shared id generators, a custom generator is the best approach.
        /// See <see cref="Ext.data.IdGenerator">Ext.data.IdGenerator</see> for details on creating custom id generators.
        /// </summary>
        public object idgen;
        /// <summary>
        /// A config object containing one or more event handlers to be added to this object during initialization. This
        /// should be a valid listeners config object as specified in the addListener example for attaching multiple
        /// handlers at once.
        /// <strong>DOM events from Ext JS <see cref="Ext.Component">Components</see></strong>
        /// While <em>some</em> Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
        /// only done when extra value can be added. For example the <see cref="Ext.view.View">DataView</see>'s <strong><c><see cref="Ext.view.ViewEvents.itemclick">itemclick</see></c></strong> event passing the node clicked on. To access DOM events directly from a
        /// child element of a Component, we need to specify the <c>element</c> option to identify the Component property to add a
        /// DOM listener to:
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// width: 400,
        /// height: 200,
        /// dockedItems: [{
        /// xtype: 'toolbar'
        /// }],
        /// listeners: {
        /// click: {
        /// element: 'el', //bind to the underlying el property on the panel
        /// fn: function(){ console.log('click el'); }
        /// },
        /// dblclick: {
        /// element: 'body', //bind to the underlying body property on the panel
        /// fn: function(){ console.log('dblclick body'); }
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsObject listeners;
        /// <summary>
        /// The name of the property on this Persistable object that its data is saved to. Defaults to 'data'
        /// (i.e: all persistable data resides in this.data.)
        /// Defaults to: <c>&quot;data&quot;</c>
        /// </summary>
        public JsString persistenceProperty;
        /// <summary>
        /// The proxy to use for this model.
        /// </summary>
        public object proxy;
        /// <summary>
        /// An array of validations for this model.
        /// </summary>
        public JsObject validations;
        public ModelConfig(params object[] args){}
    }
    #endregion
    #region ModelEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ModelEvents : Ext.BaseEvents
    {
        /// <summary>
        /// Fired when this model's id changes
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="oldId"><p>The old id</p>
        /// </param>
        /// <param name="newId"><p>The new id</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void idchanged(Ext.data.Model @this, object oldId, object newId, object eOpts){}
        public ModelEvents(params object[] args){}
    }
    #endregion
}
