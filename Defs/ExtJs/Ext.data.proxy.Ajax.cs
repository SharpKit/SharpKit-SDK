//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.data.proxy
{
    #region Ajax
    /// <inheritdocs />
    /// <summary>
    /// <p>AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
    /// data from the server, usually to be placed into a <see cref="Ext.data.Store">Store</see>. Let's take a look at a typical setup.
    /// Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a <see cref="Ext.data.Model">Model</see>:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id', 'name', 'email']
    /// });
    /// //The Store contains the AjaxProxy as an inline configuration
    /// var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// proxy: {
    /// type: 'ajax',
    /// url : 'users.json'
    /// }
    /// });
    /// store.load();
    /// </code></pre>
    /// <p>Our example is going to load user data into a Store, so we start off by defining a <see cref="Ext.data.Model">Model</see> with
    /// the fields that we expect the server to return. Next we set up the Store itself, along with a
    /// <see cref="Ext.data.StoreConfig.proxy">proxy</see> configuration. This configuration was automatically turned into an
    /// <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see> instance, with the url we specified being passed into AjaxProxy's constructor.
    /// It's as if we'd done this:</p>
    /// <pre><code>new <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see>({
    /// url: 'users.json',
    /// model: 'User',
    /// reader: 'json'
    /// });
    /// </code></pre>
    /// <p>A couple of extra configurations appeared here - <see cref="Ext.data.proxy.AjaxConfig.model">model</see> and <see cref="Ext.data.proxy.AjaxConfig.reader">reader</see>. These are set by default when we
    /// create the proxy via the Store - the Store already knows about the Model, and Proxy's default <see cref="Ext.data.reader.Reader">Reader</see> is <see cref="Ext.data.reader.Json">JsonReader</see>.</p>
    /// <p>Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
    /// ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
    /// <see cref="Ext.data.proxy.Ajax.actionMethods">actionMethods</see> to customize this - by default any kind of read will be sent as a GET request and any kind of write
    /// will be sent as a POST request).</p>
    /// <h1>Limitations</h1>
    /// <p>AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
    /// cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
    /// talking to each other via AJAX.</p>
    /// <p>If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
    /// domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
    /// from http://domainA.com), you can use <see cref="Ext.data.proxy.JsonP">Ext.data.proxy.JsonP</see> and a technique known as JSON-P (JSON with
    /// Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
    /// JSON-P responses. See <see cref="Ext.data.proxy.JsonP">JsonPProxy</see>'s introduction docs for more details.</p>
    /// <h1>Readers and Writers</h1>
    /// <p>AjaxProxy can be configured to use any type of <see cref="Ext.data.reader.Reader">Reader</see> to decode the server's response.
    /// If no Reader is supplied, AjaxProxy will default to using a <see cref="Ext.data.reader.Json">JsonReader</see>. Reader
    /// configuration can be passed in as a simple object, which the Proxy automatically turns into a <see cref="Ext.data.reader.Reader">Reader</see> instance:</p>
    /// <pre><code>var proxy = new <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see>({
    /// model: 'User',
    /// reader: {
    /// type: 'xml',
    /// root: 'users'
    /// }
    /// });
    /// proxy.getReader(); //returns an <see cref="Ext.data.reader.Xml">XmlReader</see> instance based on the config we supplied
    /// </code></pre>
    /// <h1>Url generation</h1>
    /// <p>AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
    /// each request. These are controlled with the following configuration options:</p>
    /// <ul>
    /// <li><see cref="Ext.data.proxy.AjaxConfig.pageParam">pageParam</see> - controls how the page number is sent to the server (see also <see cref="Ext.data.proxy.AjaxConfig.startParam">startParam</see> and <see cref="Ext.data.proxy.AjaxConfig.limitParam">limitParam</see>)</li>
    /// <li><see cref="Ext.data.proxy.AjaxConfig.sortParam">sortParam</see> - controls how sort information is sent to the server</li>
    /// <li><see cref="Ext.data.proxy.AjaxConfig.groupParam">groupParam</see> - controls how grouping information is sent to the server</li>
    /// <li><see cref="Ext.data.proxy.AjaxConfig.filterParam">filterParam</see> - controls how filter information is sent to the server</li>
    /// </ul>
    /// <p>Each request sent by AjaxProxy is described by an <see cref="Ext.data.Operation">Operation</see>. To see how we can customize
    /// the generated urls, let's say we're loading the Proxy with the following Operation:</p>
    /// <pre><code>var operation = new <see cref="Ext.data.Operation">Ext.data.Operation</see>({
    /// action: 'read',
    /// page  : 2
    /// });
    /// </code></pre>
    /// <p>Now we'll issue the request for this Operation by calling <see cref="Ext.data.proxy.Ajax.read">read</see>:</p>
    /// <pre><code>var proxy = new <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see>({
    /// url: '/users'
    /// });
    /// proxy.read(operation); //GET /users?page=2
    /// </code></pre>
    /// <p>Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
    /// to the server:</p>
    /// <pre><code>var proxy = new <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see>({
    /// url: '/users',
    /// pageParam: 'pageNumber'
    /// });
    /// proxy.read(operation); //GET /users?pageNumber=2
    /// </code></pre>
    /// <p>Alternatively, our Operation could have been configured to send start and limit parameters instead of page:</p>
    /// <pre><code>var operation = new <see cref="Ext.data.Operation">Ext.data.Operation</see>({
    /// action: 'read',
    /// start : 50,
    /// limit : 25
    /// });
    /// var proxy = new <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see>({
    /// url: '/users'
    /// });
    /// proxy.read(operation); //GET /users?start=50&amp;limit;=25
    /// </code></pre>
    /// <p>Again we can customize this url:</p>
    /// <pre><code>var proxy = new <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see>({
    /// url: '/users',
    /// startParam: 'startIndex',
    /// limitParam: 'limitIndex'
    /// });
    /// proxy.read(operation); //GET /users?startIndex=50&amp;limitIndex;=25
    /// </code></pre>
    /// <p>AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
    /// expressive Operation object:</p>
    /// <pre><code>var operation = new <see cref="Ext.data.Operation">Ext.data.Operation</see>({
    /// action: 'read',
    /// sorters: [
    /// new <see cref="Ext.util.Sorter">Ext.util.Sorter</see>({
    /// property : 'name',
    /// direction: 'ASC'
    /// }),
    /// new <see cref="Ext.util.Sorter">Ext.util.Sorter</see>({
    /// property : 'age',
    /// direction: 'DESC'
    /// })
    /// ],
    /// filters: [
    /// new <see cref="Ext.util.Filter">Ext.util.Filter</see>({
    /// property: 'eyeColor',
    /// value   : 'brown'
    /// })
    /// ]
    /// });
    /// </code></pre>
    /// <p>This is the type of object that is generated internally when loading a <see cref="Ext.data.Store">Store</see> with sorters and
    /// filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
    /// (note that the url is escaped before sending the request, but is left unescaped here for clarity):</p>
    /// <pre><code>var proxy = new <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see>({
    /// url: '/users'
    /// });
    /// proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&amp;filter;=[{"property":"eyeColor","value":"brown"}]
    /// </code></pre>
    /// <p>We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
    /// to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
    /// that format like this:</p>
    /// <pre><code> var proxy = new <see cref="Ext.data.proxy.Ajax">Ext.data.proxy.Ajax</see>({
    /// url: '/users',
    /// sortParam: 'sortBy',
    /// filterParam: 'filterBy',
    /// //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
    /// encodeSorters: function(sorters) {
    /// var length   = sorters.length,
    /// sortStrs = [],
    /// sorter, i;
    /// for (i = 0; i &lt; length; i++) {
    /// sorter = sorters[i];
    /// sortStrs[i] = sorter.property + '#' + sorter.direction
    /// }
    /// return sortStrs.join(",");
    /// }
    /// });
    /// proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&amp;filterBy;=[{"property":"eyeColor","value":"brown"}]
    /// </code></pre>
    /// <p>We can also provide a custom <see cref="Ext.data.proxy.Ajax.encodeFilters">encodeFilters</see> function to encode our filters.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Ajax : Server
    {
        /// <summary>
        /// Any headers to add to the Ajax request. Defaults to undefined.
        /// </summary>
        public JsObject headers;
        /// <summary>
        /// Mapping of action name to HTTP request method. In the basic AjaxProxy these are set to 'GET' for 'read' actions
        /// and 'POST' for 'create', 'update' and 'destroy' actions. The Ext.data.proxy.Rest maps these to the
        /// correct RESTful methods.
        /// Defaults to: <c>{create: &quot;POST&quot;, read: &quot;GET&quot;, update: &quot;POST&quot;, destroy: &quot;POST&quot;}</c>
        /// </summary>
        public JsObject actionMethods{get;set;}
        /// <summary>
        /// TODO: This is currently identical to the JsonPProxy version except for the return function's signature. There is a lot
        /// of code duplication inside the returned function so we need to find a way to DRY this up.
        /// </summary>
        /// <param name="request"><p>The Request object</p>
        /// </param>
        /// <param name="operation"><p>The Operation being executed</p>
        /// </param>
        /// <param name="callback"><p>The callback function to be called when the request completes. This is usually the callback
        /// passed to doRequest</p>
        /// </param>
        /// <param name="scope"><p>The scope in which to execute the callback function</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Function">Function</see></span><div><p>The callback function</p>
        /// </div>
        /// </returns>
        private System.Delegate createRequestCallback(Request request, Operation operation, System.Delegate callback, object scope){return null;}
        /// <summary>
        /// Returns the HTTP method name for a given request. By default this returns based on a lookup on
        /// actionMethods.
        /// </summary>
        /// <param name="request"><p>The request object</p>
        /// </param>
        /// <returns>
        /// <span><see cref="String">String</see></span><div><p>The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')</p>
        /// </div>
        /// </returns>
        public JsString getMethod(Request request){return null;}
        public Ajax(Ext.data.proxy.AjaxConfig config){}
        public Ajax(params object[] args){}
    }
    #endregion
    #region AjaxConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class AjaxConfig : ServerConfig
    {
        /// <summary>
        /// Any headers to add to the Ajax request. Defaults to undefined.
        /// </summary>
        public JsObject headers;
        public AjaxConfig(params object[] args){}
    }
    #endregion
    #region AjaxEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class AjaxEvents : ServerEvents
    {
        public AjaxEvents(params object[] args){}
    }
    #endregion
}
