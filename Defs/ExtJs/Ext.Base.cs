//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext
{
    #region Base
    /// <inheritdocs />
    /// <summary>
    /// <p>The root of all classes created with <see cref="Ext.ExtContext.define">Ext.define</see>.</p>
    /// <p><see cref="Ext.Base">Ext.Base</see> is the building block of all Ext classes. All classes in Ext inherit from <see cref="Ext.Base">Ext.Base</see>.
    /// All prototype and static members of this class are inherited by all other classes.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Base : JsContext
    {
        /// <summary>
        /// Defaults to: <c>&quot;Ext.Base&quot;</c>
        /// </summary>
        [JsProperty(Name="$className")]
        public JsString @className{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        public JsObject configMap{get;set;}
        /// <summary>
        /// Defaults to: <c>[]</c>
        /// </summary>
        public JsArray initConfigList{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        public JsObject initConfigMap{get;set;}
        /// <summary>
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool isInstance{get;set;}
        /// <summary>
        /// Get the reference to the current class from which this object was instantiated. Unlike statics,
        /// this.self is scope-dependent and it's meant to be used for dynamic inheritance. See statics
        /// for a detailed comparison
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// statics: {
        /// speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        /// },
        /// constructor: function() {
        /// alert(this.self.speciesName); // dependent on 'this'
        /// },
        /// clone: function() {
        /// return new this.self();
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.SnowLeopard', {
        /// extend: 'My.Cat',
        /// statics: {
        /// speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
        /// }
        /// });
        /// var cat = new My.Cat();                     // alerts 'Cat'
        /// var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
        /// var clone = snowLeopard.clone();
        /// alert(<see cref="Ext.ExtContext.getClassName">Ext.getClassName</see>(clone));             // alerts 'My.SnowLeopard'
        /// </code>
        /// </summary>
        public Class self{get;set;}
        /// <summary>
        /// Call the original method that was previously overridden with override
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// constructor: function() {
        /// alert("I'm a cat!");
        /// }
        /// });
        /// My.Cat.override({
        /// constructor: function() {
        /// alert("I'm going to be a cat!");
        /// this.callOverridden();
        /// alert("Meeeeoooowwww");
        /// }
        /// });
        /// var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
        /// // alerts "I'm a cat!"
        /// // alerts "Meeeeoooowwww"
        /// </code>
        /// <p>This method has been <strong>deprecated</strong> </p>
        /// <p>as of 4.1. Use <see cref="Ext.Base.callParent">callParent</see> instead.</p>
        /// </summary>
        /// <param name="args"><p>The arguments, either an array or the <c>arguments</c> object
        /// from the current method, for example: <c>this.callOverridden(arguments)</c></p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>Returns the result of calling the overridden method</p>
        /// </div>
        /// </returns>
        public object callOverridden(object args=null){return null;}
        /// <summary>
        /// Call the "parent" method of the current method. That is the method previously
        /// overridden by derivation or by an override (see Ext.define).
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Base', {
        /// constructor: function (x) {
        /// this.x = x;
        /// },
        /// statics: {
        /// method: function (x) {
        /// return x;
        /// }
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived', {
        /// extend: 'My.Base',
        /// constructor: function () {
        /// this.callParent([21]);
        /// }
        /// });
        /// var obj = new My.Derived();
        /// alert(obj.x);  // alerts 21
        /// </code>
        /// This can be used with an override as follows:
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.DerivedOverride', {
        /// override: 'My.Derived',
        /// constructor: function (x) {
        /// this.callParent([x*2]); // calls original My.Derived constructor
        /// }
        /// });
        /// var obj = new My.Derived();
        /// alert(obj.x);  // now alerts 42
        /// </code>
        /// This also works with static methods.
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived2', {
        /// extend: 'My.Base',
        /// statics: {
        /// method: function (x) {
        /// return this.callParent([x*2]); // calls My.Base.method
        /// }
        /// }
        /// });
        /// alert(My.Base.method(10);     // alerts 10
        /// alert(My.Derived2.method(10); // alerts 20
        /// </code>
        /// Lastly, it also works with overridden static methods.
        /// <code> <see cref="Ext.ExtContext.define">Ext.define</see>('My.Derived2Override', {
        /// override: 'My.Derived2',
        /// statics: {
        /// method: function (x) {
        /// return this.callParent([x*2]); // calls My.Derived2.method
        /// }
        /// }
        /// });
        /// alert(My.Derived2.method(10); // now alerts 40
        /// </code>
        /// </summary>
        /// <param name="args"><p>The arguments, either an array or the <c>arguments</c> object
        /// from the current method, for example: <c>this.callParent(arguments)</c></p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>Returns the result of calling the parent method</p>
        /// </div>
        /// </returns>
        public object callParent(object args=null){return null;}
        /// <summary>
        /// </summary>
        private void configClass(){}
        /// <summary>
        /// Overrides: <see cref="Ext.AbstractComponent.destroy">Ext.AbstractComponent.destroy</see>, <see cref="Ext.AbstractPlugin.destroy">Ext.AbstractPlugin.destroy</see>, <see cref="Ext.layout.Layout.destroy">Ext.layout.Layout.destroy</see>
        /// </summary>
        public void destroy(){}
        /// <summary>
        /// Parameters<li><span>name</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="name">
        /// </param>
        private void getConfig(object name){}
        /// <summary>
        /// Returns the initial configuration passed to constructor when instantiating
        /// this class.
        /// </summary>
        /// <param name="name"><p>Name of the config option to return.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see>/Mixed</span><div><p>The full config object or a single config value
        /// when <c>name</c> parameter specified.</p>
        /// </div>
        /// </returns>
        public object getInitialConfig(object name=null){return null;}
        /// <summary>
        /// Parameters<li><span>config</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="config">
        /// </param>
        private void hasConfig(object config){}
        /// <summary>
        /// Initialize configuration for this class. a typical example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.awesome.Class', {
        /// // The default config
        /// config: {
        /// name: 'Awesome',
        /// isAwesome: true
        /// },
        /// constructor: function(config) {
        /// this.initConfig(config);
        /// }
        /// });
        /// var awesome = new My.awesome.Class({
        /// name: 'Super Awesome'
        /// });
        /// alert(awesome.getName()); // 'Super Awesome'
        /// </code>
        /// </summary>
        /// <param name="config">
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Base">Ext.Base</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        protected Ext.Base initConfig(object config){return null;}
        /// <summary>
        /// Parameters<li><span>names</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>callback</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>scope</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="names">
        /// </param>
        /// <param name="callback">
        /// </param>
        /// <param name="scope">
        /// </param>
        private void onConfigUpdate(object names, object callback, object scope){}
        /// <summary>
        /// Parameters<li><span>config</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>applyIfNotSet</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="config">
        /// </param>
        /// <param name="applyIfNotSet">
        /// </param>
        private void setConfig(object config, object applyIfNotSet){}
        /// <summary>
        /// Get the reference to the class from which this object was instantiated. Note that unlike self,
        /// this.statics() is scope-independent and it always returns the class from which it was called, regardless of what
        /// this points to during run-time
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// statics: {
        /// totalCreated: 0,
        /// speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        /// },
        /// constructor: function() {
        /// var statics = this.statics();
        /// alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
        /// // equivalent to: My.Cat.speciesName
        /// alert(this.self.speciesName);   // dependent on 'this'
        /// statics.totalCreated++;
        /// },
        /// clone: function() {
        /// var cloned = new this.self;                      // dependent on 'this'
        /// cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
        /// return cloned;
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.SnowLeopard', {
        /// extend: 'My.Cat',
        /// statics: {
        /// speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
        /// },
        /// constructor: function() {
        /// this.callParent();
        /// }
        /// });
        /// var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
        /// var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
        /// var clone = snowLeopard.clone();
        /// alert(<see cref="Ext.ExtContext.getClassName">Ext.getClassName</see>(clone));         // alerts 'My.SnowLeopard'
        /// alert(clone.groupName);                 // alerts 'Cat'
        /// alert(My.Cat.totalCreated);             // alerts 3
        /// </code>
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.Class">Ext.Class</see></span><div>
        /// </div>
        /// </returns>
        protected Class statics(){return null;}
        /// <summary>
        /// Defaults to: <c>[]</c>
        /// </summary>
        [JsProperty(Name="$onExtended")]
        private static JsArray @onExtended{get;set;}
        /// <summary>
        /// Parameters<li><span>config</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="config">
        /// </param>
        private static void addConfig(object config){}
        /// <summary>
        /// Parameters<li><span>members</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="members">
        /// </param>
        private static void addInheritableStatics(object members){}
        /// <summary>
        /// Parameters<li><span>name</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>member</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="name">
        /// </param>
        /// <param name="member">
        /// </param>
        private static void addMember(object name, object member){}
        /// <summary>
        /// Add methods / properties to the prototype of this class.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.awesome.Cat', {
        /// constructor: function() {
        /// ...
        /// }
        /// });
        /// My.awesome.Cat.addMembers({
        /// meow: function() {
        /// alert('Meowww...');
        /// }
        /// });
        /// var kitty = new My.awesome.Cat;
        /// kitty.meow();
        /// </code>
        /// </summary>
        /// <param name="members">
        /// </param>
        public static void addMembers(object members){}
        /// <summary>
        /// Add / override static properties of this class.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.cool.Class', {
        /// ...
        /// });
        /// My.cool.Class.addStatics({
        /// someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
        /// method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
        /// method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
        /// });
        /// </code>
        /// </summary>
        /// <param name="members">
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Base">Ext.Base</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public static Ext.Base addStatics(object members){return null;}
        /// <summary>
        /// Parameters<li><span>xtype</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="xtype">
        /// </param>
        private static void addXtype(object xtype){}
        /// <summary>
        /// Borrow another class' members to the prototype of this class.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Bank', {
        /// money: '$$$',
        /// printMoney: function() {
        /// alert('$$$$$$$');
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('Thief', {
        /// ...
        /// });
        /// Thief.borrow(Bank, ['money', 'printMoney']);
        /// var steve = new Thief();
        /// alert(steve.money); // alerts '$$$'
        /// steve.printMoney(); // alerts '$$$$$$$'
        /// </code>
        /// </summary>
        /// <param name="fromClass"><p>The class to borrow members from</p>
        /// </param>
        /// <param name="members"><p>The names of the members to borrow</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Base">Ext.Base</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        private static Ext.Base borrow(Ext.Base fromClass, object members){return null;}
        /// <summary>
        /// Create a new instance of this Class.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.cool.Class', {
        /// ...
        /// });
        /// My.cool.Class.create({
        /// someConfig: true
        /// });
        /// </code>
        /// All parameters are passed to the constructor of the class.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>the created instance.</p>
        /// </div>
        /// </returns>
        public object create(params object[] args){return null;}
        /// <summary>
        /// Create aliases for existing prototype methods. Example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.cool.Class', {
        /// method1: function() { ... },
        /// method2: function() { ... }
        /// });
        /// var test = new My.cool.Class();
        /// My.cool.Class.createAlias({
        /// method3: 'method1',
        /// method4: 'method2'
        /// });
        /// test.method3(); // test.method1()
        /// My.cool.Class.createAlias('method5', 'method3');
        /// test.method5(); // test.method3() -&gt; test.method1()
        /// </code>
        /// </summary>
        /// <param name="alias"><p>The new method name, or an object to set multiple aliases. See
        /// <see cref="Ext.Function.flexSetter">flexSetter</see></p>
        /// </param>
        /// <param name="origin"><p>The original method name</p>
        /// </param>
        public static void createAlias(object alias, object origin){}
        /// <summary>
        /// Parameters<li><span>config</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="config">
        /// </param>
        private static void extend(object config){}
        /// <summary>
        /// Get the current class' name in string format.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.cool.Class', {
        /// constructor: function() {
        /// alert(this.self.getName()); // alerts 'My.cool.Class'
        /// }
        /// });
        /// My.cool.Class.getName(); // 'My.cool.Class'
        /// </code>
        /// </summary>
        /// <returns>
        /// <span><see cref="String">String</see></span><div><p>className</p>
        /// </div>
        /// </returns>
        public static JsString getName(){return null;}
        /// <summary>
        /// Adds members to class.
        /// <p>This method has been <strong>deprecated</strong> since 4.1</p>
        /// <p>Use <see cref="Ext.Base.addMembers">addMembers</see> instead.</p>
        /// </summary>
        public void implement(params object[] args){}
        /// <summary>
        /// Used internally by the mixins pre-processor
        /// </summary>
        /// <param name="name">
        /// </param>
        /// <param name="mixinClass">
        /// </param>
        private static void mixin(object name, object mixinClass){}
        /// <summary>
        /// Override members of this class. Overridden methods can be invoked via
        /// callParent.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// constructor: function() {
        /// alert("I'm a cat!");
        /// }
        /// });
        /// My.Cat.override({
        /// constructor: function() {
        /// alert("I'm going to be a cat!");
        /// this.callParent(arguments);
        /// alert("Meeeeoooowwww");
        /// }
        /// });
        /// var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
        /// // alerts "I'm a cat!"
        /// // alerts "Meeeeoooowwww"
        /// </code>
        /// As of 4.1, direct use of this method is deprecated. Use <see cref="Ext.ExtContext.define">Ext.define</see>
        /// instead:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.CatOverride', {
        /// override: 'My.Cat',
        /// constructor: function() {
        /// alert("I'm going to be a cat!");
        /// this.callParent(arguments);
        /// alert("Meeeeoooowwww");
        /// }
        /// });
        /// </code>
        /// The above accomplishes the same result but can be managed by the <see cref="Ext.Loader">Ext.Loader</see>
        /// which can properly order the override and its target class and the build process
        /// can determine whether the override is needed based on the required state of the
        /// target class (My.Cat).
        /// <p>This method has been <strong>deprecated</strong> since 4.1.0</p>
        /// <p>Use <see cref="Ext.ExtContext.define">Ext.define</see> instead</p>
        /// </summary>
        /// <param name="members"><p>The properties to add to this class. This should be
        /// specified as an object literal containing one or more properties.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Base">Ext.Base</see></span><div><p>this class</p>
        /// </div>
        /// </returns>
        public static Ext.Base @override(object members){return null;}
        /// <summary>
        /// </summary>
        private static void triggerExtended(){}
        public Base(Ext.BaseConfig config){}
        public Base(){}
        public Base(params object[] args){}
    }
    #endregion
    #region BaseConfig
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class BaseConfig
    {
        public BaseConfig(params object[] args){}
    }
    #endregion
    #region BaseEvents
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class BaseEvents
    {
        public BaseEvents(params object[] args){}
    }
    #endregion
}
