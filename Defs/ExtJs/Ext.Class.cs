//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext
{
    #region Class
    /// <summary>
    /// <p>Handles class creation throughout the framework. This is a low level factory that is used by <see cref="Ext.ClassManager">Ext.ClassManager</see> and generally
    /// should not be used directly. If you choose to use <see cref="Ext.Class">Ext.Class</see> you will lose out on the namespace, aliasing and depency loading
    /// features made available by <see cref="Ext.ClassManager">Ext.ClassManager</see>. The only time you would use <see cref="Ext.Class">Ext.Class</see> directly is to create an anonymous class.</p>
    /// <p>If you wish to create a class you should use <see cref="Ext.ExtContext.define">Ext.define</see> which aliases
    /// <see cref="Ext.ClassManager.create">Ext.ClassManager.create</see> to enable namespacing and dynamic dependency resolution.</p>
    /// <p><see cref="Ext.Class">Ext.Class</see> is the factory and <strong>not</strong> the superclass of everything. For the base class that <strong>all</strong> Ext classes inherit
    /// from, see <see cref="Ext.Base">Ext.Base</see>.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Class
    {
        /// <summary>
        /// List of short aliases for class names.  Most useful for defining xtypes for widgets:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.CoolPanel', {
        /// extend: '<see cref="Ext.panel.Panel">Ext.panel.Panel</see>',
        /// alias: ['widget.coolpanel'],
        /// title: 'Yeah!'
        /// });
        /// // Using <see cref="Ext.ExtContext.create">Ext.create</see>
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('widget.coolpanel');
        /// // Using the shorthand for defining widgets by xtype
        /// <see cref="Ext.ExtContext.widget">Ext.widget</see>('panel', {
        /// items: [
        /// {xtype: 'coolpanel', html: 'Foo'},
        /// {xtype: 'coolpanel', html: 'Bar'}
        /// ]
        /// });
        /// </code>
        /// Besides "widget" for xtype there are alias namespaces like "feature" for ftype and "plugin" for ptype.
        /// </summary>
        public JsString alias;
        /// <summary>
        /// Defines alternate names for this class.  For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Developer', {
        /// alternateClassName: ['Coder', 'Hacker'],
        /// code: function(msg) {
        /// alert('Typing... ' + msg);
        /// }
        /// });
        /// var joe = <see cref="Ext.ExtContext.create">Ext.create</see>('Developer');
        /// joe.code('stackoverflow');
        /// var rms = <see cref="Ext.ExtContext.create">Ext.create</see>('Hacker');
        /// rms.code('hack hack');
        /// </code>
        /// </summary>
        public object alternateClassName;
        /// <summary>
        /// List of configuration options with their default values, for which automatically
        /// accessor methods are generated.  For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('SmartPhone', {
        /// config: {
        /// hasTouchScreen: false,
        /// operatingSystem: 'Other',
        /// price: 500
        /// },
        /// constructor: function(cfg) {
        /// this.initConfig(cfg);
        /// }
        /// });
        /// var iPhone = new SmartPhone({
        /// hasTouchScreen: true,
        /// operatingSystem: 'iOS'
        /// });
        /// iPhone.getPrice(); // 500;
        /// iPhone.getOperatingSystem(); // 'iOS'
        /// iPhone.getHasTouchScreen(); // true;
        /// </code>
        /// </summary>
        public JsObject config;
        /// <summary>
        /// The parent class that this class extends. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Person', {
        /// say: function(text) { alert(text); }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('Developer', {
        /// extend: 'Person',
        /// say: function(text) { this.callParent(["print "+text]); }
        /// });
        /// </code>
        /// </summary>
        public JsString extend;
        /// <summary>
        /// List of inheritable static methods for this class.
        /// Otherwise just like statics but subclasses inherit these methods.
        /// </summary>
        public JsObject inheritableStatics;
        /// <summary>
        /// List of classes to mix into this class. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('CanSing', {
        /// sing: function() {
        /// alert("I'm on the highway to hell...")
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('Musician', {
        /// mixins: ['CanSing']
        /// })
        /// </code>
        /// In this case the Musician class will get a <c>sing</c> method from CanSing mixin.
        /// But what if the Musician already has a <c>sing</c> method? Or you want to mix
        /// in two classes, both of which define <c>sing</c>?  In such a cases it's good
        /// to define mixins as an object, where you assign a name to each mixin:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Musician', {
        /// mixins: {
        /// canSing: 'CanSing'
        /// },
        /// sing: function() {
        /// // delegate singing operation to mixin
        /// this.mixins.canSing.sing.call(this);
        /// }
        /// })
        /// </code>
        /// In this case the <c>sing</c> method of Musician will overwrite the
        /// mixed in <c>sing</c> method. But you can access the original mixed in method
        /// through special <c>mixins</c> property.
        /// </summary>
        public object mixins;
        /// <summary>
        /// List of classes that have to be loaded before instantiating this class.
        /// For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Mother', {
        /// requires: ['Child'],
        /// giveBirth: function() {
        /// // we can be sure that child class is available.
        /// return new Child();
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsString requires;
        /// <summary>
        /// When set to true, the class will be instantiated as singleton.  For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Logger', {
        /// singleton: true,
        /// log: function(msg) {
        /// console.log(msg);
        /// }
        /// });
        /// Logger.log('Hello');
        /// </code>
        /// </summary>
        public bool singleton;
        /// <summary>
        /// List of static methods for this class. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Computer', {
        /// statics: {
        /// factory: function(brand) {
        /// // 'this' in static methods refer to the class itself
        /// return new this(brand);
        /// }
        /// },
        /// constructor: function() { ... }
        /// });
        /// var dellComputer = Computer.factory('Dell');
        /// </code>
        /// </summary>
        public JsObject statics;
        /// <summary>
        /// List of optional classes to load together with this class. These aren't neccessarily loaded before
        /// this class is created, but are guaranteed to be available before Ext.onReady listeners are
        /// invoked. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Mother', {
        /// uses: ['Child'],
        /// giveBirth: function() {
        /// // This code might, or might not work:
        /// // return new Child();
        /// // Instead use <see cref="Ext.ExtContext.create">Ext.create</see>() to load the class at the spot if not loaded already:
        /// return <see cref="Ext.ExtContext.create">Ext.create</see>('Child');
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsString uses;
        /// <summary>
        /// Defaults to: <c>[]</c>
        /// </summary>
        private JsArray defaultPreprocessors{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        private JsObject preprocessors{get;set;}
        /// <summary>
        /// Create a new anonymous class.
        /// </summary>
        /// <param name="data"><p>An object represent the properties of this class</p>
        /// </param>
        /// <param name="onCreated"><p>Optional, the callback function to be executed when this class is fully created.
        /// Note that the creation process can be asynchronous depending on the pre-processors used.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Base">Ext.Base</see></span><div><p>The newly created class</p>
        /// </div>
        /// </returns>
        public Class(object data, object onCreated=null){}
        /// <summary>
        /// Parameters<li><span>Class</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>classData</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>onClassCreated</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="Class">
        /// </param>
        /// <param name="classData">
        /// </param>
        /// <param name="onClassCreated">
        /// </param>
        private void create(object Class, object classData, object onClassCreated){}
        /// <summary>
        /// </summary>
        private void getPreprocessors(){}
        /// <summary>
        /// Parameters<li><span>Class</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>data</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>hooks</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="Class">
        /// </param>
        /// <param name="data">
        /// </param>
        /// <param name="hooks">
        /// </param>
        private void onBeforeCreated(object Class, object data, object hooks){}
        /// <summary>
        /// Parameters<li><span>Class</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>data</span> : <see cref="Object">Object</see><div>
        /// </div></li><li><span>onCreated</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="Class">
        /// </param>
        /// <param name="data">
        /// </param>
        /// <param name="onCreated">
        /// </param>
        private void process(object Class, object data, object onCreated){}
        /// <summary>
        /// Retrieve the array stack of default pre-processors
        /// </summary>
        /// <returns>
        /// <span><see cref="Function">Function</see>[]</span><div><p>defaultPreprocessors</p>
        /// </div>
        /// </returns>
        private static System.Delegate[] getDefaultPreprocessors(){return null;}
        /// <summary>
        /// Retrieve a pre-processor callback function by its name, which has been registered before
        /// </summary>
        /// <param name="name">
        /// </param>
        /// <returns>
        /// <span><see cref="Function">Function</see></span><div><p>preprocessor</p>
        /// </div>
        /// </returns>
        private static System.Delegate getPreprocessor(JsString name){return null;}
        /// <summary>
        /// Register a new pre-processor to be used during the class creation process
        /// </summary>
        /// <param name="name"><p>The pre-processor's name</p>
        /// </param>
        /// <param name="fn"><p>The callback function to be executed. Typical format:</p>
        /// <pre><code>function(cls, data, fn) {
        /// // Your code here
        /// // Execute this when the processing is finished.
        /// // Asynchronous processing is perfectly ok
        /// if (fn) {
        /// fn.call(this, cls, data);
        /// }
        /// });
        /// </code></pre>
        /// <h3>Parameters</h3><ul><li><span>cls</span> : <see cref="Function">Function</see><div><p>The created class</p>
        /// </div></li><li><span>data</span> : <see cref="Object">Object</see><div><p>The set of properties passed in <see cref="Ext.Class">Ext.Class</see> constructor</p>
        /// </div></li><li><span>fn</span> : <see cref="Function">Function</see><div><p>The callback function that <strong>must</strong> to be executed when this
        /// pre-processor finishes, regardless of whether the processing is synchronous or aynchronous.</p>
        /// </div></li></ul></param>
        /// <returns>
        /// <span><see cref="Ext.Class">Ext.Class</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        private static Class registerPreprocessor(JsString name, System.Delegate fn){return null;}
        /// <summary>
        /// Insert this pre-processor at a specific position in the stack, optionally relative to
        /// any existing pre-processor. For example:
        /// <code>Ext.Class.registerPreprocessor('debug', function(cls, data, fn) {
        /// // Your code here
        /// if (fn) {
        /// fn.call(this, cls, data);
        /// }
        /// }).setDefaultPreprocessorPosition('debug', 'last');
        /// </code>
        /// </summary>
        /// <param name="name"><p>The pre-processor name. Note that it needs to be registered with
        /// <see cref="Ext.Class">registerPreprocessor</see> before this</p>
        /// </param>
        /// <param name="offset"><p>The insertion position. Four possible values are:
        /// 'first', 'last', or: 'before', 'after' (relative to the name provided in the third argument)</p>
        /// </param>
        /// <param name="relativeName">
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Class">Ext.Class</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        private static Class setDefaultPreprocessorPosition(JsString name, JsString offset, JsString relativeName){return null;}
        /// <summary>
        /// Set the default array stack of default pre-processors
        /// </summary>
        /// <param name="preprocessors">
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Class">Ext.Class</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        private static Class setDefaultPreprocessors(JsArray preprocessors){return null;}
        public Class(ClassConfig config){}
        public Class(){}
        public Class(params object[] args){}
    }
    #endregion
    #region ClassConfig
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ClassConfig
    {
        /// <summary>
        /// List of short aliases for class names.  Most useful for defining xtypes for widgets:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.CoolPanel', {
        /// extend: '<see cref="Ext.panel.Panel">Ext.panel.Panel</see>',
        /// alias: ['widget.coolpanel'],
        /// title: 'Yeah!'
        /// });
        /// // Using <see cref="Ext.ExtContext.create">Ext.create</see>
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('widget.coolpanel');
        /// // Using the shorthand for defining widgets by xtype
        /// <see cref="Ext.ExtContext.widget">Ext.widget</see>('panel', {
        /// items: [
        /// {xtype: 'coolpanel', html: 'Foo'},
        /// {xtype: 'coolpanel', html: 'Bar'}
        /// ]
        /// });
        /// </code>
        /// Besides "widget" for xtype there are alias namespaces like "feature" for ftype and "plugin" for ptype.
        /// </summary>
        public JsString alias;
        /// <summary>
        /// Defines alternate names for this class.  For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Developer', {
        /// alternateClassName: ['Coder', 'Hacker'],
        /// code: function(msg) {
        /// alert('Typing... ' + msg);
        /// }
        /// });
        /// var joe = <see cref="Ext.ExtContext.create">Ext.create</see>('Developer');
        /// joe.code('stackoverflow');
        /// var rms = <see cref="Ext.ExtContext.create">Ext.create</see>('Hacker');
        /// rms.code('hack hack');
        /// </code>
        /// </summary>
        public object alternateClassName;
        /// <summary>
        /// List of configuration options with their default values, for which automatically
        /// accessor methods are generated.  For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('SmartPhone', {
        /// config: {
        /// hasTouchScreen: false,
        /// operatingSystem: 'Other',
        /// price: 500
        /// },
        /// constructor: function(cfg) {
        /// this.initConfig(cfg);
        /// }
        /// });
        /// var iPhone = new SmartPhone({
        /// hasTouchScreen: true,
        /// operatingSystem: 'iOS'
        /// });
        /// iPhone.getPrice(); // 500;
        /// iPhone.getOperatingSystem(); // 'iOS'
        /// iPhone.getHasTouchScreen(); // true;
        /// </code>
        /// </summary>
        public JsObject config;
        /// <summary>
        /// The parent class that this class extends. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Person', {
        /// say: function(text) { alert(text); }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('Developer', {
        /// extend: 'Person',
        /// say: function(text) { this.callParent(["print "+text]); }
        /// });
        /// </code>
        /// </summary>
        public JsString extend;
        /// <summary>
        /// List of inheritable static methods for this class.
        /// Otherwise just like statics but subclasses inherit these methods.
        /// </summary>
        public JsObject inheritableStatics;
        /// <summary>
        /// List of classes to mix into this class. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('CanSing', {
        /// sing: function() {
        /// alert("I'm on the highway to hell...")
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('Musician', {
        /// mixins: ['CanSing']
        /// })
        /// </code>
        /// In this case the Musician class will get a <c>sing</c> method from CanSing mixin.
        /// But what if the Musician already has a <c>sing</c> method? Or you want to mix
        /// in two classes, both of which define <c>sing</c>?  In such a cases it's good
        /// to define mixins as an object, where you assign a name to each mixin:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Musician', {
        /// mixins: {
        /// canSing: 'CanSing'
        /// },
        /// sing: function() {
        /// // delegate singing operation to mixin
        /// this.mixins.canSing.sing.call(this);
        /// }
        /// })
        /// </code>
        /// In this case the <c>sing</c> method of Musician will overwrite the
        /// mixed in <c>sing</c> method. But you can access the original mixed in method
        /// through special <c>mixins</c> property.
        /// </summary>
        public object mixins;
        /// <summary>
        /// List of classes that have to be loaded before instantiating this class.
        /// For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Mother', {
        /// requires: ['Child'],
        /// giveBirth: function() {
        /// // we can be sure that child class is available.
        /// return new Child();
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsString requires;
        /// <summary>
        /// When set to true, the class will be instantiated as singleton.  For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Logger', {
        /// singleton: true,
        /// log: function(msg) {
        /// console.log(msg);
        /// }
        /// });
        /// Logger.log('Hello');
        /// </code>
        /// </summary>
        public bool singleton;
        /// <summary>
        /// List of static methods for this class. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Computer', {
        /// statics: {
        /// factory: function(brand) {
        /// // 'this' in static methods refer to the class itself
        /// return new this(brand);
        /// }
        /// },
        /// constructor: function() { ... }
        /// });
        /// var dellComputer = Computer.factory('Dell');
        /// </code>
        /// </summary>
        public JsObject statics;
        /// <summary>
        /// List of optional classes to load together with this class. These aren't neccessarily loaded before
        /// this class is created, but are guaranteed to be available before Ext.onReady listeners are
        /// invoked. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Mother', {
        /// uses: ['Child'],
        /// giveBirth: function() {
        /// // This code might, or might not work:
        /// // return new Child();
        /// // Instead use <see cref="Ext.ExtContext.create">Ext.create</see>() to load the class at the spot if not loaded already:
        /// return <see cref="Ext.ExtContext.create">Ext.create</see>('Child');
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsString uses;
        public ClassConfig(params object[] args){}
    }
    #endregion
    #region ClassEvents
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ClassEvents
    {
        public ClassEvents(params object[] args){}
    }
    #endregion
}
