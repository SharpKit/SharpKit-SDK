//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:42 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.util
{
    #region Renderable
    /// <summary>
    /// <p><strong>NOTE</strong> This is a private utility class for internal use by the framework. Don't rely on its existence.</p><p>Given a component hierarchy of this:</p>
    /// <pre><code> {
    /// xtype: 'panel',
    /// id: 'ContainerA',
    /// layout: 'hbox',
    /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>(),
    /// items: [
    /// {
    /// id: 'ContainerB',
    /// xtype: 'container',
    /// items: [
    /// { id: 'ComponentA' }
    /// ]
    /// }
    /// ]
    /// }
    /// </code></pre>
    /// <p>The rendering of the above proceeds roughly like this:</p>
    /// <ul>
    /// <li>ContainerA's initComponent calls <see cref="Ext.util.Renderable.render">render</see> passing the <c>renderTo</c> property as the
    /// container argument.</li>
    /// <li><c>render</c> calls the <c>getRenderTree</c> method to get a complete <see cref="Ext.DomHelper">Ext.DomHelper</see> spec.</li>
    /// <li><c>getRenderTree</c> fires the "beforerender" event and calls the #beforeRender
    /// method. Its result is obtained by calling #getElConfig.</li>
    /// <li>The #getElConfig method uses the <c>renderTpl</c> and its render data as the content
    /// of the <c>autoEl</c> described element.</li>
    /// <li>The result of <c>getRenderTree</c> is passed to <see cref="Ext.DomHelper.append">Ext.DomHelper.append</see>.</li>
    /// <li>The <c>renderTpl</c> contains calls to render things like docked items, container items
    /// and raw markup (such as the <c>html</c> or <c>tpl</c> config properties). These calls are to
    /// methods added to the <see cref="Ext.XTemplate">Ext.XTemplate</see> instance by #setupRenderTpl.</li>
    /// <li>The #setupRenderTpl method adds methods such as <c>renderItems</c>, <c>renderContent</c>, etc.
    /// to the template. These are directed to "doRenderItems", "doRenderContent" etc..</li>
    /// <li>The #setupRenderTpl calls traverse from components to their <see cref="Ext.layout.Layout">Ext.layout.Layout</see>
    /// object.</li>
    /// <li>When a container is rendered, it also has a <c>renderTpl</c>. This is processed when the
    /// <c>renderContainer</c> method is called in the component's <c>renderTpl</c>. This call goes to
    /// Ext.layout.container.Container#doRenderContainer. This method repeats this
    /// process for all components in the container.</li>
    /// <li>After the top-most component's markup is generated and placed in to the DOM, the next
    /// step is to link elements to their components and finish calling the component methods
    /// <c>onRender</c> and <c>afterRender</c> as well as fire the corresponding events.</li>
    /// <li>The first step in this is to call #finishRender. This method descends the
    /// component hierarchy and calls <c>onRender</c> and fires the <c>render</c> event. These calls
    /// are delivered top-down to approximate the timing of these calls/events from previous
    /// versions.</li>
    /// <li>During the pass, the component's <c>el</c> is set. Likewise, the <c>renderSelectors</c> and
    /// <c>childEls</c> are applied to capture references to the component's elements.</li>
    /// <li>These calls are also made on the <see cref="Ext.layout.container.Container">Ext.layout.container.Container</see> layout to
    /// capture its elements. Both of these classes use <see cref="Ext.util.ElementContainer">Ext.util.ElementContainer</see> to
    /// handle <c>childEls</c> processing.</li>
    /// <li>Once this is complete, a similar pass is made by calling #finishAfterRender.
    /// This call also descends the component hierarchy, but this time the calls are made in
    /// a bottom-up order to <c>afterRender</c>.</li>
    /// </ul>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial interface Renderable
    {
        /// <summary>
        /// Defaults to: <c>&quot;Ext.Base&quot;</c>
        /// </summary>
        [JsProperty(Name="$className")]
        JsString @className{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        JsObject configMap{get;set;}
        /// <summary>
        /// Defaults to: <c>[]</c>
        /// </summary>
        JsArray initConfigList{get;set;}
        /// <summary>
        /// Defaults to: <c>{}</c>
        /// </summary>
        JsObject initConfigMap{get;set;}
        /// <summary>
        /// Defaults to: <c>true</c>
        /// </summary>
        bool isInstance{get;set;}
        /// <summary>
        /// Get the reference to the current class from which this object was instantiated. Unlike statics,
        /// this.self is scope-dependent and it's meant to be used for dynamic inheritance. See statics
        /// for a detailed comparison
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('My.Cat', {
        /// statics: {
        /// speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        /// },
        /// constructor: function() {
        /// alert(this.self.speciesName); // dependent on 'this'
        /// },
        /// clone: function() {
        /// return new this.self();
        /// }
        /// });
        /// <see cref="Ext.ExtContext.define">Ext.define</see>('My.SnowLeopard', {
        /// extend: 'My.Cat',
        /// statics: {
        /// speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
        /// }
        /// });
        /// var cat = new My.Cat();                     // alerts 'Cat'
        /// var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
        /// var clone = snowLeopard.clone();
        /// alert(<see cref="Ext.ExtContext.getClassName">Ext.getClassName</see>(clone));             // alerts 'My.SnowLeopard'
        /// </code>
        /// </summary>
        Class self{get;set;}
        /// <summary>
        /// Allows addition of behavior after rendering is complete. At this stage the Componentâ€™s Element
        /// will have been styled according to the configuration, will have had any configured CSS class
        /// names added, and will be in the configured visibility and the configured enable state.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        void afterRender();
        /// <summary>
        /// Sets references to elements inside the component. This applies renderSelectors
        /// as well as childEls.
        /// </summary>
        void applyRenderSelectors();
        /// <summary>
        /// Called from the selected frame generation template to insert this Component's inner structure inside the framing structure.
        /// When framing is used, a selected frame generation template is used as the primary template of the #getElConfig instead
        /// of the configured <see cref="Ext.AbstractComponentConfig.renderTpl">renderTpl</see>. The renderTpl is invoked by this method which is injected into the framing template.
        /// </summary>
        /// <param name="out">
        /// </param>
        /// <param name="values">
        /// </param>
        void doApplyRenderTpl(object @out, object values);
        /// <summary>
        /// Handles autoRender.
        /// Floating Components may have an ownerCt. If they are asking to be constrained, constrain them within that
        /// ownerCt, and have their z-index managed locally. Floating Components are always rendered to document.body
        /// </summary>
        void doAutoRender();
        /// <summary>
        /// Ensures that this component is attached to document.body. If the component was
        /// rendered to Ext.getDetachedBody, then it will be appended to document.body.
        /// Any configured position is also restored.
        /// </summary>
        /// <param name="runLayout"><p>True to run the component's layout.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        void ensureAttachedToBody(object runLayout=null);
        /// <summary>
        /// This method visits the rendered component tree in a "top-down" order. That is, this
        /// code runs on a parent component before running on a child. This method calls the
        /// onRender method of each component.
        /// </summary>
        /// <param name="containerIdx"><p>The index into the Container items of this Component.</p>
        /// </param>
        void finishRender(JsNumber containerIdx);
        /// <summary>
        /// On render, reads an encoded style attribute, "background-position" from the style of this Component's element.
        /// This information is memoized based upon the CSS class name of this Component's element.
        /// Because child Components are rendered as textual HTML as part of the topmost Container, a dummy div is inserted
        /// into the document to receive the document element's CSS class name, and therefore style attributes.
        /// </summary>
        void getFrameInfo();
        /// <summary>
        /// Parameters<li><span>table</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="table">
        /// </param>
        void getFrameTpl(object table);
        /// <summary>
        /// This function takes the position argument passed to onRender and returns a
        /// DOM element that you can use in the insertBefore.
        /// </summary>
        /// <param name="position"><p>Index, element id or element you want
        /// to put this component before.</p>
        /// </param>
        /// <returns>
        /// <span>HTMLElement</span><div><p>DOM element that you can use in the insertBefore</p>
        /// </div>
        /// </returns>
        JsObject getInsertPosition(object position);
        /// <summary>
        /// Returns an offscreen div with the same class name as the element this is being rendered.
        /// This is because child item rendering takes place in a detached div which, being not part of the document, has no styling.
        /// </summary>
        /// <param name="cls">
        /// </param>
        void getStyleProxy(object cls);
        /// <summary>
        /// </summary>
        void initFrame();
        /// <summary>
        /// Initialized the renderData to be used when rendering the renderTpl.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>Object with keys and values that are going to be applied to the renderTpl</p>
        /// </div>
        /// </returns>
        object initRenderData();
        /// <summary>
        /// Initializes the renderTpl.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.XTemplate">Ext.XTemplate</see></span><div><p>The renderTpl XTemplate instance.</p>
        /// </div>
        /// </returns>
        XTemplate initRenderTpl();
        /// <summary>
        /// Template method called when this Component's DOM structure is created.
        /// At this point, this Component's (and all descendants') DOM structure <em>exists</em> but it has not
        /// been layed out (positioned and sized).
        /// Subclasses which override this to gain access to the structure at render time should
        /// call the parent class's method before attempting to access any child elements of the Component.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="parentNode"><p>The parent Element in which this Component's encapsulating element is contained.</p>
        /// </param>
        /// <param name="containerIdx"><p>The index within the parent Container's child collection of this Component.</p>
        /// </param>
        void onRender(Ext.dom.Element parentNode, JsNumber containerIdx);
        /// <summary>
        /// Renders the Component into the passed HTML element.
        /// <strong>If you are using a <see cref="Ext.container.Container">Container</see> object to house this
        /// Component, then do not use the render method.</strong>
        /// A Container's child Components are rendered by that Container's
        /// <see cref="Ext.container.ContainerConfig.layout">layout</see> manager when the Container is first rendered.
        /// If the Container is already rendered when a new child Component is added, you may need to call
        /// the Container's <see cref="Ext.container.Container.doLayout">doLayout</see> to refresh the view which
        /// causes any unrendered child Components to be rendered. This is required so that you can add
        /// multiple child components if needed while only refreshing the layout once.
        /// When creating complex UIs, it is important to remember that sizing and positioning
        /// of child items is the responsibility of the Container's <see cref="Ext.container.ContainerConfig.layout">layout</see>
        /// manager.  If you expect child items to be sized in response to user interactions, you must
        /// configure the Container with a layout manager which creates and manages the type of layout you
        /// have in mind.
        /// <strong>Omitting the Container's <see cref="Ext.container.ContainerConfig.layout">layout</see> config means that a basic
        /// layout manager is used which does nothing but render child components sequentially into the
        /// Container. No sizing or positioning will be performed in this situation.</strong>
        /// </summary>
        /// <param name="container"><p>The element this Component should be
        /// rendered into. If it is being created from existing markup, this should be omitted.</p>
        /// </param>
        /// <param name="position"><p>The element ID or DOM node index within the container <strong>before</strong>
        /// which this component will be inserted (defaults to appending to the end of the container)</p>
        /// </param>
        void render(object container=null, object position=null);
        /// <summary>
        /// Inject a reference to the function which applies the render template into the framing template. The framing template
        /// wraps the content.
        /// </summary>
        /// <param name="frameTpl">
        /// </param>
        void setupFramingTpl(object frameTpl);
    }
    #endregion
    #region RenderableConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class RenderableConfig : Ext.BaseConfig
    {
        public RenderableConfig(params object[] args){}
    }
    #endregion
    #region RenderableEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class RenderableEvents : Ext.BaseEvents
    {
        public RenderableEvents(params object[] args){}
    }
    #endregion
}
