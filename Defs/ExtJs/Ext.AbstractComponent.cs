//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext
{
    #region AbstractComponent
    /// <inheritdocs />
    /// <summary>
    /// <p><strong>NOTE</strong> This is a private utility class for internal use by the framework. Don't rely on its existence.</p><p>An abstract base class which provides shared methods for Components across the Sencha product line.</p>
    /// <p>Please refer to sub class's documentation</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractComponent : Ext.Base, Ext.util.Observable, Ext.util.Animate, Ext.util.ElementContainer, Ext.util.Renderable, Ext.state.Stateful
    {
        /// <summary>
        /// A tag name or DomHelper spec used to create the Element which will
        /// encapsulate this Component.
        /// You do not normally need to specify this. For the base classes <see cref="Ext.Component">Ext.Component</see> and
        /// <see cref="Ext.container.Container">Ext.container.Container</see>, this defaults to <strong>'div'</strong>. The more complex Sencha classes use a more
        /// complex DOM structure specified by their own <see cref="Ext.AbstractComponentConfig.renderTpl">renderTpl</see>s.
        /// This is intended to allow the developer to create application-specific utility Components encapsulated by
        /// different DOM elements. Example usage:
        /// <code>{
        /// xtype: 'component',
        /// autoEl: {
        /// tag: 'img',
        /// src: 'http://www.example.com/example.jpg'
        /// }
        /// }, {
        /// xtype: 'component',
        /// autoEl: {
        /// tag: 'blockquote',
        /// html: 'autoEl is cool!'
        /// }
        /// }, {
        /// xtype: 'container',
        /// autoEl: 'ul',
        /// cls: 'ux-unordered-list',
        /// items: {
        /// xtype: 'component',
        /// autoEl: 'li',
        /// html: 'First list item'
        /// }
        /// }
        /// </code>
        /// </summary>
        public object autoEl;
        /// <summary>
        /// An alias for loader config which also allows to specify just a string which will be
        /// used as the url that's automatically loaded:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// autoLoad: 'content.html',
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>()
        /// });
        /// </code>
        /// The above is the same as:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// loader: {
        /// url: 'content.html',
        /// autoLoad: true
        /// },
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>()
        /// });
        /// </code>
        /// Don't use it together with <see cref="Ext.AbstractComponentConfig.loader">loader</see> config.
        /// <p>This cfg has been <strong>deprecated</strong> since 4.1.1</p>
        /// <p>Use <see cref="Ext.AbstractComponentConfig.loader">loader</see> config instead.</p>
        /// </summary>
        public object autoLoad;
        /// <summary>
        /// This config is intended mainly for non-floating Components which may or may not be shown. Instead of using
        /// renderTo in the configuration, and rendering upon construction, this allows a Component to render itself
        /// upon first show. If floating is true, the value of this config is omited as if it is true.
        /// Specify as <c>true</c> to have this Component render to the document body upon first show.
        /// Specify as an element, or the ID of an element to have this Component render to a specific element upon first
        /// show.
        /// Defaults to: <c>false</c>
        /// </summary>
        public object autoRender;
        /// <summary>
        /// True to automatically show the component upon creation. This config option may only be used for
        /// floating components or components that use autoRender. Defaults to false.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool autoShow;
        /// <summary>
        /// The base CSS class to apply to this components's element. This will also be prepended to elements within this
        /// component like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and
        /// you want it to get all the Panels styling for the element and the body, you leave the baseCls x-panel and use
        /// componentCls to add specific styling for this component.
        /// Defaults to: <c>&quot;x-component&quot;</c>
        /// </summary>
        public JsString baseCls;
        /// <summary>
        /// Specifies the border size for this component. The border can be a single numeric value to apply to all sides or it can
        /// be a CSS style specification for each style, for example: '10 5 3 10'.
        /// For components that have no border by default, setting this won't make the border appear by itself.
        /// You also need to specify border color and style:
        /// <code>border: 5,
        /// style: {
        /// borderColor: 'red',
        /// borderStyle: 'solid'
        /// }
        /// </code>
        /// To turn off the border, use <c>border: false</c>.
        /// </summary>
        public object border;
        /// <summary>
        /// An array describing the child elements of the Component. Each member of the array
        /// is an object with these properties:
        /// <li><c>name</c> - The property name on the Component for the child element.</li>
        /// <li><c>itemId</c> - The id to combine with the Component's id that is the id of the child element.</li>
        /// <li><c>id</c> - The id of the child element.</li>
        /// If the array member is a string, it is equivalent to <c>{ name: m, itemId: m }</c>.
        /// For example, a Component which renders a title and body text:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>(),
        /// renderTpl: [
        /// '&lt;h1 id="{id}-title"&gt;{title}&lt;/h1&gt;',
        /// '&lt;p&gt;{msg}&lt;/p&gt;',
        /// ],
        /// renderData: {
        /// title: "Error",
        /// msg: "Something went wrong"
        /// },
        /// childEls: ["title"],
        /// listeners: {
        /// afterrender: function(cmp){
        /// // After rendering the component will have a title property
        /// cmp.title.setStyle({color: "red"});
        /// }
        /// }
        /// });
        /// </code>
        /// A more flexible, but somewhat slower, approach is <see cref="Ext.AbstractComponentConfig.renderSelectors">renderSelectors</see>.
        /// </summary>
        public JsObject childEls;
        /// <summary>
        /// An optional extra CSS class that will be added to this component's Element. This can be useful
        /// for adding customized styles to the component or any of its children using standard CSS rules.
        /// Defaults to: <c>&quot;&quot;</c>
        /// </summary>
        public JsString cls;
        /// <summary>
        /// CSS Class to be added to a components root level element to give distinction to it via styling.
        /// </summary>
        public JsString componentCls;
        /// <summary>
        /// The sizing and positioning of a Component's internal Elements is the responsibility of the Component's layout
        /// manager which sizes a Component's internal structure in response to the Component being sized.
        /// Generally, developers will not use this configuration as all provided Components which need their internal
        /// elements sizing (Such as <see cref="Ext.form.field.Base">input fields</see>) come with their own componentLayout managers.
        /// The <see cref="Ext.layout.container.Auto">default layout manager</see> will be used on instances of the base <see cref="Ext.Component">Ext.Component</see>
        /// class which simply sizes the Component's encapsulating element to the height and width specified in the
        /// <see cref="Ext.AbstractComponent.setSize">setSize</see> method.
        /// </summary>
        public object componentLayout;
        /// <summary>
        /// Specify an existing HTML element, or the id of an existing HTML element to use as the content for this component.
        /// This config option is used to take an existing HTML element and place it in the layout element of a new component
        /// (it simply moves the specified DOM element <em>after the Component is rendered</em> to use as the content.
        /// <strong>Notes:</strong>
        /// The specified HTML element is appended to the layout element of the component <em>after any configured
        /// <see cref="Ext.AbstractComponentConfig.html">HTML</see> has been inserted</em>, and so the document will not contain this element at the time
        /// the <see cref="Ext.AbstractComponentEvents.render">render</see> event is fired.
        /// The specified HTML element used will not participate in any <strong><c><see cref="Ext.container.ContainerConfig.layout">layout</see></c></strong>
        /// scheme that the Component may use. It is just HTML. Layouts operate on child
        /// <strong><c><see cref="Ext.container.ContainerConfig.items">items</see></c></strong>.
        /// Add either the <c>x-hidden</c> or the <c>x-hide-display</c> CSS class to prevent a brief flicker of the content before it
        /// is rendered to the panel.
        /// </summary>
        public JsString contentEl;
        /// <summary>
        /// The initial set of data to apply to the tpl to update the content area of the Component.
        /// </summary>
        public JsObject data;
        /// <summary>
        /// True to disable the component.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool disabled;
        /// <summary>
        /// CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.
        /// Defaults to: <c>&quot;x-item-disabled&quot;</c>
        /// </summary>
        public JsString disabledCls;
        /// <summary>
        /// Create the Component as a floating and use absolute positioning.
        /// The z-index of floating Components is handled by a ZIndexManager. If you simply render a floating Component into the DOM, it will be managed
        /// by the global <see cref="Ext.WindowManager">WindowManager</see>.
        /// If you include a floating Component as a child item of a Container, then upon render, ExtJS will seek an ancestor floating Component to house a new
        /// ZIndexManager instance to manage its descendant floaters. If no floating ancestor can be found, the global WindowManager will be used.
        /// When a floating Component which has a ZindexManager managing descendant floaters is destroyed, those descendant floaters will also be destroyed.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool floating;
        /// <summary>
        /// Specify as true to have the Component inject framing elements within the Component at render time to provide a
        /// graphical rounded frame around the Component content.
        /// This is only necessary when running on outdated, or non standard-compliant browsers such as Microsoft's Internet
        /// Explorer prior to version 9 which do not support rounded corners natively.
        /// The extra space taken up by this framing is available from the read only property <see cref="Ext.AbstractComponent.frameSize">frameSize</see>.
        /// </summary>
        public bool frame;
        /// <summary>
        /// The height of this component in pixels.
        /// </summary>
        public JsNumber height;
        /// <summary>
        /// True to hide the component.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool hidden;
        /// <summary>
        /// A String which specifies how this Component's encapsulating DOM element will be hidden. Values may be:
        /// <li><c>'display'</c> : The Component will be hidden using the <c>display: none</c> style.</li>
        /// <li><c>'visibility'</c> : The Component will be hidden using the <c>visibility: hidden</c> style.</li>
        /// <li><c>'offsets'</c> : The Component will be hidden by absolutely positioning it out of the visible area of the document.
        /// This is useful when a hidden Component must maintain measurable dimensions. Hiding using <c>display</c> results in a
        /// Component having zero dimensions.</li>
        /// Defaults to: <c>&quot;display&quot;</c>
        /// </summary>
        public JsString hideMode;
        /// <summary>
        /// An HTML fragment, or a DomHelper specification to use as the layout element content.
        /// The HTML content is added after the component is rendered, so the document will not contain this HTML at the time
        /// the render event is fired. This content is inserted into the body before any configured contentEl
        /// is appended.
        /// Defaults to: <c>&quot;&quot;</c>
        /// </summary>
        public object html;
        /// <summary>
        /// The unique id of this component instance.
        /// It should not be necessary to use this configuration except for singleton objects in your application. Components
        /// created with an id may be accessed globally using <see cref="Ext.ExtContext.getCmp">Ext.getCmp</see>.
        /// Instead of using assigned ids, use the <see cref="Ext.AbstractComponentConfig.itemId">itemId</see> config, and <see cref="Ext.ComponentQuery">ComponentQuery</see>
        /// which provides selector-based searching for Sencha Components analogous to DOM querying. The <see cref="Ext.container.Container">Container</see> class contains <see cref="Ext.container.Container.down">shortcut methods</see> to query
        /// its descendant Components by selector.
        /// Note that this id will also be used as the element id for the containing HTML element that is rendered to the
        /// page for this component. This allows you to write id-based CSS rules to style the specific instance of this
        /// component uniquely, and also to select sub-elements using this component's id as the parent.
        /// <strong>Note</strong>: to avoid complications imposed by a unique id also see <c><see cref="Ext.AbstractComponentConfig.itemId">itemId</see></c>.
        /// <strong>Note</strong>: to access the container of a Component see <c><see cref="Ext.AbstractComponent.ownerCt">ownerCt</see></c>.
        /// Defaults to an <see cref="Ext.AbstractComponent.getId">auto-assigned id</see>.
        /// </summary>
        public JsString id;
        /// <summary>
        /// An itemId can be used as an alternative way to get a reference to a component when no object reference is
        /// available. Instead of using an id with Ext.getCmp, use itemId with
        /// Ext.container.Container.getComponent which will retrieve
        /// itemId's or id's. Since itemId's are an index to the container's internal MixedCollection, the
        /// itemId is scoped locally to the container -- avoiding potential conflicts with Ext.ComponentManager
        /// which requires a unique id.
        /// <code>var c = new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({ //
        /// <see cref="Ext.ComponentConfig.height">height</see>: 300,
        /// <see cref="Ext.AbstractComponentConfig.renderTo">renderTo</see>: document.body,
        /// <see cref="Ext.container.ContainerConfig.layout">layout</see>: 'auto',
        /// <see cref="Ext.container.ContainerConfig.items">items</see>: [
        /// {
        /// itemId: 'p1',
        /// <see cref="Ext.panel.PanelConfig.title">title</see>: 'Panel 1',
        /// <see cref="Ext.ComponentConfig.height">height</see>: 150
        /// },
        /// {
        /// itemId: 'p2',
        /// <see cref="Ext.panel.PanelConfig.title">title</see>: 'Panel 2',
        /// <see cref="Ext.ComponentConfig.height">height</see>: 150
        /// }
        /// ]
        /// })
        /// p1 = c.<see cref="Ext.container.Container.getComponent">getComponent</see>('p1'); // not the same as <see cref="Ext.ExtContext.getCmp">Ext.getCmp()</see>
        /// p2 = p1.<see cref="Ext.AbstractComponent.ownerCt">ownerCt</see>.<see cref="Ext.container.Container.getComponent">getComponent</see>('p2'); // reference via a sibling
        /// </code>
        /// Also see <see cref="Ext.AbstractComponentConfig.id">id</see>, <c><see cref="Ext.container.Container.query">Ext.container.Container.query</see></c>, <c><see cref="Ext.container.Container.down">Ext.container.Container.down</see></c> and
        /// <c><see cref="Ext.container.Container.child">Ext.container.Container.child</see></c>.
        /// <strong>Note</strong>: to access the container of an item see <see cref="Ext.AbstractComponent.ownerCt">ownerCt</see>.
        /// </summary>
        public JsString itemId;
        /// <summary>
        /// A config object containing one or more event handlers to be added to this object during initialization. This
        /// should be a valid listeners config object as specified in the addListener example for attaching multiple
        /// handlers at once.
        /// <strong>DOM events from Ext JS <see cref="Ext.Component">Components</see></strong>
        /// While <em>some</em> Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
        /// only done when extra value can be added. For example the <see cref="Ext.view.View">DataView</see>'s <strong><c><see cref="Ext.view.ViewEvents.itemclick">itemclick</see></c></strong> event passing the node clicked on. To access DOM events directly from a
        /// child element of a Component, we need to specify the <c>element</c> option to identify the Component property to add a
        /// DOM listener to:
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// width: 400,
        /// height: 200,
        /// dockedItems: [{
        /// xtype: 'toolbar'
        /// }],
        /// listeners: {
        /// click: {
        /// element: 'el', //bind to the underlying el property on the panel
        /// fn: function(){ console.log('click el'); }
        /// },
        /// dblclick: {
        /// element: 'body', //bind to the underlying body property on the panel
        /// fn: function(){ console.log('dblclick body'); }
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsObject listeners;
        /// <summary>
        /// A configuration object or an instance of a Ext.ComponentLoader to load remote content
        /// for this Component.
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// loader: {
        /// url: 'content.html',
        /// autoLoad: true
        /// },
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>()
        /// });
        /// </code>
        /// </summary>
        public object loader;
        /// <summary>
        /// Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can
        /// be a CSS style specification for each style, for example: '10 5 3 10'.
        /// </summary>
        public object margin;
        /// <summary>
        /// The maximum value in pixels which this Component will set its height to.
        /// <strong>Warning:</strong> This will override any size management applied by layout managers.
        /// </summary>
        public JsNumber maxHeight;
        /// <summary>
        /// The maximum value in pixels which this Component will set its width to.
        /// <strong>Warning:</strong> This will override any size management applied by layout managers.
        /// </summary>
        public JsNumber maxWidth;
        /// <summary>
        /// The minimum value in pixels which this Component will set its height to.
        /// <strong>Warning:</strong> This will override any size management applied by layout managers.
        /// </summary>
        public JsNumber minHeight;
        /// <summary>
        /// The minimum value in pixels which this Component will set its width to.
        /// <strong>Warning:</strong> This will override any size management applied by layout managers.
        /// </summary>
        public JsNumber minWidth;
        /// <summary>
        /// An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element,
        /// and removed when the mouse moves out. This can be useful for adding customized 'active' or 'hover' styles to the
        /// component or any of its children using standard CSS rules.
        /// Defaults to: <c>&quot;&quot;</c>
        /// </summary>
        public JsString overCls;
        /// <summary>
        /// Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it
        /// can be a CSS style specification for each style, for example: '10 5 3 10'.
        /// </summary>
        public object padding;
        /// <summary>
        /// An object or array of objects that will provide custom functionality for this component. The only requirement for
        /// a valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component
        /// is created, if any plugins are available, the component will call the init method on each plugin, passing a
        /// reference to itself. Each plugin can then call methods or respond to events on the component as needed to provide
        /// its functionality.
        /// </summary>
        public object plugins;
        /// <summary>
        /// The data used by renderTpl in addition to the following property values of the component:
        /// <li>id</li>
        /// <li>ui</li>
        /// <li>uiCls</li>
        /// <li>baseCls</li>
        /// <li>componentCls</li>
        /// <li>frame</li>
        /// See <see cref="Ext.AbstractComponentConfig.renderSelectors">renderSelectors</see> and <see cref="Ext.AbstractComponentConfig.childEls">childEls</see> for usage examples.
        /// </summary>
        public JsObject renderData;
        /// <summary>
        /// An object containing properties specifying DomQuery selectors which identify child elements
        /// created by the render process.
        /// After the Component's internal structure is rendered according to the <see cref="Ext.AbstractComponentConfig.renderTpl">renderTpl</see>, this object is iterated through,
        /// and the found Elements are added as properties to the Component using the <c>renderSelector</c> property name.
        /// For example, a Component which renderes a title and description into its element:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>(),
        /// renderTpl: [
        /// '&lt;h1 class="title"&gt;{title}&lt;/h1&gt;',
        /// '&lt;p&gt;{desc}&lt;/p&gt;'
        /// ],
        /// renderData: {
        /// title: "Error",
        /// desc: "Something went wrong"
        /// },
        /// renderSelectors: {
        /// titleEl: 'h1.title',
        /// descEl: 'p'
        /// },
        /// listeners: {
        /// afterrender: function(cmp){
        /// // After rendering the component will have a titleEl and descEl properties
        /// cmp.titleEl.setStyle({color: "red"});
        /// }
        /// }
        /// });
        /// </code>
        /// For a faster, but less flexible, alternative that achieves the same end result (properties for child elements on the
        /// Component after render), see <see cref="Ext.AbstractComponentConfig.childEls">childEls</see> and <see cref="Ext.AbstractComponent.addChildEls">addChildEls</see>.
        /// </summary>
        public JsObject renderSelectors;
        /// <summary>
        /// Specify the id of the element, a DOM element or an existing Element that this component will be rendered into.
        /// <strong>Notes:</strong>
        /// Do <em>not</em> use this option if the Component is to be a child item of a <see cref="Ext.container.Container">Container</see>.
        /// It is the responsibility of the <see cref="Ext.container.Container">Container</see>'s
        /// <see cref="Ext.container.ContainerConfig.layout">layout manager</see> to render and manage its child items.
        /// When using this config, a call to render() is not required.
        /// See also: <see cref="Ext.AbstractComponent.render">render</see>.
        /// </summary>
        public object renderTo;
        /// <summary>
        /// An XTemplate used to create the internal structure inside this Component's encapsulating
        /// Element.
        /// You do not normally need to specify this. For the base classes <see cref="Ext.Component">Ext.Component</see> and
        /// <see cref="Ext.container.Container">Ext.container.Container</see>, this defaults to <strong><c>null</c></strong> which means that they will be initially rendered
        /// with no internal structure; they render their <see cref="Ext.AbstractComponent.getEl">Element</see> empty. The more specialized ExtJS and Touch
        /// classes which use a more complex DOM structure, provide their own template definitions.
        /// This is intended to allow the developer to create application-specific utility Components with customized
        /// internal structure.
        /// Upon rendering, any created child elements may be automatically imported into object properties using the
        /// <see cref="Ext.AbstractComponentConfig.renderSelectors">renderSelectors</see> and <see cref="Ext.AbstractComponentConfig.childEls">childEls</see> options.
        /// Defaults to: <c>&quot;{%this.renderContent(out,values)%}&quot;</c>
        /// </summary>
        public object renderTpl;
        /// <summary>
        /// A buffer to be applied if many state events are fired within a short period.
        /// Defaults to: <c>100</c>
        /// </summary>
        public JsNumber saveDelay;
        /// <summary>
        /// If this property is a number, it is interpreted as follows:
        /// <li>0: Neither width nor height depend on content. This is equivalent to <c>false</c>.</li>
        /// <li>1: Width depends on content (shrink wraps), but height does not.</li>
        /// <li>2: Height depends on content (shrink wraps), but width does not. The default.</li>
        /// <li>3: Both width and height depend on content (shrink wrap). This is equivalent to <c>true</c>.</li>
        /// In CSS terms, shrink-wrap width is analogous to an inline-block element as opposed
        /// to a block-level element. Some container layouts always shrink-wrap their children,
        /// effectively ignoring this property (e.g., <see cref="Ext.layout.container.HBox">Ext.layout.container.HBox</see>,
        /// <see cref="Ext.layout.container.VBox">Ext.layout.container.VBox</see>, <see cref="Ext.layout.component.Dock">Ext.layout.component.Dock</see>).
        /// Defaults to: <c>2</c>
        /// </summary>
        public object shrinkWrap;
        /// <summary>
        /// An array of events that, when fired, should trigger this object to
        /// save its state. Defaults to none. stateEvents may be any type
        /// of event supported by this object, including browser or custom events
        /// (e.g., ['click', 'customerchange']).
        /// See <c><see cref="Ext.state.StatefulConfig.stateful">stateful</see></c> for an explanation of saving and
        /// restoring object state.
        /// </summary>
        public JsString stateEvents;
        /// <summary>
        /// The unique id for this object to use for state management purposes.
        /// See <see cref="Ext.state.StatefulConfig.stateful">stateful</see> for an explanation of saving and restoring state.
        /// </summary>
        public JsString stateId;
        /// <summary>
        /// A flag which causes the object to attempt to restore the state of
        /// internal properties from a saved state on startup. The object must have
        /// a stateId for state to be managed.
        /// Auto-generated ids are not guaranteed to be stable across page loads and
        /// cannot be relied upon to save and restore the same state for a object.
        /// For state saving to work, the state manager's provider must have been
        /// set to an implementation of <see cref="Ext.state.Provider">Ext.state.Provider</see> which overrides the
        /// <see cref="Ext.state.Provider.set">set</see> and <see cref="Ext.state.Provider.get">get</see>
        /// methods to save and recall name/value pairs. A built-in implementation,
        /// <see cref="Ext.state.CookieProvider">Ext.state.CookieProvider</see> is available.
        /// To set the state provider for the current page:
        /// <see cref="Ext.state.Manager.setProvider">Ext.state.Manager.setProvider</see>(new <see cref="Ext.state.CookieProvider">Ext.state.CookieProvider</see>({
        /// <code>   expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
        /// </code>
        /// }));
        /// A stateful object attempts to save state when one of the events
        /// listed in the <see cref="Ext.state.StatefulConfig.stateEvents">stateEvents</see> configuration fires.
        /// To save state, a stateful object first serializes its state by
        /// calling <em><see cref="Ext.state.Stateful.getState">getState</see></em>.
        /// The Component base class implements <see cref="Ext.state.Stateful.getState">getState</see> to save its width and height within the state
        /// only if they were initially configured, and have changed from the configured value.
        /// The Panel class saves its collapsed state in addition to that.
        /// The Grid class saves its column state in addition to its superclass state.
        /// If there is more application state to be save, the developer must provide an implementation which
        /// first calls the superclass method to inherit the above behaviour, and then injects new properties
        /// into the returned object.
        /// The value yielded by getState is passed to <see cref="Ext.state.Manager.set">Ext.state.Manager.set</see>
        /// which uses the configured <see cref="Ext.state.Provider">Ext.state.Provider</see> to save the object
        /// keyed by the <see cref="Ext.state.StatefulConfig.stateId">stateId</see>.
        /// During construction, a stateful object attempts to <em>restore</em> its state by calling
        /// <see cref="Ext.state.Manager.get">Ext.state.Manager.get</see> passing the <see cref="Ext.state.StatefulConfig.stateId">stateId</see>
        /// The resulting object is passed to <see cref="Ext.state.Stateful.applyState">applyState</see>*. The default implementation of
        /// <see cref="Ext.state.Stateful.applyState">applyState</see> simply copies properties into the object, but a developer may
        /// override this to support restoration of more complex application state.
        /// You can perform extra processing on state save and restore by attaching
        /// handlers to the <see cref="Ext.state.StatefulEvents.beforestaterestore">beforestaterestore</see>, <see cref="Ext.state.StatefulEvents.staterestore">staterestore</see>,
        /// <see cref="Ext.state.StatefulEvents.beforestatesave">beforestatesave</see> and <see cref="Ext.state.StatefulEvents.statesave">statesave</see> events.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool stateful;
        /// <summary>
        /// A custom style specification to be applied to this component's Element. Should be a valid argument to
        /// Ext.Element.applyStyles.
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'Some Title',
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>(),
        /// width: 400, height: 300,
        /// layout: 'form',
        /// items: [{
        /// xtype: 'textarea',
        /// style: {
        /// width: '95%',
        /// marginBottom: '10px'
        /// }
        /// },
        /// new <see cref="Ext.button.Button">Ext.button.Button</see>({
        /// text: 'Send',
        /// minWidth: '100',
        /// style: {
        /// marginBottom: '10px'
        /// }
        /// })
        /// ]
        /// });
        /// </code>
        /// </summary>
        public object style;
        /// <summary>
        /// The class that is added to the content target when you set styleHtmlContent to true.
        /// Defaults to: <c>&quot;x-html&quot;</c>
        /// </summary>
        public JsString styleHtmlCls;
        /// <summary>
        /// True to automatically style the html inside the content target of this component (body for panels).
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool styleHtmlContent;
        /// <summary>
        /// An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in
        /// conjunction with the data and tplWriteMode configurations.
        /// </summary>
        public object tpl;
        /// <summary>
        /// The Ext.(X)Template method to use when updating the content area of the Component.
        /// See Ext.XTemplate.overwrite for information on default mode.
        /// Defaults to: <c>&quot;overwrite&quot;</c>
        /// </summary>
        public JsString tplWriteMode;
        /// <summary>
        /// A UI style for a component.
        /// Defaults to: <c>&quot;default&quot;</c>
        /// </summary>
        public JsString ui;
        /// <summary>
        /// An array of of classNames which are currently applied to this component
        /// Defaults to: <c>[]</c>
        /// </summary>
        public JsString uiCls;
        /// <summary>
        /// The width of this component in pixels.
        /// </summary>
        public JsNumber width;
        /// <summary>
        /// This property provides a shorter alternative to creating objects than using a full
        /// class name. Using xtype is the most common way to define component instances,
        /// especially in a container. For example, the items in a form containing text fields
        /// could be created explicitly like so:
        /// <code> items: [
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.form.field.Text">Ext.form.field.Text</see>', {
        /// fieldLabel: 'Foo'
        /// }),
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.form.field.Text">Ext.form.field.Text</see>', {
        /// fieldLabel: 'Bar'
        /// }),
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.form.field.Number">Ext.form.field.Number</see>', {
        /// fieldLabel: 'Num'
        /// })
        /// ]
        /// </code>
        /// But by using <c>xtype</c>, the above becomes:
        /// <code> items: [
        /// {
        /// xtype: 'textfield',
        /// fieldLabel: 'Foo'
        /// },
        /// {
        /// xtype: 'textfield',
        /// fieldLabel: 'Bar'
        /// },
        /// {
        /// xtype: 'numberfield',
        /// fieldLabel: 'Num'
        /// }
        /// ]
        /// </code>
        /// When the <c>xtype</c> is common to many items, <see cref="Ext.container.AbstractContainerConfig.defaultType">Ext.container.AbstractContainer.defaultType</see>
        /// is another way to specify the <c>xtype</c> for all items that don't have an explicit <c>xtype</c>:
        /// <code> defaultType: 'textfield',
        /// items: [
        /// { fieldLabel: 'Foo' },
        /// { fieldLabel: 'Bar' },
        /// { fieldLabel: 'Num', xtype: 'numberfield' }
        /// ]
        /// </code>
        /// Each member of the <c>items</c> array is now just a "configuration object". These objects
        /// are used to create and configure component instances. A configuration object can be
        /// manually used to instantiate a component using <see cref="Ext.ExtContext.widget">Ext.widget</see>:
        /// <code> var text1 = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.form.field.Text">Ext.form.field.Text</see>', {
        /// fieldLabel: 'Foo'
        /// });
        /// // or alternatively:
        /// var text1 = <see cref="Ext.ExtContext.widget">Ext.widget</see>({
        /// xtype: 'textfield',
        /// fieldLabel: 'Foo'
        /// });
        /// </code>
        /// This conversion of configuration objects into instantiated components is done when
        /// a container is created as part of its {<see cref="Ext.container.AbstractContainer.initComponent">Ext.container.AbstractContainer.initComponent</see>}
        /// process. As part of the same process, the <c>items</c> array is converted from its raw
        /// array form into a <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see> instance.
        /// You can define your own <c>xtype</c> on a custom <see cref="Ext.Component">component</see> by specifying
        /// the <c>xtype</c> property in <see cref="Ext.ExtContext.define">Ext.define</see>. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.PressMeButton', {
        /// extend: '<see cref="Ext.button.Button">Ext.button.Button</see>',
        /// xtype: 'pressmebutton',
        /// text: 'Press Me'
        /// });
        /// </code>
        /// Care should be taken when naming an <c>xtype</c> in a custom component because there is
        /// a single, shared scope for all xtypes. Third part components should consider using
        /// a prefix to avoid collisions.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Foo.form.CoolButton', {
        /// extend: '<see cref="Ext.button.Button">Ext.button.Button</see>',
        /// xtype: 'ux-coolbutton',
        /// text: 'Cool!'
        /// });
        /// </code>
        /// </summary>
        public JsString xtype;
        /// <summary>
        /// Setting this property to true causes the isLayoutRoot method to return
        /// true and stop the search for the top-most component for a layout.
        /// Defaults to: <c>false</c>
        /// </summary>
        protected bool _isLayoutRoot{get;set;}
        /// <summary>
        /// true indicates an id was auto-generated rather than provided by configuration.
        /// Defaults to: <c>false</c>
        /// </summary>
        private bool autoGenId{get;set;}
        /// <summary>
        /// The number of component layout calls made on this object.
        /// Defaults to: <c>0</c>
        /// </summary>
        private JsNumber componentLayoutCounter{get;set;}
        /// <summary>
        /// Indicates whether or not the component can be dragged.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool draggable{get;set;}
        /// <summary>
        /// Initial suspended call count. Incremented when suspendEvents is called, decremented when resumeEvents is called.
        /// Defaults to: <c>0</c>
        /// </summary>
        public JsNumber eventsSuspended{get;set;}
        /// <summary>
        /// Indicates the width of any framing elements which were added within the encapsulating element
        /// to provide graphical, rounded borders. See the frame config.
        /// This is an object containing the frame width in pixels for all four sides of the Component containing the
        /// following properties:
        /// Defaults to: <c>{left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0}</c><li><span>top</span> : <see cref="Number">Number</see> (optional)<div><p>The width of the top framing element in pixels.</p>
        /// <p>Defaults to: <c>0</c></p></div></li><li><span>right</span> : <see cref="Number">Number</see> (optional)<div><p>The width of the right framing element in pixels.</p>
        /// <p>Defaults to: <c>0</c></p></div></li><li><span>bottom</span> : <see cref="Number">Number</see> (optional)<div><p>The width of the bottom framing element in pixels.</p>
        /// <p>Defaults to: <c>0</c></p></div></li><li><span>left</span> : <see cref="Number">Number</see> (optional)<div><p>The width of the left framing element in pixels.</p>
        /// <p>Defaults to: <c>0</c></p></div></li><li><span>width</span> : <see cref="Number">Number</see> (optional)<div><p>The total width of the left and right framing elements in pixels.</p>
        /// <p>Defaults to: <c>0</c></p></div></li><li><span>height</span> : <see cref="Number">Number</see> (optional)<div><p>The total height of the top and right bottom elements in pixels.</p>
        /// <p>Defaults to: <c>0</c></p></div></li>
        /// </summary>
        public JsObject frameSize{get;set;}
        /// <summary>
        /// This object holds a key for any event that has a listener. The listener may be set
        /// directly on the instance, or on its class or a super class (via observe) or
        /// on the MVC EventBus. The values of this object are truthy
        /// (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
        /// of listeners. The value for an event is truthy if the event must be fired and is
        /// falsy if there is no need to fire the event.
        /// The intended use of this property is to avoid the expense of fireEvent calls when
        /// there are no listeners. This can be particularly helpful when one would otherwise
        /// have to call fireEvent hundreds or thousands of times. It is used like this:
        /// <code> if (this.hasListeners.foo) {
        /// this.fireEvent('foo', this, arg1);
        /// }
        /// </code>
        /// </summary>
        public JsObject hasListeners{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Component, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool isComponent{get;set;}
        /// <summary>
        /// true in this class to identify an object as an instantiated Observable, or subclass thereof.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool isObservable{get;set;}
        /// <summary>
        /// This is an internal flag that you use when creating custom components. By default this is set to true which means
        /// that every component gets a mask when it's disabled. Components like FieldContainer, FieldSet, Field, Button, Tab
        /// override this property to false since they want to implement custom disable logic.
        /// Defaults to: <c>true</c>
        /// </summary>
        public bool maskOnDisable{get;set;}
        /// <summary>
        /// This Component's owner Container (is set automatically
        /// when this Component is added to a Container).
        /// <strong>Note</strong>: to access items within the Container see <see cref="Ext.AbstractComponentConfig.itemId">itemId</see>.
        /// </summary>
        public Ext.container.Container ownerCt{get;set;}
        /// <summary>
        /// Indicates whether or not the component has been rendered.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool rendered{get;set;}
        /// <summary>
        /// Creates new Component.
        /// </summary>
        /// <param name="config"><p>Config object.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public AbstractComponent(object config=null){}
        /// <summary>
        /// Adds each argument passed to this method to the childEls array.
        /// </summary>
        public void addChildEls(params object[] args){}
        /// <summary>
        /// Adds a CSS class to the top level element representing this component.
        /// <p>This method has been <strong>deprecated</strong> since 4.1</p>
        /// <p>Use <see cref="Ext.AbstractComponent.addCls">addCls</see> instead.</p>
        /// </summary>
        /// <param name="cls"><p>The CSS class name to add</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>Returns the Component to allow method chaining.</p>
        /// </div>
        /// </returns>
        public Ext.Component addClass(object cls){return null;}
        /// <summary>
        /// Adds a CSS class to the top level element representing this component.
        /// </summary>
        /// <param name="cls"><p>The CSS class name to add</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>Returns the Component to allow method chaining.</p>
        /// </div>
        /// </returns>
        public Ext.Component addCls(object cls){return null;}
        /// <summary>
        /// Adds a cls to the uiCls array, which will also call addUIClsToElement and adds to all elements of this
        /// component.
        /// </summary>
        /// <param name="classes"><p>A string or an array of strings to add to the uiCls</p>
        /// </param>
        /// <param name="skip"><p>(Boolean) skip True to skip adding it to the class and do it later (via the return)</p>
        /// </param>
        public void addClsWithUI(object classes, object skip){}
        /// <summary>
        /// Adds the specified events to the list of events which this Observable may fire.
        /// </summary>
        /// <param name="eventNames"><p>Either an object with event names as properties with
        /// a value of <c>true</c>. For example:</p>
        /// <pre><code>this.addEvents({
        /// storeloaded: true,
        /// storecleared: true
        /// });
        /// </code></pre>
        /// <p>Or any number of event names as separate parameters. For example:</p>
        /// <pre><code>this.addEvents('storeloaded', 'storecleared');
        /// </code></pre>
        /// </param>
        public virtual void addEvents(object eventNames){}
        /// <summary>
        /// Sets up the focus listener on this Component's focusEl if it has one.
        /// Form Components which must implicitly participate in tabbing order usually have a naturally focusable
        /// element as their <see cref="Ext.AbstractComponent">focusEl</see>, and it is the DOM event of that recieving focus which drives
        /// the Component's onFocus handling, and the DOM event of it being blurred which drives the onBlur handling.
        /// If the <see cref="Ext.AbstractComponent">focusEl</see> is <b>not</b> naturally focusable, then the listeners are only added
        /// if the <see cref="Ext.FocusManager">FocusManager</see> is enabled.
        /// </summary>
        private void addFocusListener(){}
        /// <summary>
        /// Appends an event handler to this object.  For example:
        /// <code>myGridPanel.on("mouseover", this.onMouseOver, this);
        /// </code>
        /// The method also allows for a single argument to be passed which is a config object
        /// containing properties which specify multiple events. For example:
        /// <code>myGridPanel.on({
        /// cellClick: this.onCellClick,
        /// mouseover: this.onMouseOver,
        /// mouseout: this.onMouseOut,
        /// scope: this // Important. Ensure "this" is correct during handler execution
        /// });
        /// </code>
        /// One can also specify options for each event handler separately:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: this.onCellClick, scope: this, single: true},
        /// mouseover: {fn: panel.onMouseOver, scope: panel}
        /// });
        /// </code>
        /// <em>Names</em> of methods in a specified scope may also be used. Note that
        /// <c>scope</c> MUST be specified to use this option:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: 'onCellClick', scope: this, single: true},
        /// mouseover: {fn: 'onMouseOver', scope: panel}
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventName"><p>The name of the event to listen for.
        /// May also be an object who's property names are event names.</p>
        /// </param>
        /// <param name="fn"><p>The method the event invokes, or <em>if <c>scope</c> is specified, the </em>name* of the method within
        /// the specified <c>scope</c>.  Will be called with arguments
        /// given to <see cref="Ext.util.Observable.fireEvent">fireEvent</see> plus the <c>options</c> parameter described below.</p>
        /// </param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the handler function is
        /// executed. <strong>If omitted, defaults to the object which fired the event.</strong></p>
        /// </param>
        /// <param name="options"><p>An object containing handler configuration.</p>
        /// <p><strong>Note:</strong> Unlike in ExtJS 3.x, the options object will also be passed as the last
        /// argument to every event handler.</p>
        /// <p>This object may contain any of the following properties:</p>
        /// <ul><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope (<c>this</c> reference) in which the handler function is executed. <strong>If omitted,
        /// defaults to the object which fired the event.</strong></p>
        /// </div></li><li><span>delay</span> : <see cref="Number">Number</see><div><p>The number of milliseconds to delay the invocation of the handler after the event fires.</p>
        /// </div></li><li><span>single</span> : <see cref="bool">Boolean</see><div><p>True to add a handler to handle just the next firing of the event, and then remove itself.</p>
        /// </div></li><li><span>buffer</span> : <see cref="Number">Number</see><div><p>Causes the handler to be scheduled to run in an <see cref="Ext.util.DelayedTask">Ext.util.DelayedTask</see> delayed
        /// by the specified number of milliseconds. If the event fires again within that time,
        /// the original handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p>
        /// </div></li><li><span>target</span> : <see cref="Ext.util.Observable">Ext.util.Observable</see><div><p>Only call the handler if the event was fired on the target Observable, <em>not</em> if the event
        /// was bubbled up from a child Observable.</p>
        /// </div></li><li><span>element</span> : <see cref="String">String</see><div><p><strong>This option is only valid for listeners bound to <see cref="Ext.Component">Components</see>.</strong>
        /// The name of a Component property which references an element to add a listener to.</p>
        /// <p>  This option is useful during Component construction to add DOM event listeners to elements of
        /// <see cref="Ext.Component">Components</see> which will exist only after the Component is rendered.
        /// For example, to add a click listener to a Panel's body:</p>
        /// <pre><code>  new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'The title',
        /// listeners: {
        /// click: this.handlePanelClick,
        /// element: 'body'
        /// }
        /// });
        /// </code></pre>
        /// <p><strong>Combining Options</strong></p>
        /// <p>Using the options argument, it is possible to combine different types of listeners:</p>
        /// <p>A delayed, one-time listener.</p>
        /// <pre><code>myPanel.on('hide', this.handleClick, this, {
        /// single: true,
        /// delay: 100
        /// });
        /// </code></pre>
        /// </div></li></ul></param>
        public virtual void addListener(object eventName, System.Delegate fn=null, object scope=null, object options=null){}
        /// <summary>
        /// Adds listeners to any Observable object (or Ext.Element) which are automatically removed when this Component is
        /// destroyed.
        /// </summary>
        /// <param name="item"><p>The item to which to add a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        /// <param name="opt"><p>If the <c>ename</c> parameter was an event name, this is the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> options.</p>
        /// </param>
        public virtual void addManagedListener(object item, object ename, System.Delegate fn=null, object scope=null, object opt=null){}
        /// <summary>
        /// Save a property to the given state object if it is not its default or configured
        /// value.
        /// </summary>
        /// <param name="state"><p>The state object</p>
        /// </param>
        /// <param name="propName"><p>The name of the property on this object to save.</p>
        /// </param>
        /// <param name="value"><p>The value of the state property (defaults to <c>this[propName]</c>).</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>The state object or a new object if state was null and the property
        /// was saved.</p>
        /// </div>
        /// </returns>
        protected bool addPropertyToState(object state, JsString propName, object value=null){return false;}
        /// <summary>
        /// Add events that will trigger the state to be saved. If the first argument is an
        /// array, each element of that array is the name of a state event. Otherwise, each
        /// argument passed to this method is the name of a state event.
        /// </summary>
        /// <param name="events"><p>The event name or an array of event names.</p>
        /// </param>
        public virtual void addStateEvents(object events){}
        /// <summary>
        /// Method which adds a specified UI + uiCls to the components element. Can be overridden to remove the UI from more
        /// than just the components element.
        /// </summary>
        /// <param name="ui"><p>The UI to remove from the element</p>
        /// </param>
        public void addUIClsToElement(JsString ui){}
        /// <summary>
        /// Method which adds a specified UI to the components element.
        /// </summary>
        private void addUIToElement(){}
        /// <summary>
        /// Called by the layout system after the Component has been layed out.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="width"><p>The width that was set</p>
        /// </param>
        /// <param name="height"><p>The height that was set</p>
        /// </param>
        /// <param name="oldWidth"><p>The old width. <c>undefined</c> if this was the initial layout.</p>
        /// </param>
        /// <param name="oldHeight"><p>The old height. <c>undefined</c> if this was the initial layout.</p>
        /// </param>
        protected virtual void afterComponentLayout(JsNumber width, JsNumber height, JsNumber oldWidth, JsNumber oldHeight){}
        /// <summary>
        /// Allows addition of behavior after rendering is complete. At this stage the Components Element
        /// will have been styled according to the configuration, will have had any configured CSS class
        /// names added, and will be in the configured visibility and the configured enable state.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        public virtual void afterRender(){}
        /// <summary>
        /// Template method called after a Component has been positioned.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="x">
        /// </param>
        /// <param name="y">
        /// </param>
        protected virtual void afterSetPosition(JsNumber x, JsNumber y){}
        /// <summary>
        /// Performs custom animation on this object.
        /// This method is applicable to both the <see cref="Ext.Component">Component</see> class and the <see cref="Ext.draw.Sprite">Sprite</see>
        /// class. It performs animated transitions of certain properties of this object over a specified timeline.
        /// </summary>
        /// <param name="config"><p>Configuration for <see cref="Ext.fx.Anim">Ext.fx.Anim</see>.
        /// Note that the <see cref="Ext.fx.AnimConfig.to">to</see> config is required.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public virtual object animate(object config){return null;}
        /// <summary>
        /// Sets references to elements inside the component.
        /// </summary>
        /// <param name="el">
        /// </param>
        /// <param name="id">
        /// </param>
        public virtual void applyChildEls(object el, object id){}
        /// <summary>
        /// Sets references to elements inside the component. This applies renderSelectors
        /// as well as childEls.
        /// </summary>
        public virtual void applyRenderSelectors(){}
        /// <summary>
        /// Applies the state to the object. This should be overridden in subclasses to do
        /// more complex state operations. By default it applies the state properties onto
        /// the current object.
        /// </summary>
        /// <param name="state"><p>The state</p>
        /// </param>
        public virtual void applyState(object state){}
        /// <summary>
        /// Occurs before componentLayout is run. Returning false from this method will prevent the componentLayout from
        /// being executed.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="adjWidth"><p>The box-adjusted width that was set</p>
        /// </param>
        /// <param name="adjHeight"><p>The box-adjusted height that was set</p>
        /// </param>
        protected virtual void beforeComponentLayout(JsNumber adjWidth, JsNumber adjHeight){}
        /// <summary>
        /// Invoked before the Component is destroyed.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        protected virtual void beforeDestroy(){}
        /// <summary>
        /// Template method called before a Component is positioned.
        /// </summary>
        /// <param name="x">
        /// </param>
        /// <param name="y">
        /// </param>
        /// <param name="animate">
        /// </param>
        private void beforeSetPosition(object x, object y, object animate){}
        /// <summary>
        /// Cancels layout of a component.
        /// </summary>
        /// <param name="comp">
        /// </param>
        public void cancelLayout(Ext.Component comp){}
        /// <summary>
        /// Removes all listeners for this object including the managed listeners
        /// </summary>
        public virtual void clearListeners(){}
        /// <summary>
        /// Removes all managed listeners for this object.
        /// </summary>
        public virtual void clearManagedListeners(){}
        /// <summary>
        /// Returns an array of fully constructed plugin instances. This converts any configs into their
        /// appropriate instances.
        /// It does not mutate the plugins array. It creates a new array.
        /// This is borrowed by <see cref="Ext.grid.Lockable">Lockable</see> which clones and distributes Plugins
        /// to both child grids of a locking grid, so must keep to that contract.
        /// </summary>
        private void constructPlugins(){}
        /// <summary>
        /// Continue to fire event.
        /// </summary>
        /// <param name="eventName">
        /// </param>
        /// <param name="args">
        /// </param>
        /// <param name="bubbles">
        /// </param>
        public virtual void continueFireEvent(JsString eventName, object args=null, object bubbles=null){}
        /// <summary>
        /// This method converts an "{x: x, y: y}" object to a "{left: x+'px', top: y+'px'}" object.
        /// The returned object contains the styles to set to effect the position. This is
        /// overridden in RTL mode to be "{right: x, top: y}".
        /// </summary>
        /// <param name="pos">
        /// </param>
        /// <param name="withUnits">
        /// </param>
        private void convertPosition(object pos, object withUnits){}
        /// <summary>
        /// Creates an event handling function which refires the event from this object as the passed event name.
        /// </summary>
        /// <param name="newName">
        /// </param>
        /// <param name="beginEnd"><p>The caller can specify on which indices to slice</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Function">Function</see></span><div>
        /// </div>
        /// </returns>
        public virtual System.Delegate createRelayer(object newName, object beginEnd=null){return null;}
        /// <summary>
        /// Disable the component.
        /// </summary>
        /// <param name="silent"><p>Passing true will supress the 'disable' event from being fired.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        public void disable(object silent=null){}
        /// <summary>
        /// Called from the selected frame generation template to insert this Component's inner structure inside the framing structure.
        /// When framing is used, a selected frame generation template is used as the primary template of the #getElConfig instead
        /// of the configured <see cref="Ext.AbstractComponentConfig.renderTpl">renderTpl</see>. The renderTpl is invoked by this method which is injected into the framing template.
        /// </summary>
        /// <param name="out">
        /// </param>
        /// <param name="values">
        /// </param>
        public virtual void doApplyRenderTpl(object @out, object values){}
        /// <summary>
        /// Handles autoRender.
        /// Floating Components may have an ownerCt. If they are asking to be constrained, constrain them within that
        /// ownerCt, and have their z-index managed locally. Floating Components are always rendered to document.body
        /// </summary>
        public virtual void doAutoRender(){}
        /// <summary>
        /// This method needs to be called whenever you change something on this component that requires the Component's
        /// layout to be recalculated.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.container.Container">Ext.container.Container</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.container.Container doComponentLayout(){return null;}
        /// <summary>
        /// Enable the component
        /// </summary>
        /// <param name="silent"><p>Passing true will supress the 'enable' event from being fired.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        public void enable(object silent=null){}
        /// <summary>
        /// Enables events fired by this Observable to bubble up an owner hierarchy by calling this.getBubbleTarget() if
        /// present. There is no implementation in the Observable base class.
        /// This is commonly used by Ext.Components to bubble events to owner Containers.
        /// See <see cref="Ext.Component.getBubbleTarget">Ext.Component.getBubbleTarget</see>. The default implementation in <see cref="Ext.Component">Ext.Component</see> returns the
        /// Component's immediate owner. But if a known target is required, this can be overridden to access the
        /// required target more quickly.
        /// Example:
        /// <code><see cref="Ext.ExtContext.override">Ext.override</see>(<see cref="Ext.form.field.Base">Ext.form.field.Base</see>, {
        /// //  Add functionality to Field's initComponent to enable the change event to bubble
        /// initComponent : <see cref="Ext.Function.createSequence">Ext.Function.createSequence</see>(Ext.form.field.Base.prototype.initComponent, function() {
        /// this.enableBubble('change');
        /// }),
        /// //  We know that we want Field's events to bubble directly to the FormPanel.
        /// getBubbleTarget : function() {
        /// if (!this.formPanel) {
        /// this.formPanel = this.findParentByType('form');
        /// }
        /// return this.formPanel;
        /// }
        /// });
        /// var myForm = new Ext.formPanel({
        /// title: 'User Details',
        /// items: [{
        /// ...
        /// }],
        /// listeners: {
        /// change: function() {
        /// // Title goes red if form has been modified.
        /// myForm.header.setStyle('color', 'red');
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventNames"><p>The event name to bubble, or an Array of event names.</p>
        /// </param>
        public virtual void enableBubble(object eventNames){}
        /// <summary>
        /// Ensures that this component is attached to document.body. If the component was
        /// rendered to Ext.getDetachedBody, then it will be appended to document.body.
        /// Any configured position is also restored.
        /// </summary>
        /// <param name="runLayout"><p>True to run the component's layout.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        public virtual void ensureAttachedToBody(object runLayout=null){}
        /// <summary>
        /// This method visits the rendered component tree in a "top-down" order. That is, this
        /// code runs on a parent component before running on a child. This method calls the
        /// onRender method of each component.
        /// </summary>
        /// <param name="containerIdx"><p>The index into the Container items of this Component.</p>
        /// </param>
        public virtual void finishRender(JsNumber containerIdx){}
        /// <summary>
        /// Fires the specified event with the passed parameters (minus the event name, plus the options object passed
        /// to addListener).
        /// An event may be set to bubble up an Observable parent hierarchy (See <see cref="Ext.Component.getBubbleTarget">Ext.Component.getBubbleTarget</see>) by
        /// calling <see cref="Ext.util.Observable.enableBubble">enableBubble</see>.
        /// </summary>
        /// <param name="eventName"><p>The name of the event to fire.</p>
        /// </param>
        /// <param name="args"><p>Variable number of parameters are passed to handlers.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>returns false if any of the handlers return false otherwise it returns true.</p>
        /// </div>
        /// </returns>
        public virtual bool fireEvent(JsString eventName, params object[] args){return false;}
        /// <summary>
        /// Forces this component to redo its componentLayout.
        /// <p>This method has been <strong>deprecated</strong> since 4.1.0</p>
        /// <p>Use <see cref="Ext.AbstractComponent.updateLayout">updateLayout</see> instead.</p>
        /// </summary>
        public void forceComponentLayout(){}
        /// <summary>
        /// Returns the current animation if this object has any effects actively running or queued, else returns false.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.fx.Anim">Ext.fx.Anim</see>/<see cref="bool">Boolean</see></span><div><p>Anim if element has active effects, else false</p>
        /// </div>
        /// </returns>
        public virtual object getActiveAnimation(){return null;}
        /// <summary>
        /// </summary>
        private void getAutoId(){}
        /// <summary>
        /// Gets the bubbling parent for an Observable
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.util.Observable">Ext.util.Observable</see></span><div><p>The bubble parent. null is returned if no bubble target exists</p>
        /// </div>
        /// </returns>
        public virtual Ext.util.Observable getBubbleParent(){return null;}
        /// <summary>
        /// Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.container.Container">Ext.container.Container</see></span><div><p>the Container which owns this Component.</p>
        /// </div>
        /// </returns>
        public Ext.container.Container getBubbleTarget(){return null;}
        /// <summary>
        /// Retrieves the top level element representing this component.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.dom.Element">Ext.dom.Element</see></span><div>
        /// </div>
        /// </returns>
        public Ext.dom.Element getEl(){return null;}
        /// <summary>
        /// Returns the focus holder element associated with this Component. At the Component base class level, this function returns undefined.
        /// Subclasses which use embedded focusable elements (such as Window, Field and Button) should override this for use by the <see cref="Ext.AbstractComponentEvents.focus">focus</see> method.
        /// Containers which need to participate in the <see cref="Ext.FocusManager">FocusManager</see>'s navigation and Container focusing scheme also
        /// need to return a focusEl, although focus is only listened for in this case if the <see cref="Ext.FocusManager">FocusManager</see> is <see cref="Ext.FocusManager.enable">enable</see>d.
        /// </summary>
        private void getFocusEl(){}
        /// <summary>
        /// On render, reads an encoded style attribute, "background-position" from the style of this Component's element.
        /// This information is memoized based upon the CSS class name of this Component's element.
        /// Because child Components are rendered as textual HTML as part of the topmost Container, a dummy div is inserted
        /// into the document to receive the document element's CSS class name, and therefore style attributes.
        /// </summary>
        public virtual void getFrameInfo(){}
        /// <summary>
        /// Parameters<li><span>table</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="table">
        /// </param>
        public virtual void getFrameTpl(object table){}
        /// <summary>
        /// Gets the current height of the component's underlying element.
        /// </summary>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div>
        /// </div>
        /// </returns>
        public JsNumber getHeight(){return null;}
        /// <summary>
        /// Retrieves the id of this component. Will autogenerate an id if one has not already been set.
        /// </summary>
        /// <returns>
        /// <span><see cref="String">String</see></span><div>
        /// </div>
        /// </returns>
        public JsString getId(){return null;}
        /// <summary>
        /// This function takes the position argument passed to onRender and returns a
        /// DOM element that you can use in the insertBefore.
        /// </summary>
        /// <param name="position"><p>Index, element id or element you want
        /// to put this component before.</p>
        /// </param>
        /// <returns>
        /// <span>HTMLElement</span><div><p>DOM element that you can use in the insertBefore</p>
        /// </div>
        /// </returns>
        public virtual JsObject getInsertPosition(object position){return null;}
        /// <summary>
        /// Returns the value of itemId assigned to this component, or when that
        /// is not set, returns the value of id.
        /// </summary>
        /// <returns>
        /// <span><see cref="String">String</see></span><div>
        /// </div>
        /// </returns>
        public JsString getItemId(){return null;}
        /// <summary>
        /// Gets the Ext.ComponentLoader for this Component.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.ComponentLoader">Ext.ComponentLoader</see></span><div><p>The loader instance, null if it doesn't exist.</p>
        /// </div>
        /// </returns>
        public ComponentLoader getLoader(){return null;}
        /// <summary>
        /// Returns the CSS style object which will set the Component's scroll styles. This must be applied
        /// to the target element.
        /// </summary>
        private void getOverflowStyle(){}
        /// <summary>
        /// Retrieves a plugin by its pluginId which has been bound to this component.
        /// </summary>
        /// <param name="pluginId">
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.AbstractPlugin">Ext.AbstractPlugin</see></span><div><p>plugin instance.</p>
        /// </div>
        /// </returns>
        public AbstractPlugin getPlugin(JsString pluginId){return null;}
        /// <summary>
        /// Gets the current size of the component's underlying element.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>An object containing the element's size {width: (element width), height: (element height)}</p>
        /// </div>
        /// </returns>
        public object getSize(){return null;}
        /// <summary>
        /// Returns an object that describes how this component's width and height are managed.
        /// All of these objects are shared and should not be modified.
        /// </summary>
        /// <param name="ownerCtSizeModel">
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>The size model for this component.</p>
        /// <ul><li><span>width</span> : <see cref="Ext.layout.SizeModel">Ext.layout.SizeModel</see><div><p>The <see cref="Ext.layout.SizeModel">size model</see>
        /// for the width.</p>
        /// </div></li><li><span>height</span> : <see cref="Ext.layout.SizeModel">Ext.layout.SizeModel</see><div><p>The <see cref="Ext.layout.SizeModel">size model</see>
        /// for the height.</p>
        /// </div></li></ul></div>
        /// </returns>
        public object getSizeModel(object ownerCtSizeModel){return null;}
        /// <summary>
        /// The supplied default state gathering method for the AbstractComponent class.
        /// This method returns dimension settings such as <c>flex</c>, <c>anchor</c>, <c>width</c> and <c>height</c> along with <c>collapsed</c>
        /// state.
        /// Subclasses which implement more complex state should call the superclass's implementation, and apply their state
        /// to the result if this basic state is to be saved.
        /// Note that Component state will only be saved if the Component has a <see cref="Ext.AbstractComponentConfig.stateId">stateId</see> and there as a StateProvider
        /// configured for the document.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div>
        /// </div>
        /// </returns>
        public virtual object getState(){return null;}
        /// <summary>
        /// Gets the state id for this object.
        /// </summary>
        /// <returns>
        /// <span><see cref="String">String</see></span><div><p>The 'stateId' or the implicit 'id' specified by component configuration.</p>
        /// </div>
        /// </returns>
        public virtual JsString getStateId(){return null;}
        /// <summary>
        /// Returns an offscreen div with the same class name as the element this is being rendered.
        /// This is because child item rendering takes place in a detached div which, being not part of the document, has no styling.
        /// </summary>
        /// <param name="cls">
        /// </param>
        public virtual void getStyleProxy(object cls){}
        /// <summary>
        /// This is used to determine where to insert the 'html', 'contentEl' and 'items' in this component.
        /// </summary>
        private void getTargetEl(){}
        /// <summary>
        /// Parameters<li><span>name</span> : <see cref="Object">Object</see><div>
        /// </div></li>
        /// </summary>
        /// <param name="name">
        /// </param>
        private void getTpl(object name){}
        /// <summary>
        /// Gets the current width of the component's underlying element.
        /// </summary>
        /// <returns>
        /// <span><see cref="Number">Number</see></span><div>
        /// </div>
        /// </returns>
        public JsNumber getWidth(){return null;}
        /// <summary>
        /// Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all available xtypes, see the
        /// Ext.Component header.
        /// <strong>If using your own subclasses, be aware that a Component must register its own xtype to participate in
        /// determination of inherited xtypes.</strong>
        /// Example usage:
        /// <code>var t = new <see cref="Ext.form.field.Text">Ext.form.field.Text</see>();
        /// alert(t.getXTypes());  // alerts 'component/field/textfield'
        /// </code>
        /// </summary>
        /// <returns>
        /// <span><see cref="String">String</see></span><div><p>The xtype hierarchy string</p>
        /// </div>
        /// </returns>
        public JsString getXTypes(){return null;}
        /// <summary>
        /// Returns the current animation if this object has any effects actively running or queued, else returns false.
        /// <p>This method has been <strong>deprecated</strong> since 4.0</p>
        /// <p>Replaced by <see cref="Ext.util.Animate.getActiveAnimation">getActiveAnimation</see></p>
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.fx.Anim">Ext.fx.Anim</see>/<see cref="bool">Boolean</see></span><div><p>Anim if element has active effects, else false</p>
        /// </div>
        /// </returns>
        public virtual object hasActiveFx(){return null;}
        /// <summary>
        /// Checks if the specified CSS class exists on this element's DOM node.
        /// </summary>
        /// <param name="className"><p>The CSS class to check for</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if the class exists, else false</p>
        /// </div>
        /// </returns>
        public bool hasCls(JsString className){return false;}
        /// <summary>
        /// Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
        /// indicates whether the event needs firing or not.
        /// </summary>
        /// <param name="eventName"><p>The name of the event to check for</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p><c>true</c> if the event is being listened for or bubbles, else <c>false</c></p>
        /// </div>
        /// </returns>
        public virtual bool hasListener(JsString eventName){return false;}
        /// <summary>
        /// Checks if there is currently a specified uiCls
        /// </summary>
        /// <param name="cls"><p>The cls to check</p>
        /// </param>
        public void hasUICls(JsString cls){}
        /// <summary>
        /// </summary>
        public virtual void initFrame(){}
        /// <summary>
        /// Initialized the renderData to be used when rendering the renderTpl.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>Object with keys and values that are going to be applied to the renderTpl</p>
        /// </div>
        /// </returns>
        public virtual object initRenderData(){return null;}
        /// <summary>
        /// Initializes the renderTpl.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.XTemplate">Ext.XTemplate</see></span><div><p>The renderTpl XTemplate instance.</p>
        /// </div>
        /// </returns>
        public virtual XTemplate initRenderTpl(){return null;}
        /// <summary>
        /// Initializes the state of the object upon construction.
        /// </summary>
        public virtual void initState(){}
        /// <summary>
        /// Converts style definitions to String.
        /// </summary>
        /// <param name="targetEl">
        /// </param>
        /// <returns>
        /// <span><see cref="String">String</see></span><div><p>A CSS style string with style, padding, margin and border.</p>
        /// </div>
        /// </returns>
        private JsString initStyles(object targetEl){return null;}
        /// <summary>
        /// Tests whether this Component matches the selector string.
        /// </summary>
        /// <param name="selector"><p>The selector string to test against.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if this Component matches the selector.</p>
        /// </div>
        /// </returns>
        public bool @is(JsString selector){return false;}
        /// <summary>
        /// Determines whether this component is the descendant of a particular container.
        /// </summary>
        /// <param name="container">
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if it is.</p>
        /// </div>
        /// </returns>
        public bool isDescendantOf(Ext.container.Container container){return false;}
        /// <summary>
        /// Method to determine whether this Component is currently disabled.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>the disabled state of this Component.</p>
        /// </div>
        /// </returns>
        public bool isDisabled(){return false;}
        /// <summary>
        /// Method to determine whether this Component is draggable.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>the draggable state of this component.</p>
        /// </div>
        /// </returns>
        public bool isDraggable(){return false;}
        /// <summary>
        /// Method to determine whether this Component is droppable.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>the droppable state of this component.</p>
        /// </div>
        /// </returns>
        public bool isDroppable(){return false;}
        /// <summary>
        /// Method to determine whether this Component is floating.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>the floating state of this component.</p>
        /// </div>
        /// </returns>
        public bool isFloating(){return false;}
        /// <summary>
        /// Method to determine whether this Component is currently set to hidden.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>the hidden state of this Component.</p>
        /// </div>
        /// </returns>
        public bool isHidden(){return false;}
        /// <summary>
        /// Determines whether this Component is the root of a layout. This returns true if
        /// this component can run its layout without assistance from or impact on its owner.
        /// If this component cannot run its layout given these restrictions, false is returned
        /// and its owner will be considered as the next candidate for the layout root.
        /// Setting the <see cref="Ext.AbstractComponent._isLayoutRoot">_isLayoutRoot</see> property to <c>true</c> causes this method to always
        /// return <c>true</c>. This may be useful when updating a layout of a Container which shrink
        /// wraps content, and you know that it will not change size, and so can safely be the
        /// topmost participant in the layout run.
        /// </summary>
        protected void isLayoutRoot(){}
        /// <summary>
        /// Returns true if layout is suspended for this component. This can come from direct
        /// suspension of this component's layout activity (Ext.Container.suspendLayout) or if one
        /// of this component's containers is suspended.
        /// </summary>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True layout of this component is suspended.</p>
        /// </div>
        /// </returns>
        public bool isLayoutSuspended(){return false;}
        /// <summary>
        /// Returns true if this component is visible.
        /// </summary>
        /// <param name="deep"><p>Pass <c>true</c> to interrogate the visibility status of all parent Containers to
        /// determine whether this Component is truly visible to the user.</p>
        /// <p>Generally, to determine whether a Component is hidden, the no argument form is needed. For example when creating
        /// dynamically laid out UIs in a hidden Container before showing them.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if this component is visible, false otherwise.</p>
        /// </div>
        /// </returns>
        public bool isVisible(object deep=null){return false;}
        /// <summary>
        /// Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
        /// from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
        /// <strong>If using your own subclasses, be aware that a Component must register its own xtype to participate in
        /// determination of inherited xtypes.</strong>
        /// For a list of all available xtypes, see the <see cref="Ext.Component">Ext.Component</see> header.
        /// Example usage:
        /// <code>var t = new <see cref="Ext.form.field.Text">Ext.form.field.Text</see>();
        /// var isText = t.isXType('textfield');        // true
        /// var isBoxSubclass = t.isXType('field');       // true, descended from <see cref="Ext.form.field.Base">Ext.form.field.Base</see>
        /// var isBoxInstance = t.isXType('field', true); // false, not a direct <see cref="Ext.form.field.Base">Ext.form.field.Base</see> instance
        /// </code>
        /// </summary>
        /// <param name="xtype"><p>The xtype to check for this Component</p>
        /// </param>
        /// <param name="shallow"><p>True to check whether this Component is directly of the specified xtype, false to
        /// check whether this Component is descended from the xtype.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if this component descends from the specified xtype, false otherwise.</p>
        /// </div>
        /// </returns>
        public bool isXType(JsString xtype, object shallow=null){return false;}
        /// <summary>
        /// Shorthand for addManagedListener.
        /// Adds listeners to any Observable object (or <see cref="Ext.dom.Element">Ext.Element</see>) which are automatically removed when this Component is
        /// destroyed.
        /// </summary>
        /// <param name="item"><p>The item to which to add a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        /// <param name="opt"><p>If the <c>ename</c> parameter was an event name, this is the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> options.</p>
        /// </param>
        public virtual void mon(object item, object ename, System.Delegate fn=null, object scope=null, object opt=null){}
        /// <summary>
        /// Shorthand for removeManagedListener.
        /// Removes listeners that were added by the <see cref="Ext.util.Observable.mon">mon</see> method.
        /// </summary>
        /// <param name="item"><p>The item from which to remove a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        public virtual void mun(object item, object ename, System.Delegate fn=null, object scope=null){}
        /// <summary>
        /// Returns the next node in the Component tree in tree traversal order.
        /// Note that this is not limited to siblings, and if invoked upon a node with no matching siblings, will walk the
        /// tree to attempt to find a match. Contrast with <see cref="Ext.AbstractComponent.nextSibling">nextSibling</see>.
        /// </summary>
        /// <param name="selector"><p>A <see cref="Ext.ComponentQuery">ComponentQuery</see> selector to filter the following nodes.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>The next node (or the next node which matches the selector).
        /// Returns null if there is no matching node.</p>
        /// </div>
        /// </returns>
        public Ext.Component nextNode(object selector=null){return null;}
        /// <summary>
        /// Returns the next sibling of this Component.
        /// Optionally selects the next sibling which matches the passed <see cref="Ext.ComponentQuery">ComponentQuery</see> selector.
        /// May also be refered to as <strong><c>next()</c></strong>
        /// Note that this is limited to siblings, and if no siblings of the item match, <c>null</c> is returned. Contrast with
        /// <see cref="Ext.AbstractComponent.nextNode">nextNode</see>
        /// </summary>
        /// <param name="selector"><p>A <see cref="Ext.ComponentQuery">ComponentQuery</see> selector to filter the following items.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>The next sibling (or the next sibling which matches the selector).
        /// Returns null if there is no matching sibling.</p>
        /// </div>
        /// </returns>
        public Ext.Component nextSibling(object selector=null){return null;}
        /// <summary>
        /// Shorthand for addListener.
        /// Appends an event handler to this object.  For example:
        /// <code>myGridPanel.on("mouseover", this.onMouseOver, this);
        /// </code>
        /// The method also allows for a single argument to be passed which is a config object
        /// containing properties which specify multiple events. For example:
        /// <code>myGridPanel.on({
        /// cellClick: this.onCellClick,
        /// mouseover: this.onMouseOver,
        /// mouseout: this.onMouseOut,
        /// scope: this // Important. Ensure "this" is correct during handler execution
        /// });
        /// </code>
        /// One can also specify options for each event handler separately:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: this.onCellClick, scope: this, single: true},
        /// mouseover: {fn: panel.onMouseOver, scope: panel}
        /// });
        /// </code>
        /// <em>Names</em> of methods in a specified scope may also be used. Note that
        /// <c>scope</c> MUST be specified to use this option:
        /// <code>myGridPanel.on({
        /// cellClick: {fn: 'onCellClick', scope: this, single: true},
        /// mouseover: {fn: 'onMouseOver', scope: panel}
        /// });
        /// </code>
        /// </summary>
        /// <param name="eventName"><p>The name of the event to listen for.
        /// May also be an object who's property names are event names.</p>
        /// </param>
        /// <param name="fn"><p>The method the event invokes, or <em>if <c>scope</c> is specified, the </em>name* of the method within
        /// the specified <c>scope</c>.  Will be called with arguments
        /// given to <see cref="Ext.util.Observable.fireEvent">fireEvent</see> plus the <c>options</c> parameter described below.</p>
        /// </param>
        /// <param name="scope"><p>The scope (<c>this</c> reference) in which the handler function is
        /// executed. <strong>If omitted, defaults to the object which fired the event.</strong></p>
        /// </param>
        /// <param name="options"><p>An object containing handler configuration.</p>
        /// <p><strong>Note:</strong> Unlike in ExtJS 3.x, the options object will also be passed as the last
        /// argument to every event handler.</p>
        /// <p>This object may contain any of the following properties:</p>
        /// <ul><li><span>scope</span> : <see cref="Object">Object</see><div><p>The scope (<c>this</c> reference) in which the handler function is executed. <strong>If omitted,
        /// defaults to the object which fired the event.</strong></p>
        /// </div></li><li><span>delay</span> : <see cref="Number">Number</see><div><p>The number of milliseconds to delay the invocation of the handler after the event fires.</p>
        /// </div></li><li><span>single</span> : <see cref="bool">Boolean</see><div><p>True to add a handler to handle just the next firing of the event, and then remove itself.</p>
        /// </div></li><li><span>buffer</span> : <see cref="Number">Number</see><div><p>Causes the handler to be scheduled to run in an <see cref="Ext.util.DelayedTask">Ext.util.DelayedTask</see> delayed
        /// by the specified number of milliseconds. If the event fires again within that time,
        /// the original handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p>
        /// </div></li><li><span>target</span> : <see cref="Ext.util.Observable">Ext.util.Observable</see><div><p>Only call the handler if the event was fired on the target Observable, <em>not</em> if the event
        /// was bubbled up from a child Observable.</p>
        /// </div></li><li><span>element</span> : <see cref="String">String</see><div><p><strong>This option is only valid for listeners bound to <see cref="Ext.Component">Components</see>.</strong>
        /// The name of a Component property which references an element to add a listener to.</p>
        /// <p>  This option is useful during Component construction to add DOM event listeners to elements of
        /// <see cref="Ext.Component">Components</see> which will exist only after the Component is rendered.
        /// For example, to add a click listener to a Panel's body:</p>
        /// <pre><code>  new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'The title',
        /// listeners: {
        /// click: this.handlePanelClick,
        /// element: 'body'
        /// }
        /// });
        /// </code></pre>
        /// <p><strong>Combining Options</strong></p>
        /// <p>Using the options argument, it is possible to combine different types of listeners:</p>
        /// <p>A delayed, one-time listener.</p>
        /// <pre><code>myPanel.on('hide', this.handleClick, this, {
        /// single: true,
        /// delay: 100
        /// });
        /// </code></pre>
        /// </div></li></ul></param>
        public virtual void on(object eventName, System.Delegate fn=null, object scope=null, object options=null){}
        /// <summary>
        /// Method to manage awareness of when components are added to their
        /// respective Container, firing an added event. References are
        /// established at add time rather than at render time.
        /// Allows addition of behavior when a Component is added to a
        /// Container. At this stage, the Component is in the parent
        /// Container's collection of child items. After calling the
        /// superclass's onAdded, the ownerCt reference will be present,
        /// and if configured with a ref, the refOwner will be set.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="container"><p>Container which holds the component</p>
        /// </param>
        /// <param name="pos"><p>Position at which the component was added</p>
        /// </param>
        protected virtual void onAdded(Ext.container.Container container, JsNumber pos){}
        /// <summary>
        /// Allows addition of behavior to the disable operation.
        /// After calling the superclasss onDisable, the Component will be disabled.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        protected virtual void onDisable(){}
        /// <summary>
        /// Allows addition of behavior to the enable operation.
        /// After calling the superclasss onEnable, the Component will be enabled.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        protected virtual void onEnable(){}
        /// <summary>
        /// Called after the component is moved, this method is empty by default but can be implemented by any
        /// subclass that needs to perform custom logic after a move occurs.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="x"><p>The new x position</p>
        /// </param>
        /// <param name="y"><p>The new y position</p>
        /// </param>
        protected virtual void onPosition(JsNumber x, JsNumber y){}
        /// <summary>
        /// Method to manage awareness of when components are removed from their
        /// respective Container, firing a removed event. References are properly
        /// cleaned up after removing a component from its owning container.
        /// Allows addition of behavior when a Component is removed from
        /// its parent Container. At this stage, the Component has been
        /// removed from its parent Container's collection of child items,
        /// but has not been destroyed (It will be destroyed if the parent
        /// Container's autoDestroy is true, or if the remove call was
        /// passed a truthy second parameter). After calling the
        /// superclass's onRemoved, the ownerCt and the refOwner will not
        /// be present.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="destroying"><p>Will be passed as true if the Container performing the remove operation will delete this
        /// Component upon remove.</p>
        /// </param>
        protected virtual void onRemoved(bool destroying){}
        /// <summary>
        /// Template method called when this Component's DOM structure is created.
        /// At this point, this Component's (and all descendants') DOM structure <em>exists</em> but it has not
        /// been layed out (positioned and sized).
        /// Subclasses which override this to gain access to the structure at render time should
        /// call the parent class's method before attempting to access any child elements of the Component.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        /// <param name="parentNode"><p>The parent Element in which this Component's encapsulating element is contained.</p>
        /// </param>
        /// <param name="containerIdx"><p>The index within the parent Container's child collection of this Component.</p>
        /// </param>
        public virtual void onRender(Ext.dom.Element parentNode, JsNumber containerIdx){}
        /// <summary>
        /// Allows addition of behavior to the resize operation.
        /// Called when Ext.resizer.Resizer#drag event is fired.
        /// <p>This is a <i>template method</i>.
        /// a hook into the functionality of this class.
        /// Feel free to override it in child classes.</p>
        /// </summary>
        protected virtual void onResize(){}
        /// <summary>
        /// This method is called when any of the stateEvents are fired.
        /// </summary>
        public virtual void onStateChange(){}
        /// <summary>
        /// Prepares a given class for observable instances. This method is called when a
        /// class derives from this class or uses this class as a mixin.
        /// </summary>
        /// <param name="T"><p>The class constructor to prepare.</p>
        /// </param>
        public virtual void prepareClass(System.Delegate T){}
        /// <summary>
        /// Returns the previous node in the Component tree in tree traversal order.
        /// Note that this is not limited to siblings, and if invoked upon a node with no matching siblings, will walk the
        /// tree in reverse order to attempt to find a match. Contrast with <see cref="Ext.AbstractComponent.previousSibling">previousSibling</see>.
        /// </summary>
        /// <param name="selector"><p>A <see cref="Ext.ComponentQuery">ComponentQuery</see> selector to filter the preceding nodes.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>The previous node (or the previous node which matches the selector).
        /// Returns null if there is no matching node.</p>
        /// </div>
        /// </returns>
        public Ext.Component previousNode(object selector=null){return null;}
        /// <summary>
        /// Returns the previous sibling of this Component.
        /// Optionally selects the previous sibling which matches the passed <see cref="Ext.ComponentQuery">ComponentQuery</see>
        /// selector.
        /// May also be refered to as <strong><c>prev()</c></strong>
        /// Note that this is limited to siblings, and if no siblings of the item match, <c>null</c> is returned. Contrast with
        /// <see cref="Ext.AbstractComponent.previousNode">previousNode</see>
        /// </summary>
        /// <param name="selector"><p>A <see cref="Ext.ComponentQuery">ComponentQuery</see> selector to filter the preceding items.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>The previous sibling (or the previous sibling which matches the selector).
        /// Returns null if there is no matching sibling.</p>
        /// </div>
        /// </returns>
        public Ext.Component previousSibling(object selector=null){return null;}
        /// <summary>
        /// Called by Component#doAutoRender
        /// Register a Container configured <c>floating: true</c> with this Component's <see cref="Ext.ZIndexManager">ZIndexManager</see>.
        /// Components added in ths way will not participate in any layout, but will be rendered
        /// upon first show in the way that <see cref="Ext.window.Window">Window</see>s are.
        /// </summary>
        /// <param name="cmp">
        /// </param>
        public void registerFloatingItem(object cmp){}
        /// <summary>
        /// Relays selected events from the specified Observable as if the events were fired by this.
        /// For example if you are extending Grid, you might decide to forward some events from store.
        /// So you can do this inside your initComponent:
        /// <code>this.relayEvents(this.getStore(), ['load']);
        /// </code>
        /// The grid instance will then have an observable 'load' event which will be passed the
        /// parameters of the store's load event and any function fired with the grid's load event
        /// would have access to the grid using the <c>this</c> keyword.
        /// </summary>
        /// <param name="origin"><p>The Observable whose events this object is to relay.</p>
        /// </param>
        /// <param name="events"><p>Array of event names to relay.</p>
        /// </param>
        /// <param name="prefix"><p>A common prefix to prepend to the event names. For example:</p>
        /// <pre><code>this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
        /// </code></pre>
        /// <p>Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.</p>
        /// </param>
        public virtual void relayEvents(object origin, JsArray<String> events, object prefix=null){}
        /// <summary>
        /// Removes items in the childEls array based on the return value of a supplied test
        /// function. The function is called with a entry in childEls and if the test function
        /// return true, that entry is removed. If false, that entry is kept.
        /// </summary>
        /// <param name="testFn"><p>The test function.</p>
        /// </param>
        public virtual void removeChildEls(System.Delegate testFn){}
        /// <summary>
        /// Removes a CSS class from the top level element representing this component.
        /// </summary>
        /// <param name="cls"><p>The CSS class name to remove</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>Returns the Component to allow method chaining.</p>
        /// </div>
        /// </returns>
        public Ext.Component removeCls(object cls){return null;}
        /// <summary>
        /// Removes a cls to the uiCls array, which will also call removeUIClsFromElement and removes it from all
        /// elements of this component.
        /// </summary>
        /// <param name="cls"><p>A string or an array of strings to remove to the uiCls</p>
        /// </param>
        public void removeClsWithUI(object cls){}
        /// <summary>
        /// Removes an event handler.
        /// </summary>
        /// <param name="eventName"><p>The type of event the handler was associated with.</p>
        /// </param>
        /// <param name="fn"><p>The handler to remove. <strong>This must be a reference to the function passed into the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> call.</strong></p>
        /// </param>
        /// <param name="scope"><p>The scope originally specified for the handler. It must be the same as the
        /// scope argument specified in the original call to <see cref="Ext.util.Observable.addListener">addListener</see> or the listener will not be removed.</p>
        /// </param>
        public virtual void removeListener(JsString eventName, System.Delegate fn, object scope=null){}
        /// <summary>
        /// Removes listeners that were added by the mon method.
        /// </summary>
        /// <param name="item"><p>The item from which to remove a listener/listeners.</p>
        /// </param>
        /// <param name="ename"><p>The event name, or an object containing event name properties.</p>
        /// </param>
        /// <param name="fn"><p>If the <c>ename</c> parameter was an event name, this is the handler function.</p>
        /// </param>
        /// <param name="scope"><p>If the <c>ename</c> parameter was an event name, this is the scope (<c>this</c> reference)
        /// in which the handler function is executed.</p>
        /// </param>
        public virtual void removeManagedListener(object item, object ename, System.Delegate fn=null, object scope=null){}
        /// <summary>
        /// Remove a single managed listener item
        /// </summary>
        /// <param name="isClear"><p>True if this is being called during a clear</p>
        /// </param>
        /// <param name="managedListener"><p>The managed listener item
        /// See removeManagedListener for other args</p>
        /// </param>
        public virtual void removeManagedListenerItem(bool isClear, object managedListener){}
        /// <summary>
        /// Method which removes a specified UI + uiCls from the components element. The cls which is added to the element
        /// will be: this.baseCls + '-' + ui
        /// </summary>
        /// <param name="ui"><p>The UI to add to the element</p>
        /// </param>
        public void removeUIClsFromElement(JsString ui){}
        /// <summary>
        /// Method which removes a specified UI from the components element.
        /// </summary>
        private void removeUIFromElement(){}
        /// <summary>
        /// Renders the Component into the passed HTML element.
        /// <strong>If you are using a <see cref="Ext.container.Container">Container</see> object to house this
        /// Component, then do not use the render method.</strong>
        /// A Container's child Components are rendered by that Container's
        /// <see cref="Ext.container.ContainerConfig.layout">layout</see> manager when the Container is first rendered.
        /// If the Container is already rendered when a new child Component is added, you may need to call
        /// the Container's <see cref="Ext.container.Container.doLayout">doLayout</see> to refresh the view which
        /// causes any unrendered child Components to be rendered. This is required so that you can add
        /// multiple child components if needed while only refreshing the layout once.
        /// When creating complex UIs, it is important to remember that sizing and positioning
        /// of child items is the responsibility of the Container's <see cref="Ext.container.ContainerConfig.layout">layout</see>
        /// manager.  If you expect child items to be sized in response to user interactions, you must
        /// configure the Container with a layout manager which creates and manages the type of layout you
        /// have in mind.
        /// <strong>Omitting the Container's <see cref="Ext.container.ContainerConfig.layout">layout</see> config means that a basic
        /// layout manager is used which does nothing but render child components sequentially into the
        /// Container. No sizing or positioning will be performed in this situation.</strong>
        /// </summary>
        /// <param name="container"><p>The element this Component should be
        /// rendered into. If it is being created from existing markup, this should be omitted.</p>
        /// </param>
        /// <param name="position"><p>The element ID or DOM node index within the container <strong>before</strong>
        /// which this component will be inserted (defaults to appending to the end of the container)</p>
        /// </param>
        public virtual void render(object container=null, object position=null){}
        /// <summary>
        /// Resumes firing events (see suspendEvents).
        /// If events were suspended using the <c>queueSuspended</c> parameter, then all events fired
        /// during event suspension will be sent to any listeners now.
        /// </summary>
        public virtual void resumeEvents(){}
        /// <summary>
        /// Conditionally saves a single property from this object to the given state object.
        /// The idea is to only save state which has changed from the initial state so that
        /// current software settings do not override future software settings. Only those
        /// values that are user-changed state should be saved.
        /// </summary>
        /// <param name="propName"><p>The name of the property to save.</p>
        /// </param>
        /// <param name="state"><p>The state object in to which to save the property.</p>
        /// </param>
        /// <param name="stateName"><p>The name to use for the property in state.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="bool">Boolean</see></span><div><p>True if the property was saved, false if not.</p>
        /// </div>
        /// </returns>
        public virtual bool savePropToState(JsString propName, object state, object stateName=null){return false;}
        /// <summary>
        /// Gathers additional named properties of the instance and adds their current values
        /// to the passed state object.
        /// </summary>
        /// <param name="propNames"><p>The name (or array of names) of the property to save.</p>
        /// </param>
        /// <param name="state"><p>The state object in to which to save the property values.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>state</p>
        /// </div>
        /// </returns>
        public virtual object savePropsToState(object propNames, object state){return null;}
        /// <summary>
        /// Saves the state of the object to the persistence store.
        /// </summary>
        public virtual void saveState(){}
        /// <summary>
        /// Ensures that all effects queued after sequenceFx is called on this object are run in sequence. This is the
        /// opposite of syncFx.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public virtual object sequenceFx(){return null;}
        /// <summary>
        /// Parameters<li><span>border</span> : <see cref="String">String</see>/<see cref="Number">Number</see><div><p>The border, see <see>border</see>. If a falsey value is passed
        /// the border will be removed.</p>
        /// </div></li>
        /// </summary>
        /// <param name="border"><p>The border, see <see cref="Ext.AbstractComponentConfig.border">border</see>. If a falsey value is passed
        /// the border will be removed.</p>
        /// </param>
        public void setBorder(object border){}
        /// <summary>
        /// Enable or disable the component.
        /// </summary>
        /// <param name="disabled"><p>True to disable.</p>
        /// </param>
        public void setDisabled(bool disabled){}
        /// <summary>
        /// Sets the dock position of this component in its parent panel. Note that this only has effect if this item is part
        /// of the dockedItems collection of a parent that has a DockLayout (note that any Panel has a DockLayout by default)
        /// </summary>
        /// <param name="dock"><p>The dock position.</p>
        /// </param>
        /// <param name="layoutParent"><p>True to re-layout parent.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.Component setDocked(object dock, object layoutParent=null){return null;}
        /// <summary>
        /// Sets the height of the component. This method fires the resize event.
        /// </summary>
        /// <param name="height"><p>The new height to set. This may be one of:</p>
        /// <ul>
        /// <li>A Number specifying the new height in the <see cref="Ext.AbstractComponent.getEl">Element</see>'s <see cref="Ext.dom.Element.defaultUnit">Ext.Element.defaultUnit</see>s (by default, pixels).</li>
        /// <li>A String used to set the CSS height style.</li>
        /// <li><em>undefined</em> to leave the height unchanged.</li>
        /// </ul>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.Component setHeight(JsNumber height){return null;}
        /// <summary>
        /// Sets the left and top of the component. To set the page XY position instead, use setPagePosition. This
        /// method fires the move event.
        /// </summary>
        /// <param name="left"><p>The new left</p>
        /// </param>
        /// <param name="top"><p>The new top</p>
        /// </param>
        /// <param name="animate"><p>If true, the Component is <em>animated</em> into its new position. You may also pass an
        /// animation configuration.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.Component setPosition(JsNumber left, JsNumber top, object animate=null){return null;}
        /// <summary>
        /// Sets the width and height of this Component. This method fires the resize event. This method can accept
        /// either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.
        /// </summary>
        /// <param name="width"><p>The new width to set. This may be one of:</p>
        /// <ul>
        /// <li>A Number specifying the new width in the <see cref="Ext.AbstractComponent.getEl">Element</see>'s <see cref="Ext.dom.Element.defaultUnit">Ext.Element.defaultUnit</see>s (by default, pixels).</li>
        /// <li>A String used to set the CSS width style.</li>
        /// <li>A size object in the format <c>{width: widthValue, height: heightValue}</c>.</li>
        /// <li><c>undefined</c> to leave the width unchanged.</li>
        /// </ul>
        /// </param>
        /// <param name="height"><p>The new height to set (not required if a size object is passed as the first arg).
        /// This may be one of:</p>
        /// <ul>
        /// <li>A Number specifying the new height in the <see cref="Ext.AbstractComponent.getEl">Element</see>'s <see cref="Ext.dom.Element.defaultUnit">Ext.Element.defaultUnit</see>s (by default, pixels).</li>
        /// <li>A String used to set the CSS height style. Animation may <strong>not</strong> be used.</li>
        /// <li><c>undefined</c> to leave the height unchanged.</li>
        /// </ul>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.Component setSize(object width, object height){return null;}
        /// <summary>
        /// Sets the UI for the component. This will remove any existing UIs on the component. It will also loop through any
        /// uiCls set on the component and rename them so they include the new UI
        /// </summary>
        /// <param name="ui"><p>The new UI for the component</p>
        /// </param>
        public void setUI(JsString ui){}
        /// <summary>
        /// Convenience function to hide or show this component by boolean.
        /// </summary>
        /// <param name="visible"><p>True to show, false to hide</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.Component setVisible(bool visible){return null;}
        /// <summary>
        /// Sets the width of the component. This method fires the resize event.
        /// </summary>
        /// <param name="width"><p>The new width to setThis may be one of:</p>
        /// <ul>
        /// <li>A Number specifying the new width in the <see cref="Ext.AbstractComponent.getEl">Element</see>'s <see cref="Ext.dom.Element.defaultUnit">Ext.Element.defaultUnit</see>s (by default, pixels).</li>
        /// <li>A String used to set the CSS width style.</li>
        /// </ul>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public Ext.Component setWidth(JsNumber width){return null;}
        /// <summary>
        /// Inject a reference to the function which applies the render template into the framing template. The framing template
        /// wraps the content.
        /// </summary>
        /// <param name="frameTpl">
        /// </param>
        public virtual void setupFramingTpl(object frameTpl){}
        /// <summary>
        /// Stops any running effects and clears this object's internal effects queue if it contains any additional effects
        /// that haven't started yet.
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.dom.Element">Ext.Element</see></span><div><p>The Element</p>
        /// </div>
        /// </returns>
        public virtual Ext.dom.Element stopAnimation(){return null;}
        /// <summary>
        /// Stops any running effects and clears this object's internal effects queue if it contains any additional effects
        /// that haven't started yet.
        /// <p>This method has been <strong>deprecated</strong> since 4.0</p>
        /// <p>Replaced by <see cref="Ext.util.Animate.stopAnimation">stopAnimation</see></p>
        /// </summary>
        /// <returns>
        /// <span><see cref="Ext.dom.Element">Ext.Element</see></span><div><p>The Element</p>
        /// </div>
        /// </returns>
        public virtual Ext.dom.Element stopFx(){return null;}
        /// <summary>
        /// Suspends the firing of all events. (see resumeEvents)
        /// </summary>
        /// <param name="queueSuspended"><p>Pass as true to queue up suspended events to be fired
        /// after the <see cref="Ext.util.Observable.resumeEvents">resumeEvents</see> call instead of discarding all suspended events.</p>
        /// </param>
        public virtual void suspendEvents(bool queueSuspended){}
        /// <summary>
        /// Ensures that all effects queued after syncFx is called on this object are run concurrently. This is the opposite
        /// of sequenceFx.
        /// </summary>
        /// <returns>
        /// <span><see cref="Object">Object</see></span><div><p>this</p>
        /// </div>
        /// </returns>
        public virtual object syncFx(){return null;}
        /// <summary>
        /// Shorthand for removeListener.
        /// Removes an event handler.
        /// </summary>
        /// <param name="eventName"><p>The type of event the handler was associated with.</p>
        /// </param>
        /// <param name="fn"><p>The handler to remove. <strong>This must be a reference to the function passed into the
        /// <see cref="Ext.util.Observable.addListener">addListener</see> call.</strong></p>
        /// </param>
        /// <param name="scope"><p>The scope originally specified for the handler. It must be the same as the
        /// scope argument specified in the original call to <see cref="Ext.util.Observable.addListener">addListener</see> or the listener will not be removed.</p>
        /// </param>
        public virtual void un(JsString eventName, System.Delegate fn, object scope=null){}
        /// <summary>
        /// Walks up the ownerCt axis looking for an ancestor Container which matches the passed simple selector.
        /// Example:
        /// <code>var owningTabPanel = grid.up('tabpanel');
        /// </code>
        /// </summary>
        /// <param name="selector"><p>The simple selector to test.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.container.Container">Ext.container.Container</see></span><div><p>The matching ancestor Container (or <c>undefined</c> if no match was found).</p>
        /// </div>
        /// </returns>
        public Ext.container.Container up(object selector=null){return null;}
        /// <summary>
        /// Update the content area of a component.
        /// </summary>
        /// <param name="htmlOrData"><p>If this component has been configured with a template via the tpl config then
        /// it will use this argument as data to populate the template. If this component was not configured with a template,
        /// the components content area will be updated via <see cref="Ext.dom.Element">Ext.Element</see> update</p>
        /// </param>
        /// <param name="loadScripts"><p>Only legitimate when using the html configuration.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        /// <param name="callback"><p>Only legitimate when using the html configuration. Callback to execute when
        /// scripts have finished loading</p>
        /// </param>
        public void update(object htmlOrData, object loadScripts=null, object callback=null){}
        /// <summary>
        /// Injected as an override by Ext.Aria.initialize
        /// </summary>
        private void updateAria(){}
        /// <summary>
        /// Updates this component's layout. If this update effects this components ownerCt,
        /// that component's updateLayout method will be called to perform the layout instead.
        /// Otherwise, just this component (and its child items) will layout.
        /// </summary>
        /// <param name="options"><p>An object with layout options.</p>
        /// <ul><li><span>defer</span> : <see cref="bool">Boolean</see><div><p>True if this layout should be deferred.</p>
        /// </div></li><li><span>isRoot</span> : <see cref="bool">Boolean</see><div><p>True if this layout should be the root of the layout.</p>
        /// </div></li></ul></param>
        public void updateLayout(object options){}
        /// <summary>
        /// Performs all pending layouts that were sceduled while
        /// suspendLayouts was in effect.
        /// </summary>
        public static void flushLayouts(){}
        /// <summary>
        /// Resumes layout activity in the whole framework.
        /// <see cref="Ext.ExtContext.suspendLayouts">Ext.suspendLayouts</see> is alias of <see cref="Ext.AbstractComponent.suspendLayouts">suspendLayouts</see>.
        /// </summary>
        /// <param name="flush"><p>True to perform all the pending layouts. This can also be
        /// achieved by calling <see cref="Ext.AbstractComponent.flushLayouts">flushLayouts</see> directly.</p>
        /// <p>Defaults to: <c>false</c></p></param>
        public static void resumeLayouts(object flush=null){}
        /// <summary>
        /// Stops layouts from happening in the whole framework.
        /// It's useful to suspend the layout activity while updating multiple components and
        /// containers:
        /// <code><see cref="Ext.ExtContext.suspendLayouts">Ext.suspendLayouts</see>();
        /// // batch of updates...
        /// <see cref="Ext.ExtContext.resumeLayouts">Ext.resumeLayouts</see>(true);
        /// </code>
        /// <see cref="Ext.ExtContext.suspendLayouts">Ext.suspendLayouts</see> is alias of <see cref="Ext.AbstractComponent.suspendLayouts">suspendLayouts</see>.
        /// See also <see cref="Ext.ExtContext.batchLayouts">Ext.batchLayouts</see> for more abstract way of doing this.
        /// </summary>
        public static void suspendLayouts(){}
        /// <summary>
        /// Adds each argument passed to this method to the childEls array.
        /// </summary>
        public virtual void addChildEls(){}
        public AbstractComponent(AbstractComponentConfig config){}
        public AbstractComponent(params object[] args){}
    }
    #endregion
    #region AbstractComponentConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractComponentConfig : Ext.BaseConfig
    {
        /// <summary>
        /// A tag name or DomHelper spec used to create the Element which will
        /// encapsulate this Component.
        /// You do not normally need to specify this. For the base classes <see cref="Ext.Component">Ext.Component</see> and
        /// <see cref="Ext.container.Container">Ext.container.Container</see>, this defaults to <strong>'div'</strong>. The more complex Sencha classes use a more
        /// complex DOM structure specified by their own <see cref="Ext.AbstractComponentConfig.renderTpl">renderTpl</see>s.
        /// This is intended to allow the developer to create application-specific utility Components encapsulated by
        /// different DOM elements. Example usage:
        /// <code>{
        /// xtype: 'component',
        /// autoEl: {
        /// tag: 'img',
        /// src: 'http://www.example.com/example.jpg'
        /// }
        /// }, {
        /// xtype: 'component',
        /// autoEl: {
        /// tag: 'blockquote',
        /// html: 'autoEl is cool!'
        /// }
        /// }, {
        /// xtype: 'container',
        /// autoEl: 'ul',
        /// cls: 'ux-unordered-list',
        /// items: {
        /// xtype: 'component',
        /// autoEl: 'li',
        /// html: 'First list item'
        /// }
        /// }
        /// </code>
        /// </summary>
        public object autoEl;
        /// <summary>
        /// An alias for loader config which also allows to specify just a string which will be
        /// used as the url that's automatically loaded:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// autoLoad: 'content.html',
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>()
        /// });
        /// </code>
        /// The above is the same as:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// loader: {
        /// url: 'content.html',
        /// autoLoad: true
        /// },
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>()
        /// });
        /// </code>
        /// Don't use it together with <see cref="Ext.AbstractComponentConfig.loader">loader</see> config.
        /// <p>This cfg has been <strong>deprecated</strong> since 4.1.1</p>
        /// <p>Use <see cref="Ext.AbstractComponentConfig.loader">loader</see> config instead.</p>
        /// </summary>
        public object autoLoad;
        /// <summary>
        /// This config is intended mainly for non-floating Components which may or may not be shown. Instead of using
        /// renderTo in the configuration, and rendering upon construction, this allows a Component to render itself
        /// upon first show. If floating is true, the value of this config is omited as if it is true.
        /// Specify as <c>true</c> to have this Component render to the document body upon first show.
        /// Specify as an element, or the ID of an element to have this Component render to a specific element upon first
        /// show.
        /// Defaults to: <c>false</c>
        /// </summary>
        public object autoRender;
        /// <summary>
        /// True to automatically show the component upon creation. This config option may only be used for
        /// floating components or components that use autoRender. Defaults to false.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool autoShow;
        /// <summary>
        /// The base CSS class to apply to this components's element. This will also be prepended to elements within this
        /// component like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and
        /// you want it to get all the Panels styling for the element and the body, you leave the baseCls x-panel and use
        /// componentCls to add specific styling for this component.
        /// Defaults to: <c>&quot;x-component&quot;</c>
        /// </summary>
        public JsString baseCls;
        /// <summary>
        /// Specifies the border size for this component. The border can be a single numeric value to apply to all sides or it can
        /// be a CSS style specification for each style, for example: '10 5 3 10'.
        /// For components that have no border by default, setting this won't make the border appear by itself.
        /// You also need to specify border color and style:
        /// <code>border: 5,
        /// style: {
        /// borderColor: 'red',
        /// borderStyle: 'solid'
        /// }
        /// </code>
        /// To turn off the border, use <c>border: false</c>.
        /// </summary>
        public object border;
        /// <summary>
        /// An array describing the child elements of the Component. Each member of the array
        /// is an object with these properties:
        /// <li><c>name</c> - The property name on the Component for the child element.</li>
        /// <li><c>itemId</c> - The id to combine with the Component's id that is the id of the child element.</li>
        /// <li><c>id</c> - The id of the child element.</li>
        /// If the array member is a string, it is equivalent to <c>{ name: m, itemId: m }</c>.
        /// For example, a Component which renders a title and body text:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>(),
        /// renderTpl: [
        /// '&lt;h1 id="{id}-title"&gt;{title}&lt;/h1&gt;',
        /// '&lt;p&gt;{msg}&lt;/p&gt;',
        /// ],
        /// renderData: {
        /// title: "Error",
        /// msg: "Something went wrong"
        /// },
        /// childEls: ["title"],
        /// listeners: {
        /// afterrender: function(cmp){
        /// // After rendering the component will have a title property
        /// cmp.title.setStyle({color: "red"});
        /// }
        /// }
        /// });
        /// </code>
        /// A more flexible, but somewhat slower, approach is <see cref="Ext.AbstractComponentConfig.renderSelectors">renderSelectors</see>.
        /// </summary>
        public JsObject childEls;
        /// <summary>
        /// An optional extra CSS class that will be added to this component's Element. This can be useful
        /// for adding customized styles to the component or any of its children using standard CSS rules.
        /// Defaults to: <c>&quot;&quot;</c>
        /// </summary>
        public JsString cls;
        /// <summary>
        /// CSS Class to be added to a components root level element to give distinction to it via styling.
        /// </summary>
        public JsString componentCls;
        /// <summary>
        /// The sizing and positioning of a Component's internal Elements is the responsibility of the Component's layout
        /// manager which sizes a Component's internal structure in response to the Component being sized.
        /// Generally, developers will not use this configuration as all provided Components which need their internal
        /// elements sizing (Such as <see cref="Ext.form.field.Base">input fields</see>) come with their own componentLayout managers.
        /// The <see cref="Ext.layout.container.Auto">default layout manager</see> will be used on instances of the base <see cref="Ext.Component">Ext.Component</see>
        /// class which simply sizes the Component's encapsulating element to the height and width specified in the
        /// <see cref="Ext.AbstractComponent.setSize">setSize</see> method.
        /// </summary>
        public object componentLayout;
        /// <summary>
        /// Specify an existing HTML element, or the id of an existing HTML element to use as the content for this component.
        /// This config option is used to take an existing HTML element and place it in the layout element of a new component
        /// (it simply moves the specified DOM element <em>after the Component is rendered</em> to use as the content.
        /// <strong>Notes:</strong>
        /// The specified HTML element is appended to the layout element of the component <em>after any configured
        /// <see cref="Ext.AbstractComponentConfig.html">HTML</see> has been inserted</em>, and so the document will not contain this element at the time
        /// the <see cref="Ext.AbstractComponentEvents.render">render</see> event is fired.
        /// The specified HTML element used will not participate in any <strong><c><see cref="Ext.container.ContainerConfig.layout">layout</see></c></strong>
        /// scheme that the Component may use. It is just HTML. Layouts operate on child
        /// <strong><c><see cref="Ext.container.ContainerConfig.items">items</see></c></strong>.
        /// Add either the <c>x-hidden</c> or the <c>x-hide-display</c> CSS class to prevent a brief flicker of the content before it
        /// is rendered to the panel.
        /// </summary>
        public JsString contentEl;
        /// <summary>
        /// The initial set of data to apply to the tpl to update the content area of the Component.
        /// </summary>
        public JsObject data;
        /// <summary>
        /// True to disable the component.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool disabled;
        /// <summary>
        /// CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.
        /// Defaults to: <c>&quot;x-item-disabled&quot;</c>
        /// </summary>
        public JsString disabledCls;
        /// <summary>
        /// Allows the component to be dragged.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool draggable;
        /// <summary>
        /// Create the Component as a floating and use absolute positioning.
        /// The z-index of floating Components is handled by a ZIndexManager. If you simply render a floating Component into the DOM, it will be managed
        /// by the global <see cref="Ext.WindowManager">WindowManager</see>.
        /// If you include a floating Component as a child item of a Container, then upon render, ExtJS will seek an ancestor floating Component to house a new
        /// ZIndexManager instance to manage its descendant floaters. If no floating ancestor can be found, the global WindowManager will be used.
        /// When a floating Component which has a ZindexManager managing descendant floaters is destroyed, those descendant floaters will also be destroyed.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool floating;
        /// <summary>
        /// Specify as true to have the Component inject framing elements within the Component at render time to provide a
        /// graphical rounded frame around the Component content.
        /// This is only necessary when running on outdated, or non standard-compliant browsers such as Microsoft's Internet
        /// Explorer prior to version 9 which do not support rounded corners natively.
        /// The extra space taken up by this framing is available from the read only property <see cref="Ext.AbstractComponent.frameSize">frameSize</see>.
        /// </summary>
        public bool frame;
        /// <summary>
        /// The height of this component in pixels.
        /// </summary>
        public JsNumber height;
        /// <summary>
        /// True to hide the component.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool hidden;
        /// <summary>
        /// A String which specifies how this Component's encapsulating DOM element will be hidden. Values may be:
        /// <li><c>'display'</c> : The Component will be hidden using the <c>display: none</c> style.</li>
        /// <li><c>'visibility'</c> : The Component will be hidden using the <c>visibility: hidden</c> style.</li>
        /// <li><c>'offsets'</c> : The Component will be hidden by absolutely positioning it out of the visible area of the document.
        /// This is useful when a hidden Component must maintain measurable dimensions. Hiding using <c>display</c> results in a
        /// Component having zero dimensions.</li>
        /// Defaults to: <c>&quot;display&quot;</c>
        /// </summary>
        public JsString hideMode;
        /// <summary>
        /// An HTML fragment, or a DomHelper specification to use as the layout element content.
        /// The HTML content is added after the component is rendered, so the document will not contain this HTML at the time
        /// the render event is fired. This content is inserted into the body before any configured contentEl
        /// is appended.
        /// Defaults to: <c>&quot;&quot;</c>
        /// </summary>
        public object html;
        /// <summary>
        /// The unique id of this component instance.
        /// It should not be necessary to use this configuration except for singleton objects in your application. Components
        /// created with an id may be accessed globally using <see cref="Ext.ExtContext.getCmp">Ext.getCmp</see>.
        /// Instead of using assigned ids, use the <see cref="Ext.AbstractComponentConfig.itemId">itemId</see> config, and <see cref="Ext.ComponentQuery">ComponentQuery</see>
        /// which provides selector-based searching for Sencha Components analogous to DOM querying. The <see cref="Ext.container.Container">Container</see> class contains <see cref="Ext.container.Container.down">shortcut methods</see> to query
        /// its descendant Components by selector.
        /// Note that this id will also be used as the element id for the containing HTML element that is rendered to the
        /// page for this component. This allows you to write id-based CSS rules to style the specific instance of this
        /// component uniquely, and also to select sub-elements using this component's id as the parent.
        /// <strong>Note</strong>: to avoid complications imposed by a unique id also see <c><see cref="Ext.AbstractComponentConfig.itemId">itemId</see></c>.
        /// <strong>Note</strong>: to access the container of a Component see <c><see cref="Ext.AbstractComponent.ownerCt">ownerCt</see></c>.
        /// Defaults to an <see cref="Ext.AbstractComponent.getId">auto-assigned id</see>.
        /// </summary>
        public JsString id;
        /// <summary>
        /// An itemId can be used as an alternative way to get a reference to a component when no object reference is
        /// available. Instead of using an id with Ext.getCmp, use itemId with
        /// Ext.container.Container.getComponent which will retrieve
        /// itemId's or id's. Since itemId's are an index to the container's internal MixedCollection, the
        /// itemId is scoped locally to the container -- avoiding potential conflicts with Ext.ComponentManager
        /// which requires a unique id.
        /// <code>var c = new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({ //
        /// <see cref="Ext.ComponentConfig.height">height</see>: 300,
        /// <see cref="Ext.AbstractComponentConfig.renderTo">renderTo</see>: document.body,
        /// <see cref="Ext.container.ContainerConfig.layout">layout</see>: 'auto',
        /// <see cref="Ext.container.ContainerConfig.items">items</see>: [
        /// {
        /// itemId: 'p1',
        /// <see cref="Ext.panel.PanelConfig.title">title</see>: 'Panel 1',
        /// <see cref="Ext.ComponentConfig.height">height</see>: 150
        /// },
        /// {
        /// itemId: 'p2',
        /// <see cref="Ext.panel.PanelConfig.title">title</see>: 'Panel 2',
        /// <see cref="Ext.ComponentConfig.height">height</see>: 150
        /// }
        /// ]
        /// })
        /// p1 = c.<see cref="Ext.container.Container.getComponent">getComponent</see>('p1'); // not the same as <see cref="Ext.ExtContext.getCmp">Ext.getCmp()</see>
        /// p2 = p1.<see cref="Ext.AbstractComponent.ownerCt">ownerCt</see>.<see cref="Ext.container.Container.getComponent">getComponent</see>('p2'); // reference via a sibling
        /// </code>
        /// Also see <see cref="Ext.AbstractComponentConfig.id">id</see>, <c><see cref="Ext.container.Container.query">Ext.container.Container.query</see></c>, <c><see cref="Ext.container.Container.down">Ext.container.Container.down</see></c> and
        /// <c><see cref="Ext.container.Container.child">Ext.container.Container.child</see></c>.
        /// <strong>Note</strong>: to access the container of an item see <see cref="Ext.AbstractComponent.ownerCt">ownerCt</see>.
        /// </summary>
        public JsString itemId;
        /// <summary>
        /// A config object containing one or more event handlers to be added to this object during initialization. This
        /// should be a valid listeners config object as specified in the addListener example for attaching multiple
        /// handlers at once.
        /// <strong>DOM events from Ext JS <see cref="Ext.Component">Components</see></strong>
        /// While <em>some</em> Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
        /// only done when extra value can be added. For example the <see cref="Ext.view.View">DataView</see>'s <strong><c><see cref="Ext.view.ViewEvents.itemclick">itemclick</see></c></strong> event passing the node clicked on. To access DOM events directly from a
        /// child element of a Component, we need to specify the <c>element</c> option to identify the Component property to add a
        /// DOM listener to:
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// width: 400,
        /// height: 200,
        /// dockedItems: [{
        /// xtype: 'toolbar'
        /// }],
        /// listeners: {
        /// click: {
        /// element: 'el', //bind to the underlying el property on the panel
        /// fn: function(){ console.log('click el'); }
        /// },
        /// dblclick: {
        /// element: 'body', //bind to the underlying body property on the panel
        /// fn: function(){ console.log('dblclick body'); }
        /// }
        /// }
        /// });
        /// </code>
        /// </summary>
        public JsObject listeners;
        /// <summary>
        /// A configuration object or an instance of a Ext.ComponentLoader to load remote content
        /// for this Component.
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// loader: {
        /// url: 'content.html',
        /// autoLoad: true
        /// },
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>()
        /// });
        /// </code>
        /// </summary>
        public object loader;
        /// <summary>
        /// Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can
        /// be a CSS style specification for each style, for example: '10 5 3 10'.
        /// </summary>
        public object margin;
        /// <summary>
        /// The maximum value in pixels which this Component will set its height to.
        /// <strong>Warning:</strong> This will override any size management applied by layout managers.
        /// </summary>
        public JsNumber maxHeight;
        /// <summary>
        /// The maximum value in pixels which this Component will set its width to.
        /// <strong>Warning:</strong> This will override any size management applied by layout managers.
        /// </summary>
        public JsNumber maxWidth;
        /// <summary>
        /// The minimum value in pixels which this Component will set its height to.
        /// <strong>Warning:</strong> This will override any size management applied by layout managers.
        /// </summary>
        public JsNumber minHeight;
        /// <summary>
        /// The minimum value in pixels which this Component will set its width to.
        /// <strong>Warning:</strong> This will override any size management applied by layout managers.
        /// </summary>
        public JsNumber minWidth;
        /// <summary>
        /// An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element,
        /// and removed when the mouse moves out. This can be useful for adding customized 'active' or 'hover' styles to the
        /// component or any of its children using standard CSS rules.
        /// Defaults to: <c>&quot;&quot;</c>
        /// </summary>
        public JsString overCls;
        /// <summary>
        /// Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it
        /// can be a CSS style specification for each style, for example: '10 5 3 10'.
        /// </summary>
        public object padding;
        /// <summary>
        /// An object or array of objects that will provide custom functionality for this component. The only requirement for
        /// a valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component
        /// is created, if any plugins are available, the component will call the init method on each plugin, passing a
        /// reference to itself. Each plugin can then call methods or respond to events on the component as needed to provide
        /// its functionality.
        /// </summary>
        public object plugins;
        /// <summary>
        /// The data used by renderTpl in addition to the following property values of the component:
        /// <li>id</li>
        /// <li>ui</li>
        /// <li>uiCls</li>
        /// <li>baseCls</li>
        /// <li>componentCls</li>
        /// <li>frame</li>
        /// See <see cref="Ext.AbstractComponentConfig.renderSelectors">renderSelectors</see> and <see cref="Ext.AbstractComponentConfig.childEls">childEls</see> for usage examples.
        /// </summary>
        public JsObject renderData;
        /// <summary>
        /// An object containing properties specifying DomQuery selectors which identify child elements
        /// created by the render process.
        /// After the Component's internal structure is rendered according to the <see cref="Ext.AbstractComponentConfig.renderTpl">renderTpl</see>, this object is iterated through,
        /// and the found Elements are added as properties to the Component using the <c>renderSelector</c> property name.
        /// For example, a Component which renderes a title and description into its element:
        /// <code><see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.Component">Ext.Component</see>', {
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>(),
        /// renderTpl: [
        /// '&lt;h1 class="title"&gt;{title}&lt;/h1&gt;',
        /// '&lt;p&gt;{desc}&lt;/p&gt;'
        /// ],
        /// renderData: {
        /// title: "Error",
        /// desc: "Something went wrong"
        /// },
        /// renderSelectors: {
        /// titleEl: 'h1.title',
        /// descEl: 'p'
        /// },
        /// listeners: {
        /// afterrender: function(cmp){
        /// // After rendering the component will have a titleEl and descEl properties
        /// cmp.titleEl.setStyle({color: "red"});
        /// }
        /// }
        /// });
        /// </code>
        /// For a faster, but less flexible, alternative that achieves the same end result (properties for child elements on the
        /// Component after render), see <see cref="Ext.AbstractComponentConfig.childEls">childEls</see> and <see cref="Ext.AbstractComponent.addChildEls">addChildEls</see>.
        /// </summary>
        public JsObject renderSelectors;
        /// <summary>
        /// Specify the id of the element, a DOM element or an existing Element that this component will be rendered into.
        /// <strong>Notes:</strong>
        /// Do <em>not</em> use this option if the Component is to be a child item of a <see cref="Ext.container.Container">Container</see>.
        /// It is the responsibility of the <see cref="Ext.container.Container">Container</see>'s
        /// <see cref="Ext.container.ContainerConfig.layout">layout manager</see> to render and manage its child items.
        /// When using this config, a call to render() is not required.
        /// See also: <see cref="Ext.AbstractComponent.render">render</see>.
        /// </summary>
        public object renderTo;
        /// <summary>
        /// An XTemplate used to create the internal structure inside this Component's encapsulating
        /// Element.
        /// You do not normally need to specify this. For the base classes <see cref="Ext.Component">Ext.Component</see> and
        /// <see cref="Ext.container.Container">Ext.container.Container</see>, this defaults to <strong><c>null</c></strong> which means that they will be initially rendered
        /// with no internal structure; they render their <see cref="Ext.AbstractComponent.getEl">Element</see> empty. The more specialized ExtJS and Touch
        /// classes which use a more complex DOM structure, provide their own template definitions.
        /// This is intended to allow the developer to create application-specific utility Components with customized
        /// internal structure.
        /// Upon rendering, any created child elements may be automatically imported into object properties using the
        /// <see cref="Ext.AbstractComponentConfig.renderSelectors">renderSelectors</see> and <see cref="Ext.AbstractComponentConfig.childEls">childEls</see> options.
        /// Defaults to: <c>&quot;{%this.renderContent(out,values)%}&quot;</c>
        /// </summary>
        public object renderTpl;
        /// <summary>
        /// A buffer to be applied if many state events are fired within a short period.
        /// Defaults to: <c>100</c>
        /// </summary>
        public JsNumber saveDelay;
        /// <summary>
        /// If this property is a number, it is interpreted as follows:
        /// <li>0: Neither width nor height depend on content. This is equivalent to <c>false</c>.</li>
        /// <li>1: Width depends on content (shrink wraps), but height does not.</li>
        /// <li>2: Height depends on content (shrink wraps), but width does not. The default.</li>
        /// <li>3: Both width and height depend on content (shrink wrap). This is equivalent to <c>true</c>.</li>
        /// In CSS terms, shrink-wrap width is analogous to an inline-block element as opposed
        /// to a block-level element. Some container layouts always shrink-wrap their children,
        /// effectively ignoring this property (e.g., <see cref="Ext.layout.container.HBox">Ext.layout.container.HBox</see>,
        /// <see cref="Ext.layout.container.VBox">Ext.layout.container.VBox</see>, <see cref="Ext.layout.component.Dock">Ext.layout.component.Dock</see>).
        /// Defaults to: <c>2</c>
        /// </summary>
        public object shrinkWrap;
        /// <summary>
        /// An array of events that, when fired, should trigger this object to
        /// save its state. Defaults to none. stateEvents may be any type
        /// of event supported by this object, including browser or custom events
        /// (e.g., ['click', 'customerchange']).
        /// See <c><see cref="Ext.state.StatefulConfig.stateful">stateful</see></c> for an explanation of saving and
        /// restoring object state.
        /// </summary>
        public JsString stateEvents;
        /// <summary>
        /// The unique id for this object to use for state management purposes.
        /// See <see cref="Ext.state.StatefulConfig.stateful">stateful</see> for an explanation of saving and restoring state.
        /// </summary>
        public JsString stateId;
        /// <summary>
        /// A flag which causes the object to attempt to restore the state of
        /// internal properties from a saved state on startup. The object must have
        /// a stateId for state to be managed.
        /// Auto-generated ids are not guaranteed to be stable across page loads and
        /// cannot be relied upon to save and restore the same state for a object.
        /// For state saving to work, the state manager's provider must have been
        /// set to an implementation of <see cref="Ext.state.Provider">Ext.state.Provider</see> which overrides the
        /// <see cref="Ext.state.Provider.set">set</see> and <see cref="Ext.state.Provider.get">get</see>
        /// methods to save and recall name/value pairs. A built-in implementation,
        /// <see cref="Ext.state.CookieProvider">Ext.state.CookieProvider</see> is available.
        /// To set the state provider for the current page:
        /// <see cref="Ext.state.Manager.setProvider">Ext.state.Manager.setProvider</see>(new <see cref="Ext.state.CookieProvider">Ext.state.CookieProvider</see>({
        /// <code>   expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
        /// </code>
        /// }));
        /// A stateful object attempts to save state when one of the events
        /// listed in the <see cref="Ext.state.StatefulConfig.stateEvents">stateEvents</see> configuration fires.
        /// To save state, a stateful object first serializes its state by
        /// calling <em><see cref="Ext.state.Stateful.getState">getState</see></em>.
        /// The Component base class implements <see cref="Ext.state.Stateful.getState">getState</see> to save its width and height within the state
        /// only if they were initially configured, and have changed from the configured value.
        /// The Panel class saves its collapsed state in addition to that.
        /// The Grid class saves its column state in addition to its superclass state.
        /// If there is more application state to be save, the developer must provide an implementation which
        /// first calls the superclass method to inherit the above behaviour, and then injects new properties
        /// into the returned object.
        /// The value yielded by getState is passed to <see cref="Ext.state.Manager.set">Ext.state.Manager.set</see>
        /// which uses the configured <see cref="Ext.state.Provider">Ext.state.Provider</see> to save the object
        /// keyed by the <see cref="Ext.state.StatefulConfig.stateId">stateId</see>.
        /// During construction, a stateful object attempts to <em>restore</em> its state by calling
        /// <see cref="Ext.state.Manager.get">Ext.state.Manager.get</see> passing the <see cref="Ext.state.StatefulConfig.stateId">stateId</see>
        /// The resulting object is passed to <see cref="Ext.state.Stateful.applyState">applyState</see>*. The default implementation of
        /// <see cref="Ext.state.Stateful.applyState">applyState</see> simply copies properties into the object, but a developer may
        /// override this to support restoration of more complex application state.
        /// You can perform extra processing on state save and restore by attaching
        /// handlers to the <see cref="Ext.state.StatefulEvents.beforestaterestore">beforestaterestore</see>, <see cref="Ext.state.StatefulEvents.staterestore">staterestore</see>,
        /// <see cref="Ext.state.StatefulEvents.beforestatesave">beforestatesave</see> and <see cref="Ext.state.StatefulEvents.statesave">statesave</see> events.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool stateful;
        /// <summary>
        /// A custom style specification to be applied to this component's Element. Should be a valid argument to
        /// Ext.Element.applyStyles.
        /// <code>new <see cref="Ext.panel.Panel">Ext.panel.Panel</see>({
        /// title: 'Some Title',
        /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>(),
        /// width: 400, height: 300,
        /// layout: 'form',
        /// items: [{
        /// xtype: 'textarea',
        /// style: {
        /// width: '95%',
        /// marginBottom: '10px'
        /// }
        /// },
        /// new <see cref="Ext.button.Button">Ext.button.Button</see>({
        /// text: 'Send',
        /// minWidth: '100',
        /// style: {
        /// marginBottom: '10px'
        /// }
        /// })
        /// ]
        /// });
        /// </code>
        /// </summary>
        public object style;
        /// <summary>
        /// The class that is added to the content target when you set styleHtmlContent to true.
        /// Defaults to: <c>&quot;x-html&quot;</c>
        /// </summary>
        public JsString styleHtmlCls;
        /// <summary>
        /// True to automatically style the html inside the content target of this component (body for panels).
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool styleHtmlContent;
        /// <summary>
        /// An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in
        /// conjunction with the data and tplWriteMode configurations.
        /// </summary>
        public object tpl;
        /// <summary>
        /// The Ext.(X)Template method to use when updating the content area of the Component.
        /// See Ext.XTemplate.overwrite for information on default mode.
        /// Defaults to: <c>&quot;overwrite&quot;</c>
        /// </summary>
        public JsString tplWriteMode;
        /// <summary>
        /// A UI style for a component.
        /// Defaults to: <c>&quot;default&quot;</c>
        /// </summary>
        public JsString ui;
        /// <summary>
        /// An array of of classNames which are currently applied to this component
        /// Defaults to: <c>[]</c>
        /// </summary>
        public JsString uiCls;
        /// <summary>
        /// The width of this component in pixels.
        /// </summary>
        public JsNumber width;
        /// <summary>
        /// This property provides a shorter alternative to creating objects than using a full
        /// class name. Using xtype is the most common way to define component instances,
        /// especially in a container. For example, the items in a form containing text fields
        /// could be created explicitly like so:
        /// <code> items: [
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.form.field.Text">Ext.form.field.Text</see>', {
        /// fieldLabel: 'Foo'
        /// }),
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.form.field.Text">Ext.form.field.Text</see>', {
        /// fieldLabel: 'Bar'
        /// }),
        /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.form.field.Number">Ext.form.field.Number</see>', {
        /// fieldLabel: 'Num'
        /// })
        /// ]
        /// </code>
        /// But by using <c>xtype</c>, the above becomes:
        /// <code> items: [
        /// {
        /// xtype: 'textfield',
        /// fieldLabel: 'Foo'
        /// },
        /// {
        /// xtype: 'textfield',
        /// fieldLabel: 'Bar'
        /// },
        /// {
        /// xtype: 'numberfield',
        /// fieldLabel: 'Num'
        /// }
        /// ]
        /// </code>
        /// When the <c>xtype</c> is common to many items, <see cref="Ext.container.AbstractContainerConfig.defaultType">Ext.container.AbstractContainer.defaultType</see>
        /// is another way to specify the <c>xtype</c> for all items that don't have an explicit <c>xtype</c>:
        /// <code> defaultType: 'textfield',
        /// items: [
        /// { fieldLabel: 'Foo' },
        /// { fieldLabel: 'Bar' },
        /// { fieldLabel: 'Num', xtype: 'numberfield' }
        /// ]
        /// </code>
        /// Each member of the <c>items</c> array is now just a "configuration object". These objects
        /// are used to create and configure component instances. A configuration object can be
        /// manually used to instantiate a component using <see cref="Ext.ExtContext.widget">Ext.widget</see>:
        /// <code> var text1 = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.form.field.Text">Ext.form.field.Text</see>', {
        /// fieldLabel: 'Foo'
        /// });
        /// // or alternatively:
        /// var text1 = <see cref="Ext.ExtContext.widget">Ext.widget</see>({
        /// xtype: 'textfield',
        /// fieldLabel: 'Foo'
        /// });
        /// </code>
        /// This conversion of configuration objects into instantiated components is done when
        /// a container is created as part of its {<see cref="Ext.container.AbstractContainer.initComponent">Ext.container.AbstractContainer.initComponent</see>}
        /// process. As part of the same process, the <c>items</c> array is converted from its raw
        /// array form into a <see cref="Ext.util.MixedCollection">Ext.util.MixedCollection</see> instance.
        /// You can define your own <c>xtype</c> on a custom <see cref="Ext.Component">component</see> by specifying
        /// the <c>xtype</c> property in <see cref="Ext.ExtContext.define">Ext.define</see>. For example:
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('MyApp.PressMeButton', {
        /// extend: '<see cref="Ext.button.Button">Ext.button.Button</see>',
        /// xtype: 'pressmebutton',
        /// text: 'Press Me'
        /// });
        /// </code>
        /// Care should be taken when naming an <c>xtype</c> in a custom component because there is
        /// a single, shared scope for all xtypes. Third part components should consider using
        /// a prefix to avoid collisions.
        /// <code><see cref="Ext.ExtContext.define">Ext.define</see>('Foo.form.CoolButton', {
        /// extend: '<see cref="Ext.button.Button">Ext.button.Button</see>',
        /// xtype: 'ux-coolbutton',
        /// text: 'Cool!'
        /// });
        /// </code>
        /// </summary>
        public JsString xtype;
        public AbstractComponentConfig(params object[] args){}
    }
    #endregion
    #region AbstractComponentEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class AbstractComponentEvents : Ext.BaseEvents
    {
        /// <summary>
        /// Fires after a Component has been visually activated.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void activate(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires after a Component had been added to a Container.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="container"><p>Parent Container</p>
        /// </param>
        /// <param name="pos"><p>position of Component</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void added(Ext.Component @this, Ext.container.Container container, JsNumber pos, object eOpts){}
        /// <summary>
        /// Fires after the component rendering is finished.
        /// The afterrender event is fired after this Component has been <see cref="Ext.AbstractComponent.rendered">rendered</see>, been postprocesed by any
        /// afterRender method defined for the Component.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void afterrender(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires before a Component has been visually activated. Returning false from an event listener can prevent
        /// the activate from occurring.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforeactivate(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires before a Component has been visually deactivated. Returning false from an event listener can
        /// prevent the deactivate from occurring.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforedeactivate(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires before the component is destroyed. Return false from an event handler to stop the
        /// destroy.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforedestroy(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires before the component is hidden when calling the hide method. Return false from an event
        /// handler to stop the hide.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforehide(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires before the component is rendered. Return false from an event handler to stop the
        /// render.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforerender(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires before the component is shown when calling the show method. Return false from an event
        /// handler to stop the show.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforeshow(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires before the state of the object is restored. Return false from an event handler to stop the restore.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="state"><p>The hash of state values returned from the StateProvider. If this
        /// event is not vetoed, then the state object is passed to <b><tt>applyState</tt></b>. By default,
        /// that simply copies property values into this object. The method maybe overriden to
        /// provide custom state restoration.</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforestaterestore(Ext.state.Stateful @this, object state, object eOpts){}
        /// <summary>
        /// Fires before the state of the object is saved to the configured state provider. Return false to stop the save.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="state"><p>The hash of state values. This is determined by calling
        /// <b><tt>getState()</tt></b> on the object. This method must be provided by the
        /// developer to return whetever representation of state is required, by default, <see cref="Ext.state.Stateful">Ext.state.Stateful</see>
        /// has a null implementation.</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void beforestatesave(Ext.state.Stateful @this, object state, object eOpts){}
        /// <summary>
        /// Fires when this Component loses focus.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="The"><p>blur event.</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void blur(Ext.Component @this, EventObject The, object eOpts){}
        /// <summary>
        /// Fires one time - after the component has been layed out for the first time at its initial size.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="width"><p>The initial width</p>
        /// </param>
        /// <param name="height"><p>The initial height</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void boxready(Ext.Component @this, JsNumber width, JsNumber height, object eOpts){}
        /// <summary>
        /// Fires after a Component has been visually deactivated.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void deactivate(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires after the component is destroyed.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void destroy(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires after the component is disabled.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void disable(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires after the component is enabled.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void enable(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires when this Component receives focus.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="The"><p>focus event.</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void focus(Ext.Component @this, EventObject The, object eOpts){}
        /// <summary>
        /// Fires after the component is hidden. Fires after the component is hidden when calling the hide
        /// method.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void hide(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires after the component is moved.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="x"><p>The new x position</p>
        /// </param>
        /// <param name="y"><p>The new y position</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void move(Ext.Component @this, JsNumber x, JsNumber y, object eOpts){}
        /// <summary>
        /// Fires when a component is removed from an Ext.container.Container
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="ownerCt"><p>Container which holds the component</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void removed(Ext.Component @this, Ext.container.Container ownerCt, object eOpts){}
        /// <summary>
        /// Fires after the component markup is rendered.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void render(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires after the component is resized. Note that this does not fire when the component is first layed out at its initial
        /// size. To hook that point in the lifecycle, use the boxready event.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="width"><p>The new width that was set</p>
        /// </param>
        /// <param name="height"><p>The new height that was set</p>
        /// </param>
        /// <param name="oldWidth"><p>The previous width</p>
        /// </param>
        /// <param name="oldHeight"><p>The previous height</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void resize(Ext.Component @this, JsNumber width, JsNumber height, JsNumber oldWidth, JsNumber oldHeight, object eOpts){}
        /// <summary>
        /// Fires after the component is shown when calling the show method.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void show(Ext.Component @this, object eOpts){}
        /// <summary>
        /// Fires after the state of the object is restored.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="state"><p>The hash of state values returned from the StateProvider. This is passed
        /// to <b><tt>applyState</tt></b>. By default, that simply copies property values into this
        /// object. The method maybe overriden to provide custom state restoration.</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void staterestore(Ext.state.Stateful @this, object state, object eOpts){}
        /// <summary>
        /// Fires after the state of the object is saved to the configured state provider.
        /// </summary>
        /// <param name="this">
        /// </param>
        /// <param name="state"><p>The hash of state values. This is determined by calling
        /// <b><tt>getState()</tt></b> on the object. This method must be provided by the
        /// developer to return whetever representation of state is required, by default, <see cref="Ext.state.Stateful">Ext.state.Stateful</see>
        /// has a null implementation.</p>
        /// </param>
        /// <param name="eOpts"><p>The options object passed to <see cref="Ext.util.Observable.addListener">Ext.util.Observable.addListener</see>.</p>
        /// </param>
        public void statesave(Ext.state.Stateful @this, object state, object eOpts){}
        public AbstractComponentEvents(params object[] args){}
    }
    #endregion
}
