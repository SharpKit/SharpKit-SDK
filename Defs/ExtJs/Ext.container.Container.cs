//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.container
{
    #region Container
    /// <inheritdocs />
    /// <summary>
    /// <p>Base class for any <see cref="Ext.Component">Ext.Component</see> that may contain other Components. Containers handle the basic behavior of
    /// containing items, namely adding, inserting and removing items.</p>
    /// <p>The most commonly used Container classes are <see cref="Ext.panel.Panel">Ext.panel.Panel</see>, <see cref="Ext.window.Window">Ext.window.Window</see> and
    /// <see cref="Ext.tab.Panel">Ext.tab.Panel</see>. If you do not need the capabilities offered by the aforementioned classes you can create a
    /// lightweight Container to be encapsulated by an HTML element to your specifications by using the
    /// <see cref="Ext.ComponentConfig.autoEl">autoEl</see> config option.</p>
    /// <p>The code below illustrates how to explicitly create a Container:</p>
    /// <pre><code>// Explicitly create a Container
    /// <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.container.Container">Ext.container.Container</see>', {
    /// layout: {
    /// type: 'hbox'
    /// },
    /// width: 400,
    /// renderTo: <see cref="Ext.ExtContext.getBody">Ext.getBody</see>(),
    /// border: 1,
    /// style: {borderColor:'#000000', borderStyle:'solid', borderWidth:'1px'},
    /// defaults: {
    /// labelWidth: 80,
    /// // implicitly create Container by specifying xtype
    /// xtype: 'datefield',
    /// flex: 1,
    /// style: {
    /// padding: '10px'
    /// }
    /// },
    /// items: [{
    /// xtype: 'datefield',
    /// name: 'startDate',
    /// fieldLabel: 'Start date'
    /// },{
    /// xtype: 'datefield',
    /// name: 'endDate',
    /// fieldLabel: 'End date'
    /// }]
    /// });
    /// </code></pre>
    /// <h2>Layout</h2>
    /// <p>Container classes delegate the rendering of child Components to a layout manager class which must be configured into
    /// the Container using the <c><see cref="Ext.container.ContainerConfig.layout">layout</see></c> configuration property.</p>
    /// <p>When either specifying child <c><see cref="Ext.container.ContainerConfig.items">items</see></c> of a Container, or dynamically <see cref="Ext.container.Container.add">adding</see> Components to a
    /// Container, remember to consider how you wish the Container to arrange those child elements, and whether those child
    /// elements need to be sized using one of Ext's built-in <c><see cref="Ext.container.ContainerConfig.layout">layout</see></c> schemes. By default, Containers use the
    /// <see cref="Ext.layout.container.Auto">Auto</see> scheme which only renders child components, appending them one after the other
    /// inside the Container, and <strong>does not apply any sizing</strong> at all.</p>
    /// <p>A common mistake is when a developer neglects to specify a <c><see cref="Ext.container.ContainerConfig.layout">layout</see></c> (e.g. widgets like GridPanels or
    /// TreePanels are added to Containers for which no <c><see cref="Ext.container.ContainerConfig.layout">layout</see></c> has been specified). If a Container is left to
    /// use the default <see cref="Ext.layout.container.Auto">Auto</see> scheme, none of its child components will be resized, or changed in
    /// any way when the Container is resized.</p>
    /// <p>Certain layout managers allow dynamic addition of child components. Those that do include
    /// <see cref="Ext.layout.container.Card">Ext.layout.container.Card</see>, <see cref="Ext.layout.container.Anchor">Ext.layout.container.Anchor</see>, <see cref="Ext.layout.container.VBox">Ext.layout.container.VBox</see>,
    /// <see cref="Ext.layout.container.HBox">Ext.layout.container.HBox</see>, and <see cref="Ext.layout.container.Table">Ext.layout.container.Table</see>. For example:</p>
    /// <pre><code>//  Create the GridPanel.
    /// var myNewGrid = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.grid.Panel">Ext.grid.Panel</see>', {
    /// store: myStore,
    /// headers: myHeaders,
    /// title: 'Results', // the title becomes the title of the tab
    /// });
    /// myTabPanel.add(myNewGrid); // <see cref="Ext.tab.Panel">Ext.tab.Panel</see> implicitly uses <see cref="Ext.layout.container.Card">Card</see>
    /// myTabPanel.<see cref="Ext.tab.Panel.setActiveTab">setActiveTab</see>(myNewGrid);
    /// </code></pre>
    /// <p>The example above adds a newly created GridPanel to a TabPanel. Note that a TabPanel uses <see cref="Ext.layout.container.Card">Ext.layout.container.Card</see> as its layout manager which means all its child items are sized to <see cref="Ext.layout.container.Fit">fit</see> exactly into its client area.</p>
    /// <p><strong><em>Overnesting is a common problem</em></strong>. An example of overnesting occurs when a GridPanel is added to a TabPanel by
    /// wrapping the GridPanel <em>inside</em> a wrapping Panel (that has no <c><see cref="Ext.container.ContainerConfig.layout">layout</see></c> specified) and then add that
    /// wrapping Panel to the TabPanel. The point to realize is that a GridPanel <strong>is</strong> a Component which can be added
    /// directly to a Container. If the wrapping Panel has no <c><see cref="Ext.container.ContainerConfig.layout">layout</see></c> configuration, then the overnested
    /// GridPanel will not be sized as expected.</p>
    /// <h2>Adding via remote configuration</h2>
    /// <p>A server side script can be used to add Components which are generated dynamically on the server. An example of
    /// adding a GridPanel to a TabPanel where the GridPanel is generated by the server based on certain parameters:</p>
    /// <pre><code>// execute an Ajax request to invoke server side script:
    /// <see cref="Ext.Ajax.request">Ext.Ajax.request</see>({
    /// url: 'gen-invoice-grid.php',
    /// // send additional parameters to instruct server script
    /// params: {
    /// startDate: <see cref="Ext.ExtContext.getCmp">Ext.getCmp</see>('start-date').getValue(),
    /// endDate: <see cref="Ext.ExtContext.getCmp">Ext.getCmp</see>('end-date').getValue()
    /// },
    /// // process the response object to add it to the TabPanel:
    /// success: function(xhr) {
    /// var newComponent = eval(xhr.responseText); // see discussion below
    /// myTabPanel.add(newComponent); // add the component to the TabPanel
    /// myTabPanel.setActiveTab(newComponent);
    /// },
    /// failure: function() {
    /// <see cref="Ext.MessageBox.alert">Ext.Msg.alert</see>("Grid create failed", "Server communication failure");
    /// }
    /// });
    /// </code></pre>
    /// <p>The server script needs to return a JSON representation of a configuration object, which, when decoded will return a
    /// config object with an <see cref="Ext.ComponentConfig.xtype">xtype</see>. The server might return the following JSON:</p>
    /// <pre><code>{
    /// "xtype": 'grid',
    /// "title": 'Invoice Report',
    /// "store": {
    /// "model": 'Invoice',
    /// "proxy": {
    /// "type": 'ajax',
    /// "url": 'get-invoice-data.php',
    /// "reader": {
    /// "type": 'json'
    /// "record": 'transaction',
    /// "idProperty": 'id',
    /// "totalRecords": 'total'
    /// })
    /// },
    /// "autoLoad": {
    /// "params": {
    /// "startDate": '01/01/2008',
    /// "endDate": '01/31/2008'
    /// }
    /// }
    /// },
    /// "headers": [
    /// {"header": "Customer", "width": 250, "dataIndex": 'customer', "sortable": true},
    /// {"header": "Invoice Number", "width": 120, "dataIndex": 'invNo', "sortable": true},
    /// {"header": "Invoice Date", "width": 100, "dataIndex": 'date', "renderer": <see cref="Ext.util.Format.dateRenderer">Ext.util.Format.dateRenderer</see>('M d, y'), "sortable": true},
    /// {"header": "Value", "width": 120, "dataIndex": 'value', "renderer": 'usMoney', "sortable": true}
    /// ]
    /// }
    /// </code></pre>
    /// <p>When the above code fragment is passed through the <c>eval</c> function in the success handler of the Ajax request, the
    /// result will be a config object which, when added to a Container, will cause instantiation of a GridPanel. <strong>Be sure
    /// that the Container is configured with a layout which sizes and positions the child items to your requirements.</strong></p>
    /// <p><strong>Note:</strong> since the code above is <em>generated</em> by a server script, the <c>autoLoad</c> params for the Store, the user's
    /// preferred date format, the metadata to allow generation of the Model layout, and the ColumnModel can all be generated
    /// into the code since these are all known on the server.</p>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Container : AbstractContainer
    {
        /// <summary>
        /// Defines the anchoring size of container.
        /// Either a number to define the width of the container or an object with width and height fields.
        /// </summary>
        public object anchorSize;
        /// <summary>
        /// Return the immediate child Component in which the passed element is located.
        /// </summary>
        /// <param name="el"><p>The element to test (or ID of element).</p>
        /// </param>
        /// <param name="deep"><p>If <c>true</c>, returns the deepest descendant Component which contains the passed element.</p>
        /// </param>
        /// <returns>
        /// <span><see cref="Ext.Component">Ext.Component</see></span><div><p>The child item which contains the passed element.</p>
        /// </div>
        /// </returns>
        public Ext.Component getChildByElement(object el, bool deep){return null;}
        public Container(Ext.container.ContainerConfig config){}
        public Container(){}
        public Container(params object[] args){}
    }
    #endregion
    #region ContainerConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ContainerConfig : AbstractContainerConfig
    {
        /// <summary>
        /// Defines the anchoring size of container.
        /// Either a number to define the width of the container or an object with width and height fields.
        /// </summary>
        public object anchorSize;
        public ContainerConfig(params object[] args){}
    }
    #endregion
    #region ContainerEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class ContainerEvents : AbstractContainerEvents
    {
        public ContainerEvents(params object[] args){}
    }
    #endregion
}
