//***************************************************
//* This file was generated by tool
//* SharpKit
//* At: 29/08/2012 03:59:39 p.m.
//***************************************************
using SharpKit.JavaScript;
namespace Ext.data.reader
{
    #region Json
    /// <inheritdocs />
    /// <summary>
    /// <p>The JSON Reader is used by a Proxy to read a server response that is sent back in JSON format. This usually
    /// happens as a result of loading a Store - for example we might create something like this:</p>
    /// <pre><code><see cref="Ext.ExtContext.define">Ext.define</see>('User', {
    /// extend: '<see cref="Ext.data.Model">Ext.data.Model</see>',
    /// fields: ['id', 'name', 'email']
    /// });
    /// var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// model: 'User',
    /// proxy: {
    /// type: 'ajax',
    /// url : 'users.json',
    /// reader: {
    /// type: 'json'
    /// }
    /// }
    /// });
    /// </code></pre>
    /// <p>The example above creates a 'User' model. Models are explained in the <see cref="Ext.data.Model">Model</see> docs if you're
    /// not already familiar with them.</p>
    /// <p>We created the simplest type of JSON Reader possible by simply telling our <see cref="Ext.data.Store">Store</see>'s
    /// <see cref="Ext.data.proxy.Proxy">Proxy</see> that we want a JSON Reader. The Store automatically passes the configured model to the
    /// Store, so it is as if we passed this instead:</p>
    /// <pre><code>reader: {
    /// type : 'json',
    /// model: 'User'
    /// }
    /// </code></pre>
    /// <p>The reader we set up is ready to read data from our server - at the moment it will accept a response like this:</p>
    /// <pre><code>[
    /// {
    /// "id": 1,
    /// "name": "Ed Spencer",
    /// "email": "ed@sencha.com"
    /// },
    /// {
    /// "id": 2,
    /// "name": "Abe Elias",
    /// "email": "abe@sencha.com"
    /// }
    /// ]
    /// </code></pre>
    /// <h2>Reading other JSON formats</h2>
    /// <p>If you already have your JSON format defined and it doesn't look quite like what we have above, you can usually
    /// pass JsonReader a couple of configuration options to make it parse your format. For example, we can use the
    /// <see cref="Ext.data.reader.JsonConfig.root">root</see> configuration to parse data that comes back like this:</p>
    /// <pre><code>{
    /// "users": [
    /// {
    /// "id": 1,
    /// "name": "Ed Spencer",
    /// "email": "ed@sencha.com"
    /// },
    /// {
    /// "id": 2,
    /// "name": "Abe Elias",
    /// "email": "abe@sencha.com"
    /// }
    /// ]
    /// }
    /// </code></pre>
    /// <p>To parse this we just pass in a <see cref="Ext.data.reader.JsonConfig.root">root</see> configuration that matches the 'users' above:</p>
    /// <pre><code>reader: {
    /// type: 'json',
    /// root: 'users'
    /// }
    /// </code></pre>
    /// <p>Sometimes the JSON structure is even more complicated. Document databases like CouchDB often provide metadata
    /// around each record inside a nested structure like this:</p>
    /// <pre><code>{
    /// "total": 122,
    /// "offset": 0,
    /// "users": [
    /// {
    /// "id": "ed-spencer-1",
    /// "value": 1,
    /// "user": {
    /// "id": 1,
    /// "name": "Ed Spencer",
    /// "email": "ed@sencha.com"
    /// }
    /// }
    /// ]
    /// }
    /// </code></pre>
    /// <p>In the case above the record data is nested an additional level inside the "users" array as each "user" item has
    /// additional metadata surrounding it ('id' and 'value' in this case). To parse data out of each "user" item in the
    /// JSON above we need to specify the <see cref="Ext.data.reader.JsonConfig.record">record</see> configuration like this:</p>
    /// <pre><code>reader: {
    /// type  : 'json',
    /// root  : 'users',
    /// record: 'user'
    /// }
    /// </code></pre>
    /// <h2>Response MetaData</h2>
    /// <p>The server can return metadata in its response, in addition to the record data, that describe attributes
    /// of the data set itself or are used to reconfigure the Reader. To pass metadata in the response you simply
    /// add a <c>metaData</c> attribute to the root of the response data. The metaData attribute can contain anything,
    /// but supports a specific set of properties that are handled by the Reader if they are present:</p>
    /// <ul>
    /// <li><see cref="Ext.data.reader.JsonConfig.root">root</see>: the property name of the root response node containing the record data</li>
    /// <li><see cref="Ext.data.reader.JsonConfig.idProperty">idProperty</see>: property name for the primary key field of the data</li>
    /// <li><see cref="Ext.data.reader.JsonConfig.totalProperty">totalProperty</see>: property name for the total number of records in the data</li>
    /// <li><see cref="Ext.data.reader.JsonConfig.successProperty">successProperty</see>: property name for the success status of the response</li>
    /// <li><see cref="Ext.data.reader.JsonConfig.messageProperty">messageProperty</see>: property name for an optional response message</li>
    /// <li><see cref="Ext.data.ModelConfig.fields">fields</see>: Config used to reconfigure the Model's fields before converting the
    /// response data into records</li>
    /// </ul>
    /// <p>An initial Reader configuration containing all of these properties might look like this ("fields" would be
    /// included in the Model definition, not shown):</p>
    /// <pre><code>reader: {
    /// type : 'json',
    /// root : 'root',
    /// idProperty     : 'id',
    /// totalProperty  : 'total',
    /// successProperty: 'success',
    /// messageProperty: 'message'
    /// }
    /// </code></pre>
    /// <p>If you were to pass a response object containing attributes different from those initially defined above, you could
    /// use the <c>metaData</c> attribute to reconifgure the Reader on the fly. For example:</p>
    /// <pre><code>{
    /// "count": 1,
    /// "ok": true,
    /// "msg": "Users found",
    /// "users": [{
    /// "userId": 123,
    /// "name": "Ed Spencer",
    /// "email": "ed@sencha.com"
    /// }],
    /// "metaData": {
    /// "root": "users",
    /// "idProperty": 'userId',
    /// "totalProperty": 'count',
    /// "successProperty": 'ok',
    /// "messageProperty": 'msg'
    /// }
    /// }
    /// </code></pre>
    /// <p>You can also place any other arbitrary data you need into the <c>metaData</c> attribute which will be ignored by the Reader,
    /// but will be accessible via the Reader's <see cref="Ext.data.reader.Json.metaData">metaData</see> property (which is also passed to listeners via the Proxy's
    /// <see cref="Ext.data.proxy.ProxyEvents.metachange">metachange</see> event (also relayed by the <see cref="Ext.data.AbstractStoreEvents.metachange">store</see>). Application code can then process the passed metadata in any way it chooses.</p>
    /// <p>A simple example for how this can be used would be customizing the fields for a Model that is bound to a grid. By passing
    /// the <c>fields</c> property the Model will be automatically updated by the Reader internally, but that change will not be
    /// reflected automatically in the grid unless you also update the column configuration. You could do this manually, or you
    /// could simply pass a standard grid <see cref="Ext.panel.TableConfig.columns">column</see> config object as part of the <c>metaData</c> attribute
    /// and then pass that along to the grid. Here's a very simple example for how that could be accomplished:</p>
    /// <pre><code>// response format:
    /// {
    /// ...
    /// "metaData": {
    /// "fields": [
    /// { "name": "userId", "type": "int" },
    /// { "name": "name", "type": "string" },
    /// { "name": "birthday", "type": "date", "dateFormat": "Y-j-m" },
    /// ],
    /// "columns": [
    /// { "text": "User ID", "dataIndex": "userId", "width": 40 },
    /// { "text": "User Name", "dataIndex": "name", "flex": 1 },
    /// { "text": "Birthday", "dataIndex": "birthday", "flex": 1, "format": 'Y-j-m', "xtype": "datecolumn" }
    /// ]
    /// }
    /// }
    /// </code></pre>
    /// <p>The Reader will automatically read the meta fields config and rebuild the Model based on the new fields, but to handle
    /// the new column configuration you would need to handle the metadata within the application code. This is done simply enough
    /// by handling the metachange event on either the store or the proxy, e.g.:</p>
    /// <pre><code>var store = <see cref="Ext.ExtContext.create">Ext.create</see>('<see cref="Ext.data.Store">Ext.data.Store</see>', {
    /// ...
    /// listeners: {
    /// 'metachange': function(store, meta) {
    /// myGrid.reconfigure(store, meta.columns);
    /// }
    /// }
    /// });
    /// </code></pre>
    /// </summary>
    [JsType(JsMode.Prototype, Export=false, OmitOptionalParameters=true)]
    public partial class Json : Reader
    {
        /// <summary>
        /// The optional location within the JSON response that the record data itself can be found at.
        /// See the JsonReader intro docs for more details. This is not often needed.
        /// </summary>
        public JsString record;
        /// <summary>
        /// True to ensure that field names/mappings are treated as literals when
        /// reading values.
        /// For example, by default, using the mapping "foo.bar.baz" will try and read a property foo from the root, then a property bar
        /// from foo, then a property baz from bar. Setting the simple accessors to true will read the property with the name
        /// "foo.bar.baz" direct from the root object.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool useSimpleAccessors;
        /// <summary>
        /// A copy of this.rawData.
        /// <p>This property has been <strong>deprecated</strong> </p>
        /// <p>Will be removed in Ext JS 5.0. This is just a copy of this.rawData - use that instead.</p>
        /// </summary>
        public JsObject jsonData{get;set;}
        /// <summary>
        /// Returns an accessor function for the given property string. Gives support for properties such as the following:
        /// <li>'someProperty'</li>
        /// <li>'some.property'</li>
        /// <li>'some["property"]'</li>
        /// This is used by buildExtractors to create optimized extractor functions when casting raw data into model instances.
        /// </summary>
        private void createAccessor(){}
        /// <summary>
        /// Returns an accessor expression for the passed Field. Gives support for properties such as the following:
        /// <li>'someProperty'</li>
        /// <li>'some.property'</li>
        /// <li>'some["property"]'</li>
        /// This is used by buildExtractors to create optimized on extractor function which converts raw data into model instances.
        /// </summary>
        private void createFieldAccessExpression(){}
        public Json(Ext.data.reader.JsonConfig config){}
        public Json(){}
        public Json(params object[] args){}
    }
    #endregion
    #region JsonConfig
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class JsonConfig : ReaderConfig
    {
        /// <summary>
        /// The optional location within the JSON response that the record data itself can be found at.
        /// See the JsonReader intro docs for more details. This is not often needed.
        /// </summary>
        public JsString record;
        /// <summary>
        /// True to ensure that field names/mappings are treated as literals when
        /// reading values.
        /// For example, by default, using the mapping "foo.bar.baz" will try and read a property foo from the root, then a property bar
        /// from foo, then a property baz from bar. Setting the simple accessors to true will read the property with the name
        /// "foo.bar.baz" direct from the root object.
        /// Defaults to: <c>false</c>
        /// </summary>
        public bool useSimpleAccessors;
        public JsonConfig(params object[] args){}
    }
    #endregion
    #region JsonEvents
    /// <inheritdocs />
    [JsType(JsMode.Json, Export=false, OmitOptionalParameters=true)]
    public partial class JsonEvents : ReaderEvents
    {
        public JsonEvents(params object[] args){}
    }
    #endregion
}
