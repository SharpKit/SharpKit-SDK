//***************************************************
//* This file was generated by tool
//* SharpKit
//***************************************************
using System;
using System.Collections.Generic;
using SharpKit.JavaScript;
namespace Y_.Text_
{
    /// <summary>
    /// <p>
    /// Provides a basic accent folding implementation that converts common accented
    /// letters (like "á") to their non-accented forms (like "a").
    /// </p>
    /// <p>
    /// This implementation is not comprehensive, and should only be used as a last
    /// resort when accent folding can't be done on the server. A comprehensive
    /// accent folding implementation would require much more character data to be
    /// sent to the browser, resulting in a significant performance penalty. This
    /// implementation strives for a compromise between usefulness and performance.
    /// </p>
    /// <p>
    /// Accent folding is a destructive operation that can't be reversed, and may
    /// change or destroy the actual meaning of the text depending on the language.
    /// It should not be used on strings that will later be displayed to a user,
    /// unless this is done with the understanding that linguistic meaning may be
    /// lost and that you may in fact confuse or insult the user by doing so.
    /// </p>
    /// <p>
    /// When used for matching, accent folding is likely to produce erroneous matches
    /// for languages in which characters with diacritics are considered different
    /// from their base characters, or where correct folding would map to other
    /// character sequences than just stripped characters. For example, in German
    /// "ü" is a character that's clearly different from "u" and should match "ue"
    /// instead. The word "betrügen" means "to defraud", while "betrugen" is the past
    /// tense of "to behave". The name "Müller" is expected to match "Mueller", but
    /// not "Muller". On the other hand, accent folding falls short for languages
    /// where different base characters are expected to match. In Japanese, for
    /// example, hiragana and katakana characters with the same pronunciation ("あ"
    /// and "ア") are commonly treated as equivalent for lookups, but accent folding
    /// treats them as different.
    /// </p>
    /// </summary>
    public partial class AccentFold
    {
        /// <summary>
        /// Returns <code>true</code> if the specified string contains one or more
        /// characters that can be folded, <code>false</code> otherwise.
        /// </summary>
        public object canFold(object @string){return null;}
        /// <summary>
        /// Compares the accent-folded versions of two strings and returns
        /// <code>true</code> if they're the same, <code>false</code> otherwise. If
        /// a custom comparison function is supplied, the accent-folded strings will
        /// be passed to that function for comparison.
        /// </summary>
        public object compare(object a, object b, JsAction func){return null;}
        /// <summary>
        /// <p>
        /// Returns a copy of <em>haystack</em> containing only the strings for which
        /// the supplied function returns <code>true</code>.
        /// </p>
        /// <p>
        /// While comparisons will be made using accent-folded strings, the returned
        /// array of matches will contain the original strings that were passed in.
        /// </p>
        /// </summary>
        public Y_.Array filter(Y_.Array haystack, JsAction func){return null;}
        /// <summary>
        /// Accent-folds the specified string or array of strings and returns a copy
        /// in which common accented letters have been converted to their closest
        /// non-accented, lowercase forms.
        /// </summary>
        public object fold(object input){return null;}
    }
}
