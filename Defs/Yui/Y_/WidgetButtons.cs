//***************************************************
//* This file was generated by tool
//* SharpKit
//***************************************************
using System;
using System.Collections.Generic;
using SharpKit.JavaScript;
namespace Y_
{
    /// <summary>
    /// Provides header/body/footer button support for Widgets that use the
    /// `WidgetStdMod` extension.
    /// This Widget extension makes it easy to declaratively configure a widget's
    /// buttons. It adds a `buttons` attribute along with button- accessor and mutator
    /// methods. All button nodes have the `Y.Plugin.Button` plugin applied.
    /// This extension also includes `HTML_PARSER` support to seed a widget's `buttons`
    /// from those which already exist in its DOM.
    /// </summary>
    public partial class WidgetButtons
    {
        /// <summary>
        /// Handles this widget's `buttonsChange` event which fires anytime the
        /// `buttons` attribute is modified.
        /// **Note:** This method special-cases the `buttons` modifications caused by
        /// `addButton()` and `removeButton()`, both of which set the `src` property on
        /// the event facade to "add" and "remove" respectively.
        /// </summary>
        protected void _afterButtonsChange(EventFacade e){}
        /// <summary>
        /// Handles this widget's `headerContentChange`, `bodyContentChange`,
        /// `footerContentChange` events by making sure the `buttons` remain rendered
        /// after changes to the content areas.
        /// These events are very chatty, so extra caution is taken to avoid doing extra
        /// work or getting into an infinite loop.
        /// </summary>
        protected void _afterContentChangeButtons(EventFacade e){}
        /// <summary>
        /// Handles this widget's `defaultButtonChange` event by adding the
        /// "yui3-button-primary" CSS class to the new `defaultButton` and removing it
        /// from the old default button.
        /// </summary>
        protected void _afterDefaultButtonChange(EventFacade e){}
        /// <summary>
        /// Handles this widget's `visibleChange` event by focusing the `defaultButton`
        /// if there is one.
        /// </summary>
        protected void _afterVisibleChangeButtons(EventFacade e){}
        /// <summary>
        /// Binds UI event listeners. This method is inserted via AOP, and will execute
        /// after `bindUI()`.
        /// </summary>
        protected void _bindUIButtons(){}
        /// <summary>
        /// Returns a button node based on the specified `button` node or configuration.
        /// The button node will either be created via `Y.Plugin.Button.createNode()`,
        /// or when `button` is specified as a node already, it will by `plug()`ed with
        /// `Y.Plugin.Button`.
        /// </summary>
        protected Node _createButton(object button){return null;}
        [JsMethod(JsonInitializers=true)]
        public WidgetButtons(){}
        /// <summary>
        /// Returns the buttons container for the specified `section`, passing a truthy
        /// value for `create` will create the node if it does not already exist.
        /// **Note:** It is up to the caller to properly insert the returned container
        /// node into the content section.
        /// </summary>
        protected Node _getButtonContainer(object section, object create){return null;}
        /// <summary>
        /// Returns whether or not the specified `button` is configured to be the
        /// default button.
        /// When a button node is specified, the button's `getData()` method will be
        /// used to determine if the button is configured to be the default. When a
        /// button config object is specified, the `isDefault` prop will determine
        /// whether the button is the default.
        /// **Note:** `<button data-default="true"></button>` is supported via the
        /// `button.getData('default')` API call.
        /// </summary>
        protected object _getButtonDefault(object button){return null;}
        /// <summary>
        /// Returns the name of the specified `button`.
        /// When a button node is specified, the button's `getData('name')` method is
        /// preferred, but will fallback to `get('name')`, and the result will determine
        /// the button's name. When a button config object is specified, the `name` prop
        /// will determine the button's name.
        /// **Note:** `<button data-name="foo"></button>` is supported via the
        /// `button.getData('name')` API call.
        /// </summary>
        protected object _getButtonName(object button){return null;}
        /// <summary>
        /// Getter for the `buttons` attribute. A copy of the `buttons` object is
        /// returned so the stored state cannot be modified by the callers of
        /// `get('buttons')`.
        /// This will recreate a copy of the `buttons` object, and each section array
        /// (the button nodes are *not* copied/cloned.)
        /// </summary>
        protected object _getButtons(object buttons){return null;}
        /// <summary>
        /// Adds the specified `button` to the buttons map (both name -> button and
        /// section:name -> button), and sets the button as the default if it is
        /// configured as the default button.
        /// **Note:** If two or more buttons are configured with the same `name` and/or
        /// configured to be the default button, the last one wins.
        /// </summary>
        protected void _mapButton(Node button, object section){}
        /// <summary>
        /// Adds the specified `buttons` to the buttons map (both name -> button and
        /// section:name -> button), and set the a button as the default if one is
        /// configured as the default button.
        /// **Note:** This will clear all previous button mappings and null-out any
        /// previous default button! If two or more buttons are configured with the same
        /// `name` and/or configured to be the default button, the last one wins.
        /// </summary>
        protected void _mapButtons(object buttons){}
        /// <summary>
        /// Returns a copy of the specified `config` object merged with any defaults
        /// provided by a `srcNode` and/or a predefined configuration for a button
        /// with the same `name` on the `BUTTONS` property.
        /// </summary>
        protected object _mergeButtonConfig(object config){return null;}
        /// <summary>
        /// `HTML_PARSER` implementation for the `buttons` attribute.
        /// **Note:** To determine a button node's name its `data-name` and `name`
        /// attributes are examined. Whether the button should be the default is
        /// determined by its `data-default` attribute.
        /// </summary>
        protected object _parseButtons(Node srcNode){return null;}
        /// <summary>
        /// Setter for the `buttons` attribute. This processes the specified `config`
        /// and returns a new `buttons` object which is stored as the new state; leaving
        /// the original, specified `config` unmodified.
        /// The button nodes will either be created via `Y.Plugin.Button.createNode()`,
        /// or when a button is already a Node already, it will by `plug()`ed with
        /// `Y.Plugin.Button`.
        /// </summary>
        protected object _setButtons(object config){return null;}
        /// <summary>
        /// Syncs this widget's current button-related state to its DOM. This method is
        /// inserted via AOP, and will execute after `syncUI()`.
        /// </summary>
        protected void _syncUIButtons(){}
        /// <summary>
        /// Inserts the specified `button` node into this widget's DOM at the specified
        /// `section` and `index` and updates the section content.
        /// The section and button container nodes will be created if they do not
        /// already exist.
        /// </summary>
        protected void _uiInsertButton(Node button, object section, Y_.DataType_.Number index){}
        /// <summary>
        /// Removes the button node from this widget's DOM and detaches any event
        /// subscriptions on the button that were created by this widget. The section
        /// content will be updated unless `{preserveContent: true}` is passed in the
        /// `options`.
        /// By default the button container node will be removed when this removes the
        /// last button of the specified `section`; and if no other content remains in
        /// the section node, it will also be removed.
        /// </summary>
        protected void _uiRemoveButton(Node button, object section){}
        /// <summary>
        /// Removes the button node from this widget's DOM and detaches any event
        /// subscriptions on the button that were created by this widget. The section
        /// content will be updated unless `{preserveContent: true}` is passed in the
        /// `options`.
        /// By default the button container node will be removed when this removes the
        /// last button of the specified `section`; and if no other content remains in
        /// the section node, it will also be removed.
        /// </summary>
        protected void _uiRemoveButton(Node button, object section, object options){}
        /// <summary>
        /// Sets the current `buttons` state to this widget's DOM by rendering the
        /// specified collection of `buttons` and updates the contents of each section
        /// as needed.
        /// Button nodes which already exist in the DOM will remain intact, or will be
        /// moved if they should be in a new position. Old button nodes which are no
        /// longer represented in the specified `buttons` collection will be removed,
        /// and any event subscriptions on the button which were created by this widget
        /// will be detached.
        /// If the button nodes in this widget's DOM actually change, then each content
        /// section will be updated (or removed) appropriately.
        /// </summary>
        protected void _uiSetButtons(object buttons){}
        /// <summary>
        /// Adds the "yui3-button-primary" CSS class to the new `defaultButton` and
        /// removes it from the old default button.
        /// </summary>
        protected void _uiSetDefaultButton(Node newButton, Node oldButton){}
        /// <summary>
        /// Focuses this widget's `defaultButton` if there is one and this widget is
        /// visible.
        /// </summary>
        protected void _uiSetVisibleButtons(object visible){}
        /// <summary>
        /// Removes the specified `button` to the buttons map, and nulls-out the
        /// `defaultButton` if it is currently the default button.
        /// </summary>
        protected void _unMapButton(Node button){}
        /// <summary>
        /// Updates the content attribute which corresponds to the specified `section`.
        /// The method updates the section's content to its current `childNodes`
        /// (text and/or HTMLElement), or will null-out its contents if the section is
        /// empty. It also specifies a `src` of `buttons` on the change event facade.
        /// </summary>
        protected void _updateContentButtons(object section){}
        /// <summary>
        /// Updates the `defaultButton` attribute if it needs to be updated by comparing
        /// its current value with the protected `_defaultButton` property.
        /// </summary>
        protected void _updateDefaultButton(){}
        /// <summary>
        /// Adds a button to this widget.
        /// The new button node will have the `Y.Plugin.Button` plugin applied, be added
        /// to this widget's `buttons`, and rendered in the specified `section` at the
        /// specified `index` (or end of the section). If the section does not exist, it
        /// will be created.
        /// This fires the `buttonsChange` event and adds the following properties to
        /// the event facade:
        /// * `button`: The button node or config object to add.
        /// * `section`: The `WidgetStdMod` section (header/body/footer) where the
        /// button should be added.
        /// * `index`: The index at which to add the button to the section.
        /// * `src`: "add"
        /// </summary>
        public void addButton(object button){}
        /// <summary>
        /// Adds a button to this widget.
        /// The new button node will have the `Y.Plugin.Button` plugin applied, be added
        /// to this widget's `buttons`, and rendered in the specified `section` at the
        /// specified `index` (or end of the section). If the section does not exist, it
        /// will be created.
        /// This fires the `buttonsChange` event and adds the following properties to
        /// the event facade:
        /// * `button`: The button node or config object to add.
        /// * `section`: The `WidgetStdMod` section (header/body/footer) where the
        /// button should be added.
        /// * `index`: The index at which to add the button to the section.
        /// * `src`: "add"
        /// </summary>
        public void addButton(object button, Y_.DataType_.Number index){}
        /// <summary>
        /// Adds a button to this widget.
        /// The new button node will have the `Y.Plugin.Button` plugin applied, be added
        /// to this widget's `buttons`, and rendered in the specified `section` at the
        /// specified `index` (or end of the section). If the section does not exist, it
        /// will be created.
        /// This fires the `buttonsChange` event and adds the following properties to
        /// the event facade:
        /// * `button`: The button node or config object to add.
        /// * `section`: The `WidgetStdMod` section (header/body/footer) where the
        /// button should be added.
        /// * `index`: The index at which to add the button to the section.
        /// * `src`: "add"
        /// </summary>
        public void addButton(object button, object section){}
        /// <summary>
        /// Adds a button to this widget.
        /// The new button node will have the `Y.Plugin.Button` plugin applied, be added
        /// to this widget's `buttons`, and rendered in the specified `section` at the
        /// specified `index` (or end of the section). If the section does not exist, it
        /// will be created.
        /// This fires the `buttonsChange` event and adds the following properties to
        /// the event facade:
        /// * `button`: The button node or config object to add.
        /// * `section`: The `WidgetStdMod` section (header/body/footer) where the
        /// button should be added.
        /// * `index`: The index at which to add the button to the section.
        /// * `src`: "add"
        /// </summary>
        public void addButton(object button, object section, Y_.DataType_.Number index){}
        /// <summary>
        /// Returns a button node from this widget's `buttons`.
        /// </summary>
        public Node getButton(object name){return null;}
        /// <summary>
        /// Returns a button node from this widget's `buttons`.
        /// </summary>
        public Node getButton(object name, object section){return null;}
        /// <summary>
        /// Removes a button from this widget.
        /// The button will be removed from this widget's `buttons` and its DOM. Any
        /// event subscriptions on the button which were created by this widget will be
        /// detached. If the content section becomes empty after removing the button
        /// node, then the section will also be removed.
        /// This fires the `buttonsChange` event and adds the following properties to
        /// the event facade:
        /// * `button`: The button node to remove.
        /// * `section`: The `WidgetStdMod` section (header/body/footer) where the
        /// button should be removed from.
        /// * `index`: The index at which at which the button exists in the section.
        /// * `src`: "remove"
        /// </summary>
        public void removeButton(object button){}
        /// <summary>
        /// Removes a button from this widget.
        /// The button will be removed from this widget's `buttons` and its DOM. Any
        /// event subscriptions on the button which were created by this widget will be
        /// detached. If the content section becomes empty after removing the button
        /// node, then the section will also be removed.
        /// This fires the `buttonsChange` event and adds the following properties to
        /// the event facade:
        /// * `button`: The button node to remove.
        /// * `section`: The `WidgetStdMod` section (header/body/footer) where the
        /// button should be removed from.
        /// * `index`: The index at which at which the button exists in the section.
        /// * `src`: "remove"
        /// </summary>
        public void removeButton(object button, object section){}
        /// <summary>
        /// A map of button node `_yuid` -> event-handle for all button nodes which were
        /// created by this widget.
        /// </summary>
        protected object _buttonsHandles{get;set;}
        /// <summary>
        /// A map of this widget's `buttons`, both name -> button and
        /// section:name -> button.
        /// </summary>
        protected object _buttonsMap{get;set;}
        /// <summary>
        /// Internal reference to this widget's default button.
        /// </summary>
        protected Node _defaultButton{get;set;}
        /// <summary>
        /// Collection containing a widget's buttons.
        /// The collection is an Object which contains an Array of `Y.Node`s for every
        /// `WidgetStdMod` section (header, body, footer) which has one or more buttons.
        /// All button nodes have the `Y.Plugin.Button` plugin applied.
        /// This attribute is very flexible in the values it will accept. `buttons` can
        /// be specified as a single Array, or an Object of Arrays keyed to a particular
        /// section.
        /// All specified values will be normalized to this type of structure:
        /// {
        /// header: [...],
        /// footer: [...]
        /// }
        /// A button can be specified as a `Y.Node`, config Object, or String name for a
        /// predefined button on the `BUTTONS` prototype property. When a config Object
        /// is provided, it will be merged with any defaults provided by a button with
        /// the same `name` defined on the `BUTTONS` property.
        /// See `addButton()` for the detailed list of configuration properties.
        /// For convenience, a widget's buttons will always persist and remain rendered
        /// after header/body/footer content updates. Buttons should be removed by
        /// updating this attribute or using the `removeButton()` method.
        /// </summary>
        public object buttons{get;set;}
        /// <summary>
        /// Collection of predefined buttons mapped by name -> config.
        /// These button configurations will serve as defaults for any button added to a
        /// widget's buttons which have the same `name`.
        /// See `addButton()` for a list of possible configuration values.
        /// </summary>
        public object BUTTONS{get;set;}
        /// <summary>
        /// CSS classes used by `WidgetButtons`.
        /// </summary>
        public object CLASS_NAMES{get;set;}
        /// <summary>
        /// The current default button as configured through this widget's `buttons`.
        /// A button can be configured as the default button in the following ways:
        /// * As a config Object with an `isDefault` property:
        /// `{label: 'Okay', isDefault: true}`.
        /// * As a Node with a `data-default` attribute:
        /// `<button data-default="true">Okay</button>`.
        /// This attribute is **read-only**; anytime there are changes to this widget's
        /// `buttons`, the `defaultButton` will be updated if needed.
        /// **Note:** If two or more buttons are configured to be the default button,
        /// the last one wins.
        /// </summary>
        public Node defaultButton{get;private set;}
        /// <summary>
        /// The list of button configuration properties which are specific to
        /// `WidgetButtons` and should not be passed to `Y.Plugin.Button.createNode()`.
        /// </summary>
        public Y_.Array NON_BUTTON_NODE_CFG{get;set;}
    }
}
