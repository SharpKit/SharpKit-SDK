//***************************************************
//* This file was generated by tool
//* SharpKit
//***************************************************
using System;
using System.Collections.Generic;
using SharpKit.JavaScript;
namespace Y_
{
    /// <summary>
    /// The event utility provides functions to add and remove event listeners,
    /// event cleansing.  It also tries to automatically remove listeners it
    /// registers during the unload event.
    /// </summary>
    public partial class Event
    {
        /// <summary>
        /// Walks up the parent axis of an event's target, and tests each element
        /// against a supplied filter function.  If any Nodes, including the container,
        /// satisfy the filter, the delegated callback will be triggered for each.
        /// Hosted as a protected property of the `delegate` method (e.g.
        /// `Y.delegate._applyFilter`).
        /// </summary>
        protected Node _applyFilter(JsAction filter, Y_.Array args, CustomEvent ce){return null;}
        /// <summary>
        /// Adds an event listener
        /// </summary>
        public EventHandle attach(object type, JsAction fn, object el, object context, object args){return null;}
        /// <summary>
        /// Compiles a selector string into a filter function to identify whether
        /// Nodes along the parent axis of an event's target should trigger event
        /// notification.
        /// This function is memoized, so previously compiled filter functions are
        /// returned if the same selector string is provided.
        /// This function may be useful when defining synthetic events for delegate
        /// handling.
        /// Hosted as a property of the `delegate` method (e.g. `Y.delegate.compileFilter`).
        /// </summary>
        public JsAction compileFilter(object selector){return null;}
        /// <summary>
        /// <p>Defines a new event in the DOM event system.  Implementers are
        /// responsible for monitoring for a scenario whereby the event is fired.  A
        /// notifier object is provided to the functions identified below.  When the
        /// criteria defining the event are met, call notifier.fire( [args] ); to
        /// execute event subscribers.</p>
        /// <p>The first parameter is the name of the event.  The second parameter is a
        /// configuration object which define the behavior of the event system when the
        /// new event is subscribed to or detached from.  The methods that should be
        /// defined in this configuration object are <code>on</code>,
        /// <code>detach</code>, <code>delegate</code>, and <code>detachDelegate</code>.
        /// You are free to define any other methods or properties needed to define your
        /// event.  Be aware, however, that since the object is used to subclass
        /// SyntheticEvent, you should avoid method names used by SyntheticEvent unless
        /// your intention is to override the default behavior.</p>
        /// <p>This is a list of properties and methods that you can or should specify
        /// in the configuration object:</p>
        /// <dl>
        /// <dt><code>on</code></dt>
        /// <dd><code>function (node, subscription, notifier)</code> The
        /// implementation logic for subscription.  Any special setup you need to
        /// do to create the environment for the event being fired--E.g. native
        /// DOM event subscriptions.  Store subscription related objects and
        /// state on the <code>subscription</code> object.  When the
        /// criteria have been met to fire the synthetic event, call
        /// <code>notifier.fire(e)</code>.  See Notifier's <code>fire()</code>
        /// method for details about what to pass as parameters.</dd>
        /// <dt><code>detach</code></dt>
        /// <dd><code>function (node, subscription, notifier)</code> The
        /// implementation logic for cleaning up a detached subscription. E.g.
        /// detach any DOM subscriptions added in <code>on</code>.</dd>
        /// <dt><code>delegate</code></dt>
        /// <dd><code>function (node, subscription, notifier, filter)</code> The
        /// implementation logic for subscription via <code>Y.delegate</code> or
        /// <code>node.delegate</code>.  The filter is typically either a selector
        /// string or a function.  You can use
        /// <code>Y.delegate.compileFilter(selectorString)</code> to create a
        /// filter function from a selector string if needed.  The filter function
        /// expects an event object as input and should output either null, a
        /// matching Node, or an array of matching Nodes.  Otherwise, this acts
        /// like <code>on</code> DOM event subscriptions.  Store subscription
        /// related objects and information on the <code>subscription</code>
        /// object.  When the criteria have been met to fire the synthetic event,
        /// call <code>notifier.fire(e)</code> as noted above.</dd>
        /// <dt><code>detachDelegate</code></dt>
        /// <dd><code>function (node, subscription, notifier)</code> The
        /// implementation logic for cleaning up a detached delegate subscription.
        /// E.g. detach any DOM delegate subscriptions added in
        /// <code>delegate</code>.</dd>
        /// <dt><code>publishConfig</code></dt>
        /// <dd>(Object) The configuration object that will be used to instantiate
        /// the underlying CustomEvent. See Notifier's <code>fire</code> method
        /// for details.</dd>
        /// <dt><code>processArgs</code></dt
        /// <dd>
        /// <p><code>function (argArray, fromDelegate)</code> Optional method
        /// to extract any additional arguments from the subscription
        /// signature.  Using this allows <code>on</code> or
        /// <code>delegate</code> signatures like
        /// <code>node.on(&quot;hover&quot;, overCallback,
        /// outCallback)</code>.</p>
        /// <p>When processing an atypical argument signature, make sure the
        /// args array is returned to the normal signature before returning
        /// from the function.  For example, in the &quot;hover&quot; example
        /// above, the <code>outCallback</code> needs to be <code>splice</code>d
        /// out of the array.  The expected signature of the args array for
        /// <code>on()</code> subscriptions is:</p>
        /// <pre>
        /// <code>[type, callback, target, contextOverride, argN...]</code>
        /// </pre>
        /// <p>And for <code>delegate()</code>:</p>
        /// <pre>
        /// <code>[type, callback, target, filter, contextOverride, argN...]</code>
        /// </pre>
        /// <p>where <code>target</code> is the node the event is being
        /// subscribed for.  You can see these signatures documented for
        /// <code>Y.on()</code> and <code>Y.delegate()</code> respectively.</p>
        /// <p>Whatever gets returned from the function will be stored on the
        /// <code>subscription</code> object under
        /// <code>subscription._extra</code>.</p></dd>
        /// <dt><code>subMatch</code></dt>
        /// <dd>
        /// <p><code>function (sub, args)</code>  Compares a set of
        /// subscription arguments against a Subscription object to determine
        /// if they match.  The default implementation compares the callback
        /// function against the second argument passed to
        /// <code>Y.on(...)</code> or <code>node.detach(...)</code> etc.</p>
        /// </dd>
        /// </dl>
        /// </summary>
        public SyntheticEvent define(object type, object config, object force){return null;}
        /// <summary>
        /// Defines a new outside event to correspond with the given DOM event.
        /// By default, the created synthetic event name will be the name of the event
        /// with "outside" appended (e.g. "click" becomes "clickoutside"). If you want
        /// a different name for the created Event, pass it as a second argument like so:
        /// <code>Y.Event.defineOutside(eventType, "yonderclick")</code>.
        /// </summary>
        public void defineOutside(object @event, object name){}
        /// <summary>
        /// <p>Sets up event delegation on a container element.  The delegated event
        /// will use a supplied selector or filtering function to test if the event
        /// references at least one node that should trigger the subscription
        /// callback.</p>
        /// <p>Selector string filters will trigger the callback if the event originated
        /// from a node that matches it or is contained in a node that matches it.
        /// Function filters are called for each Node up the parent axis to the
        /// subscribing container node, and receive at each level the Node and the event
        /// object.  The function should return true (or a truthy value) if that Node
        /// should trigger the subscription callback.  Note, it is possible for filters
        /// to match multiple Nodes for a single event.  In this case, the delegate
        /// callback will be executed for each matching Node.</p>
        /// <p>For each matching Node, the callback will be executed with its 'this'
        /// object set to the Node matched by the filter (unless a specific context was
        /// provided during subscription), and the provided event's
        /// <code>currentTarget</code> will also be set to the matching Node.  The
        /// containing Node from which the subscription was originally made can be
        /// referenced as <code>e.container</code>.
        /// </summary>
        public EventHandle @delegate(object type, JsAction fn, object el, object filter, object context, object args){return null;}
        /// <summary>
        /// Removes an event listener.  Supports the signature the event was bound
        /// with, but the preferred way to remove listeners is using the handle
        /// that is returned when using Y.on
        /// </summary>
        public object detach(object type, JsAction fn, object el){return null;}
        /// <summary>
        /// Generates an unique ID for the element if it does not already
        /// have one.
        /// </summary>
        public object generateId(object el){return null;}
        /// <summary>
        /// Finds the event in the window object, the caller's arguments, or
        /// in the arguments of another method in the callstack.  This is
        /// executed automatically for events registered through the event
        /// manager, so the implementer should not normally need to execute
        /// this function at all.
        /// </summary>
        public Event getEvent(Event e, object el){return null;}
        /// <summary>
        /// Returns all listeners attached to the given element via addListener.
        /// Optionally, you can specify a specific type of event to return.
        /// </summary>
        public CustomEvent getListeners(object el, object type){return null;}
        /// <summary>
        /// Executes the supplied callback when the item with the supplied
        /// id is found.  This is meant to be used to execute behavior as
        /// soon as possible as the page loads.  If you use this after the
        /// initial page load it will poll for a fixed time for the element.
        /// The number of times it will poll and the frequency are
        /// configurable.  By default it will poll for 10 seconds.
        /// <p>The callback is executed with a single parameter:
        /// the custom object parameter, if provided.</p>
        /// </summary>
        public void onAvailable(object id, JsAction fn, object p_obj, object p_override, object checkContent){}
        /// <summary>
        /// Works the same way as onAvailable, but additionally checks the
        /// state of sibling elements to determine if the content of the
        /// available element is safe to modify.
        /// <p>The callback is executed with a single parameter:
        /// the custom object parameter, if provided.</p>
        /// </summary>
        public void onContentReady(object id, JsAction fn, object obj, object @override){}
        /// <summary>
        /// Removes all listeners attached to the given element via addListener.
        /// Optionally, the node's children can also be purged.
        /// Optionally, you can specify a specific type of event to remove.
        /// </summary>
        public void purgeElement(object el, object recurse, object type){}
        /// <summary>
        /// Simulates the event with the given name on a target.
        /// </summary>
        public object simulate(object target, object type, object options){return null;}
        /// <summary>
        /// addListener/removeListener can throw errors in unexpected scenarios.
        /// These errors are suppressed, the method returns false, and this property
        /// is set
        /// </summary>
        public Y_.Do_.Error lastError{get;set;}
        /// <summary>
        /// The poll interval in milliseconds
        /// </summary>
        public int POLL_INTERVAL{get;set;}
        /// <summary>
        /// The number of times we should look for elements that are not
        /// in the DOM at the time the event is requested after the document
        /// has been loaded.  The default is 1000@amp;40 ms, so it will poll
        /// for 40 seconds or until all outstanding handlers are bound
        /// (whichever comes first).
        /// </summary>
        public int POLL_RETRYS{get;set;}
    }
}
