//***************************************************
//* This file was generated by tool
//* SharpKit
//***************************************************
using System;
using System.Collections.Generic;
using SharpKit.JavaScript;
namespace Y_
{
    /// <summary>
    /// <p>Wrapper class for the integration of new events into the YUI event
    /// infrastructure.  Don't instantiate this object directly, use
    /// <code>Y.Event.define(type, config)</code>.  See that method for details.</p>
    /// <p>Properties that MAY or SHOULD be specified in the configuration are noted
    /// below and in the description of <code>Y.Event.define</code>.</p>
    /// </summary>
    public partial class SyntheticEvent
    {
        /// <summary>
        /// Construction logic for the event.
        /// </summary>
        protected void _init(){}
        /// <summary>
        /// <p>Implementers MAY provide this method definition.</p>
        /// <p>Implement this function if you want extra data extracted during
        /// processArgs to be propagated to subscriptions on a per-node basis.
        /// That is to say, if you call <code>Y.on('xyz', fn, xtra, 'div')</code>
        /// the data returned from processArgs will be shared
        /// across the subscription objects for all the divs.  If you want each
        /// subscription to receive unique information, do that processing
        /// here.</p>
        /// <p>The default implementation adds the data extracted by processArgs
        /// to the subscription object as <code>sub._extra</code>.</p>
        /// </summary>
        public void applyArgExtras(object extra, object sub){}
        /// <summary>
        /// <p>Implementers SHOULD provide this method definition.</p>
        /// <p>Implementation logic for subscriptions done via
        /// <code>node.delegate(type, fn, filter)</code> or
        /// <code>Y.delegate(type, fn, container, filter)</code>.  Like with
        /// <code>on()</code> above, this function should monitor the environment
        /// for the event being fired, and trigger subscription execution by
        /// calling <code>notifier.fire(e)</code>.</p>
        /// <p>This function receives a fourth argument, which is the filter
        /// used to identify which Node's are of interest to the subscription.
        /// The filter will be either a boolean function that accepts a target
        /// Node for each hierarchy level as the event bubbles, or a selector
        /// string.  To translate selector strings into filter functions, use
        /// <code>Y.delegate.compileFilter(filter)</code>.</p>
        /// </summary>
        public void @delegate(Node node, object sub, Y_.SyntheticEvent_.Notifier notifier, object filter){}
        /// <summary>
        /// <p>Implementers SHOULD provide this method definition.</p>
        /// <p>Implementation logic for detaching subscriptions done via
        /// <code>node.on(type, fn)</code>.  This function should clean up any
        /// subscriptions made in the <code>on()</code> phase.</p>
        /// </summary>
        public void detach(Node node, object sub, Y_.SyntheticEvent_.Notifier notifier){}
        /// <summary>
        /// <p>Implementers SHOULD provide this method definition.</p>
        /// <p>Implementation logic for detaching subscriptions done via
        /// <code>node.delegate(type, fn, filter)</code> or
        /// <code>Y.delegate(type, fn, container, filter)</code>.  This function
        /// should clean up any subscriptions made in the
        /// <code>delegate()</code> phase.</p>
        /// </summary>
        public void detachDelegate(Node node, object sub, Y_.SyntheticEvent_.Notifier notifier, object filter){}
        /// <summary>
        /// Returns the array of subscription handles for a node for the given event
        /// type.  Passing true as the third argument will create a registry entry
        /// in the event system's DOM map to host the array if one doesn't yet exist.
        /// </summary>
        protected Y_.Array getRegistry(Node node, object type, object create){return null;}
        /// <summary>
        /// Returns the detach handles of subscriptions on a node that satisfy a
        /// search/filter function.  By default, the filter used is the
        /// <code>subMatch</code> method.
        /// </summary>
        public object getSubs(Node node, Y_.Array args, JsAction filter, object first){return null;}
        /// <summary>
        /// <p>Implementers SHOULD provide this method definition.</p>
        /// Implementation logic for subscriptions done via <code>node.on(type,
        /// fn)</code> or <code>Y.on(type, fn, target)</code>.  This
        /// function should set up the monitor(s) that will eventually fire the
        /// event.  Typically this involves subscribing to at least one DOM
        /// event.  It is recommended to store detach handles from any DOM
        /// subscriptions to make for easy cleanup in the <code>detach</code>
        /// method.  Typically these handles are added to the <code>sub</code>
        /// object.  Also for SyntheticEvents that leverage a single DOM
        /// subscription under the hood, it is recommended to pass the DOM event
        /// object to <code>notifier.fire(e)</code>.  (The event name on the
        /// object will be updated).
        /// </summary>
        public void on(Node node, object sub, Y_.SyntheticEvent_.Notifier notifier){}
        /// <summary>
        /// <p>Implementers MAY provide this method definition.</p>
        /// <p>Implement this function if the event supports a different
        /// subscription signature.  This function is used by both
        /// <code>on()</code> and <code>delegate()</code>.  The second parameter
        /// indicates that the event is being subscribed via
        /// <code>delegate()</code>.</p>
        /// <p>Implementations must remove extra arguments from the args list
        /// before returning.  The required args for <code>on()</code>
        /// subscriptions are</p>
        /// <pre><code>[type, callback, target, context, argN...]</code></pre>
        /// <p>The required args for <code>delegate()</code>
        /// subscriptions are</p>
        /// <pre><code>[type, callback, target, filter, context, argN...]</code></pre>
        /// <p>The return value from this function will be stored on the
        /// subscription in the '_extra' property for reference elsewhere.</p>
        /// </summary>
        public object processArgs(Y_.Array args, object @delegate){return null;}
        /// <summary>
        /// <p>Implementers MAY override this to define what constitutes a
        /// &quot;same&quot; subscription.  Override implementations should
        /// consider the lack of a comparator as a match, so calling
        /// <code>getSubs()</code> with no arguments will return all subs.</p>
        /// <p>Compares a set of subscription arguments against a Subscription
        /// object to determine if they match.  The default implementation
        /// compares the callback function against the second argument passed to
        /// <code>Y.on(...)</code> or <code>node.detach(...)</code> etc.</p>
        /// </summary>
        public object subMatch(object sub, Y_.Array args){return null;}
    }
}
